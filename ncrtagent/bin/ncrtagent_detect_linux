#!/usr/bin/perl

use strict;

our ($TOOLHOME, $PLUGINSDIR, $CONFDIR);
BEGIN {
	$0 =~ m"^(.*)/";
	$TOOLHOME = "$1/..";
	while( $TOOLHOME =~ s{(^|/)[^\.][^/]*/\.\.(/|$)}{$1} ){}
	$PLUGINSDIR = "$TOOLHOME/plugins";
	$CONFDIR = "$TOOLHOME/conf";
}
use lib "$TOOLHOME/lib/perl5";

if( @ARGV < 1 ){
	print "usage: % $0 SERVICE VSERVICE\n";
	exit 3;
}
my $service = $ARGV[0];
my $vservice = $ARGV[1] // $service;

# setup work directory
our $WORKDIR;
if( $ENV{'HOME'} ){ $WORKDIR = $ENV{'HOME'} . "/.ncrt"; }
else{
	my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $home, $shell, $expire ) = getpwuid $<;
	$WORKDIR = "$home/.ncrt";
}
unless( -d $WORKDIR ){ mkdir $WORKDIR or die "$WORKDIR: cannot create, stopped"; }

# metrics
my %m;
#
my @w;
my @c;

# read from service's output
my $f = "$PLUGINSDIR/ncrtagentmeasure_${service}_linux";
open my $e, '-|', "$f $CONFDIR $WORKDIR $vservice" or do {
	print "UNKNOWN $f: not found.\n";
	exit 3;
};
while( <$e> ){
	chomp;
	next if m"^\s*(#|$)";
	die "$_, stopped" unless m"^([-\.\w/\[\]]+)=(\S+)$";
	my $k = $1;
	my $v = $2;
	$m{$k} = $v;
}
close $e;

my $plugin_has_failed;
my $plugin_rc = $? >> 8;
if( $plugin_rc > 0 ){
	$plugin_has_failed = 1;
}

# statistics
my $f = "$CONFDIR/statistic/statistics.$vservice";
if( open my $h, '<', $f ){
	use NCRTStackMachine;
	use NCRTTimeSeries;
	my $memory = new_memory;
	my $timeseries = new_timeseries;
	load_timeseries $timeseries, "vservice", $WORKDIR;
	add_timeseries $timeseries, \%m;
	$memory->{IMPORT} = \%m;
	$memory->{TIMESERIES} = $timeseries;
	eval {
		while( <$h> ){
			chomp;
			evaluate_expr $memory, $_;
		}
	};
	if( $@ ){
		print "UNKNOWN $f: $@\n";
		exit 3;
	}
	close $h;
	while( my ($k, $v) = each %{$memory->{EXPORT}} ){ $m{$k} = $v; }
	my $lifetime = $memory->{TIMESERIES_LIFETIME};
	store_timeseries $timeseries, "vservice", $WORKDIR, $lifetime if $lifetime > 0;
}

# thresholds
my @wt;
my @ct;
# load thresholds
my $f = "$CONFDIR/threshold/thresholds.$vservice";
open my $h, '<', $f or do {
	print "UNKNOWN $f: not found.\n";
	exit 3;
};
while( <$h> ){
	chomp;
	next if m"^\s*(#|$)";
	unless( m"^(\S+)\s+(crit|warn)\s+\[\s*([-+]?\d+(?:\.\d+)?)\s*,\s*([-+]?\d+(?:\.\d+)?)\s*\]$" ){
		print "UNKNOWN $f:$.: illegal format in \"$_\".\n";
		exit 3;
	}
	my $itempattern = qr"^$1$";
	my $severity = $2;
	my $lower = $3;
	my $upper = $4;
	if    ( $severity eq 'crit' ){
		push @ct, [ $itempattern, $lower, $upper ];
	}elsif( $severity eq 'warn' ){
		push @wt, [ $itempattern, $lower, $upper ];
	}
}
close $h;

# threshold per metric
my %wm;
my %cm;

# select thretholds
foreach my $k ( keys %m ){
	foreach my $t ( @wt ){
		my ($re, $lower, $upper) = @$t;
		next unless $k =~ $re;
		$wm{$k} = [$lower, $upper];
	}
	foreach my $t ( @ct ){
		my ($re, $lower, $upper) = @$t;
		next unless $k =~ $re;
		$cm{$k} = [$lower, $upper];
	}
}

#
my @p;
foreach my $k ( sort keys %m ){
	my $v = $m{$k};
	my $critical_occurred;
	my ($min, $max);
	
	next unless $v =~ m"^([-+]?\d+(?:\.\d+)?)(.*)$";
	my $value = $1;
	my $unit = $2;
	if   ( $unit eq '%' ) { $min = '0.00'; $max = '100.00'; }
	elsif( $unit eq 'MB' ){ $min = '0.00'; }

	my $key_text = $unit ? "$k\[$unit\]" : "$k";

	my $c;
	if( $cm{$k} ){
		my ($lower, $upper) = @{$cm{$k}};
		$c = "$lower:$upper";
		if    ( $value < $lower ){
			push @c, "$key_text:${value}(lower-crit-thr:$lower)";
			$critical_occurred = 1;
		}elsif( $v > $upper ){
			push @c, "$key_text:${value}(upper-crit-thr:$upper)";
			$critical_occurred = 1;
		}
	}
	my $w;
	if( $wm{$k} ){
		my ($lower, $upper) = @{$wm{$k}};
		$w = "$lower:$upper";
		if    ( $critical_occurred ){
			# ignore
		}elsif( $value < $lower ){
			push @w, "$key_text:${value}(lower-warn-thr:$lower)";
		}elsif( $value > $upper ){
			push @w, "$key_text:${value}(upper-warn-thr:$upper)";
		}
	}
	my $p = "$k=$v;$w;$c;$min;$max";
	push @p, $p;
}

#
my $r = 'OK';
my $rc = 0;
my @r;
if( $plugin_has_failed ){
	$r = 'UNKNOWN';
	$rc = 3;
	push @r, "$service plugin has failed.";
}
elsif( @c ){ $r = 'CRIT'; $rc = 2; }
elsif( @w ){ $r = 'WARN';  $rc = 1; }

print join(' / ', $r, @r, @c, @w), "| ", join(' ', @p), "\n";
exit $rc;


