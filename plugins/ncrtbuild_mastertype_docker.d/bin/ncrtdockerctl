#!/usr/bin/perl

our $TOOLHOME;
BEGIN {
	$0 =~ m"^(.*)/";
	$TOOLHOME = ` cd "$1/.." && pwd || echo . `;
	chomp $TOOLHOME;
}
use lib "$TOOLHOME/lib/perl5";
our $SETTINGSDIR = "$TOOLHOME/containersettings";
our $DATADIR = "$TOOLHOME/containerdata";
our $PLUGINSCONFDIR = "$TOOLHOME/pluginsconf";

use strict;
use LWP::UserAgent;
use MIME::Base64;
use JSON;
use Carp::Always;

our $DOCKER_COMPOSE_CMD = "docker compose";
our $CONFIG = "$TOOLHOME/containers/docker-compose.yml";
our $PROJECT = "ncrtmaster";

our %CONFIG = (
	"GRAFANA_LOCALPORT"             => "3000",
	"INFLUXDB_LOCALPORT"            => "8086",

	"SERVERSIDE_PORT"		=> "7080",	
	"SERVERSIDE_PATH_PREFIX"	=> "/ncrt",	

	"BROWSERSIDE_URL_PREFIX"        => "http://localhost/",

);
our ($INFLUXDB_USER, $INFLUXDB_PASSWD);
our ($SERVERSIDE_PORT, $SERVERSIDE_PATH_PREFIX, $BROWSERSIDE_URL_PREFIX);
our ($GRAFANA_LOCALPORT, $INFLUXDB_LOCALPORT);
our %PASSWD;
our $UA = LWP::UserAgent->new;
our $JSON = JSON->new->canonical;
our $VERBOSE = 0;

STDOUT->autoflush(1);

#### fixed values
our $GRAFANA_DATAOWNER = "ncrt_gfdataowner";
our $GRAFANA_DATAOWNEREMAIL = 'ncrt_gfdataowner@example.com';
our $GRAFANA_ORG = "ncrt_gforg";
our $GRAFANA_DATASOURCE = "influxdb";
our $GRAFANA_DB = "ncrt_gfdb";

our $INFLUXDB_ADMIN = "ncrt_ifxadmin",
our $INFLUXDB_ORG = "ncrt_ifxorg";
our $INFLUXDB_BUCKET = "ncrt_ifxbucket";
our $INFLUXDB_OPTIONALBUCKET = "ncrt_ifxoptional";
our $INFLUXDB_ARCHIVEBUCKET  = "ncrt_ifxarchive";

####

sub usage () {
	print "usage: % $0 COMMAND [OPTIONS]\n",
		"\n",
		"Docker Operation Commands\n",
		"  start\n",
		"  stop\n",
		"  reload\n",
		"  reconfigure\n",
		"  rebuild\n",
		"  status\n",
		"\n",
		"Work Files Operation Commands\n",
		"  backup_workfiles  BACKUPDIR\n",
		"  restore_workfiles BACKUPDIR\n",
		"\n",
		"Terminal Operation Commands\n",
		"  bash_in_naemonvm\n",
		"  zsh_in_naemonvm\n",
		"  bash_in_influxdbvm\n",
		"  bash_in_grafanavm\n",
		"\n";

	exit 1;
}

sub timestamp ($) {
	my ($sec, $min, $hour, $day, $mon, $year) = localtime shift;
	return sprintf "%04d-%02d-%02d_%02d:%02d:%02d", $year+1900, $mon+1, $day, $hour, $min, $sec;
}

sub create_or_die ($) {
	my ($f) = @_;
	open my $h, '>', $f or die "$f: cannot create, stopped";
	close $h;
}

sub write_or_die ($$) {
	my ($f,$content) = @_;
	open my $h, '>', $f or die "$f: cannot open, stopped";
	print $h $content;
	close $h;
}

sub append_or_die ($$) {
	my ($f,$content) = @_;
	open my $h, '>>', $f or die "$f: cannot open, stopped";
	print $h $content;
	close $h;
}

sub read_or_die ($) {
	my ($f) = @_;
	open my $h, '<', $f or die "$f: cannot open, stopped";
	my $r = join "", <$h>;
	close $h;
	return $r;
}

sub mkdir_or_die ($) {
	my ($d) = @_;
	return if -d $d;
	mkdir $d or die "$d: cannot create, stopped";
}

sub rm_r_or_die ($) {
	my ($r) = @_;
	return unless -d $r;
	opendir my $d, $r or do {
		die "$r: cannot open, stopped";
	};
	my @e = readdir $d;
	foreach my $e ( @e ){
		next if $e eq '..' || $e eq '.';
		if( -d "$r/$e" && ! -l "$r/$e" ){
			rm_r_or_die( "$r/$e" );
		}else{
			unlink "$r/$e" or die "$r/$e, stopped";
		}
	}
	closedir $d;
	rmdir $r or die "$r: cannot remove, stopped";
}

sub system_or_die ($) {
	my ($cmd) = @_;
	my $r = system $cmd;
	if    ( $? == -1 ){
		die sprintf "%s: failed to execute: %d, stopped",
			$cmd, $!;
	}elsif( $? & 127 ){
		die sprintf "%s: child died with signal %d, %s coredump, stopped",
			$cmd, ($? & 127), ($? & 128) ? 'with' : 'without';
	}elsif( ($?>>8) != 0 ){
		 die sprintf "%s: child exited with value %d, stopped",
			$cmd, $? >> 8;
	}
}

sub with_trailing_slash ($) {
	my ($path) = @_;
	$path =~ s{/$}{};
	return "$path/";
}

sub load_config () {
	my $f = "$TOOLHOME/pluginsconf/mastertype/docker.conf";
	open my $h, "<", $f or die "$f: cannot open, stopped";
	while( <$h> ){
		chomp;
		next if m"^\s*(#|$)";
		die "$f:$.: invalid format, stopped" unless m"^(\w+)=(.*)";
		$CONFIG{$1} = $2;
	}
	close $h;

	$SERVERSIDE_PORT        = int $CONFIG{SERVERSIDE_PORT};
	$SERVERSIDE_PATH_PREFIX = with_trailing_slash $CONFIG{SERVERSIDE_PATH_PREFIX};
	$BROWSERSIDE_URL_PREFIX = with_trailing_slash $CONFIG{BROWSERSIDE_URL_PREFIX};
	$GRAFANA_LOCALPORT      = int $CONFIG{GRAFANA_LOCALPORT};
	$INFLUXDB_LOCALPORT     = int $CONFIG{INFLUXDB_LOCALPORT};
}

sub load_userprofiles ($) {
	my ($f) = @_;
	open my $h, "<", $f or return ();
	my %profiles;
	while( <$h> ){
		chomp;
		die "$f:$.: invalid format, stopped" unless m"^([^:\s\p{Cc}]+):(.*)$";
		my $username = $1;
		my $password = $2;
		$profiles{$username} = {
			"username" => $username,
			"password" => $password,
		};
	}
	close $h;
	return %profiles;
}

sub docker_is_running () {
	my $allstatuses = `$DOCKER_COMPOSE_CMD ls`;
	my @allstatuses = split m"\n", $allstatuses;
	shift @allstatuses;
	foreach( @allstatuses ){
		my ($project, $status, $config) = split m"\s+";
		next unless $project eq $PROJECT;
		next unless $config eq $CONFIG;
		return 1 if $status =~ m"^running";
	}
	return undef;
}

sub docker_is_exited () {
	my $allstatuses = `$DOCKER_COMPOSE_CMD ls -a`;
	my @allstatuses = split m"\n", $allstatuses;
	shift @allstatuses;
	foreach( @allstatuses ){
		my ($project, $status, $config) = split m"\s+";
		next unless $project eq $PROJECT;
		next unless $config eq $CONFIG;
		return 1 if $status =~ m"^exited";
	}
	return undef;
}

sub apache2_is_running () {
	my $stdout = `$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/apache2 status`;
	my $rc = $?;
	return 1 if $rc == 0;
	return undef;
}

sub naemon_is_running () {
	my $stdout = `$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/naemon status`;
	my $rc = $?;
	return 1 if $rc == 0;
	return undef;
}

sub nullmailer_is_running () {
	my $stdout = `$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/nullmailer status`;
	my $rc = $?;
	return 1 if $rc == 0;
	return undef;
}

sub grafana_port_is_working () {
	my $stdout = `curl -o /dev/null -s -w "%{http_code}\n" http://localhost:$GRAFANA_LOCALPORT/`;
	my $rc = $?;
	chomp $stdout;
	return undef unless $rc == 0;
	return undef unless $stdout eq "302";
	return 1;
}

sub influxdb_port_is_working () {
	my $stdout = `curl -o /dev/null -s -w "%{http_code}\n" http://localhost:$INFLUXDB_LOCALPORT/`;
	my $rc = $?;
	chomp $stdout;
	return undef unless $rc == 0;
	return undef unless $stdout eq "200";
	return 1;
}


####

sub setup_influxdb_admin () {
	my $influxdb_datadir = "$DATADIR/influxdb_var_lib_influxdb2";
	return if -f "$influxdb_datadir/influxdb_admin_has_been_setup";
	print "[setup_influxdb_admin]\n";

	my $influxdb_passwd = ` head -c 16 /dev/urandom | sha1sum | head -c 32 `;
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-influxdb " .
		"influx setup -f -o $INFLUXDB_ORG -r 52w -b $INFLUXDB_BUCKET " .
		" -u $INFLUXDB_ADMIN -p $influxdb_passwd --name default";
	write_or_die "$DATADIR/influxdb_passwd", $influxdb_passwd;

	create_or_die "$influxdb_datadir/influxdb_admin_has_been_setup";
}

sub setup_influxdb_bucket () {
	my $influxdb_datadir = "$DATADIR/influxdb_var_lib_influxdb2";
	return if -f "$influxdb_datadir/influxdb_org_has_been_setup";
	print "[setup_influxdb_bucket]\n";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-influxdb " .
		"influx bucket create -o $INFLUXDB_ORG -r 4w -n $INFLUXDB_OPTIONALBUCKET";
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-influxdb " .
		"influx bucket create -o $INFLUXDB_ORG -r 520w -n $INFLUXDB_ARCHIVEBUCKET";

	create_or_die "$influxdb_datadir/influxdb_org_has_been_setup";
}

sub setup_influxdb_token () {
	my $influxdb_datadir = "$DATADIR/influxdb_var_lib_influxdb2";
	return if -f "$influxdb_datadir/influxdb_token_has_been_setup";
	print "[setup_influxdb_token]\n";

	my $tokenname = "all-access_token_of_$INFLUXDB_ORG";
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-influxdb " .
		"influx auth create -o $INFLUXDB_ORG -d \Q$tokenname\E --all-access";
	my $cmd = "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-influxdb " .
		"influx auth list | " .
		"awk -v d=\Q$tokenname\E '\$2==d{print \$3}'";
	my $influxdb_token = ` $cmd `;
	chomp $influxdb_token;
	write_or_die "$DATADIR/influxdb_token", $influxdb_token;

	create_or_die "$influxdb_datadir/influxdb_token_has_been_setup";
}

sub req_grafanaapi ($$$;$) {
	my ($method, $path, $authtoken, $req_body) = @_;
	my $url = "http://localhost:$GRAFANA_LOCALPORT$path";
	my $req = HTTP::Request->new($method => $url);

	$req->header("Authorization" => $authtoken);

	if( $method eq "POST" || $method eq "PUT" ){
		$req->header("Content-Type" => "application/json");
		$req->content( $JSON->encode($req_body) );
	}

	my $res = $UA->request($req);
	my $status_line = $res->status_line;
	unless($res->is_success) {
		print "An error happened: $status_line\n";
		my $res_body = $res->decoded_content;
		print "Request: ", $JSON->encode($req_body), "\n";
		print "Reesponse: $status_line, $res_body\n";
		die;
	}
	print "Transfer went ok\n" if $VERBOSE;
	my $res_body = $res->decoded_content;
	print "Received response: $status_line, $res_body\n" if $VERBOSE;
	my $res_obj = $JSON->decode( $res_body );
	return $res_obj;
}

sub req_grafanaadminapi ($$;$) {
	my ($method, $path, $req_body) = @_;

	my $admin_passwd = read_or_die "$DATADIR/grafana_admin_passwd";
	my $authtoken = "Basic " . encode_base64 "admin:$admin_passwd", "";
	return req_grafanaapi $method, $path, $authtoken, $req_body;
}

sub req_grafanadataownerapi ($$;$) {
	my ($method, $path, $req_body) = @_;

	my $dataowner_passwd = read_or_die "$DATADIR/grafana_dataowner_passwd";
	my $authtoken = "Basic " . encode_base64 "$GRAFANA_DATAOWNER:$dataowner_passwd", "";
	return req_grafanaapi $method, $path, $authtoken, $req_body;
}

sub req_grafanasaapi ($$;$) {
	my ($method, $path, $req_body) = @_;

	my $satoken = read_or_die "$DATADIR/grafana_service_account_token";
	my $authtoken = "Bearer $satoken";
	return req_grafanaapi $method, $path, $authtoken, $req_body;
}

sub req_grafanaadminapi_search_all_users () {
	return req_grafanaadminapi("GET", "/api/users");
}

sub req_grafanaadminapi_search_all_orgs () {
	return req_grafanaadminapi("GET", "/api/orgs");
}

sub req_grafanaadminapi_create_user ($$$$) {
	my ($login, $email, $passwd, $is_admin) = @_;
	
	my $req = {
		"name" => $login,
		"login" => $login,
		"email" => $email,
		"password" => $passwd,
		"isAdmin" => $is_admin ? \1 : \0,
	};
	return req_grafanaadminapi("POST", "/api/admin/users", $req);
}

sub req_grafanaadminapi_update_user ($$$$$) {
	my ($id, $login, $email, $passwd, $is_admin) = @_;
	
	my $req = {
		"name" => $login,
		"login" => $login,
		"email" => $email,
		"password" => $passwd,
		"isAdmin" => $is_admin ? \1 : \0,
	};
	return req_grafanaadminapi("PUT", "/api/users/$id", $req);
}

sub req_grafanaadminapi_delete_user ($) {
	my ($id) = @_;
	return req_grafanaadminapi("DELETE", "/api/admin/users/$id");
}

sub req_grafanaadminapi_create_org ($) {
	my ($name) = @_;
	
	my $req = {
		"name" => $name,
	};
	return req_grafanaadminapi("POST", "/api/orgs", $req);
}

sub req_grafanaadminapi_delete_org ($) {
	my ($id) = @_;
	return req_grafanaadminapi("DELETE", "/api/orgs/$id");
}

sub req_grafanaadminapi_get_id_of_org ($) {
	my ($org_name) = @_;
	return req_grafanaadminapi("GET", "/api/orgs/name/$org_name");
}

sub req_grafanaadminapi_search_all_members_in_org ($) {
	my ($org_id) = @_;
	return req_grafanaadminapi("GET", "/api/orgs/$org_id/users");
}

sub req_grafanaadminapi_join_org ($$$) {
	my ($user_name, $role, $org_id) = @_;
	my $req = {
		"loginOrEmail" => $user_name,
		"role" => $role,
	};
	return req_grafanaadminapi("POST", "/api/orgs/$org_id/users", $req);
}

sub req_grafanaadminapi_switch_user_context ($$) {
	my ($user_id, $org_id) = @_;
	return req_grafanaadminapi("POST", "/api/users/$user_id/using/$org_id");
}

sub req_grafanadataownerapi_search_serviceaccounts () {
	return req_grafanadataownerapi("GET", "/api/serviceaccounts/search");
}

sub req_grafanadataownerapi_create_serviceaccount ($$$) {
	my ($name, $org_id, $role) = @_;
	
	my $req = {
		"name" => $name,
		"role" => $role,
		"orgId" => $org_id,
	};
	return req_grafanadataownerapi("POST", "/api/serviceaccounts", $req);
}

sub req_grafanadataownerapi_search_serviceaccount_tokens_of ($) {
	my ($sa_id) = @_;
	return req_grafanadataownerapi("GET", "/api/serviceaccounts/$sa_id/tokens");
}

sub req_grafanadataownerapi_delete_serviceaccount_token ($$) {
	my ($sa_id, $token_id) = @_;
	return req_grafanadataownerapi("DELETE", "/api/serviceaccounts/$sa_id/tokens/$token_id");
}

sub req_grafanadataownerapi_create_serviceaccount_token ($$) {
	my ($sa_id, $token_name) = @_;
	my $req = {
		"name" => $token_name,
	};
	return req_grafanadataownerapi("POST", "/api/serviceaccounts/$sa_id/tokens", $req);
}

sub req_grafanasaapi_search_datasources () {
	return req_grafanasaapi("GET", "/api/datasources");
}

sub req_grafanasaapi_create_datasource ($$$$$$$) {
	my ($name, $type, $url, $org_id, $access, $jsondata, $securejsondata) = @_;
	
	my $req = {
		"name" => $name,
		"type" => $type,
		"url" => $url,
#		"orgId" => $org_id,
		"access" => $access,
		"jsonData" => $jsondata,
		"secureJsonData" => $securejsondata,
	};
	return req_grafanasaapi("POST", "/api/datasources", $req);
}

####

sub setup_grafana_admin () {
	my $grafana_datadir = "$DATADIR/grafana_var_lib_grafana";
	return if -f "$grafana_datadir/grafana_admin_has_been_setup";
	print "[setup_grafana_admin]\n";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-grafana " .
		"grafana cli admin data-migration encrypt-datasource-passwords";
	sleep 3;

	my $admin_passwd = ` head -c 16 /dev/urandom | sha1sum | head -c 32 `;
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-grafana " .
		"grafana cli admin reset-admin-password \Q$admin_passwd\E";
	write_or_die "$DATADIR/grafana_admin_passwd", $admin_passwd;
	sleep 3;

	create_or_die "$grafana_datadir/grafana_admin_has_been_setup";
}

sub setup_grafana_dataowner () {
	my $grafana_datadir = "$DATADIR/grafana_var_lib_grafana";
	return if -f "$grafana_datadir/grafana_dataowner_has_been_setup";
	print "[setup_grafana_dataowner]\n";

	my $res = req_grafanaadminapi_search_all_users;
	my $target_id;
	foreach my $user ( @$res ){
		next unless $$user{login} eq $GRAFANA_DATAOWNER;
		$target_id = $$user{id};
		last;
	}

	my $dataowner_passwd = ` head -c 16 /dev/urandom | sha1sum | head -c 32 `;
	if    ( defined $target_id ){
		my $res = req_grafanaadminapi_update_user
			$target_id, $GRAFANA_DATAOWNER, $GRAFANA_DATAOWNEREMAIL, $dataowner_passwd, 0;
		sleep 3;
	}else{
		my $res = req_grafanaadminapi_create_user
			$GRAFANA_DATAOWNER, $GRAFANA_DATAOWNEREMAIL, $dataowner_passwd, 0;
		sleep 3;
	}
	write_or_die "$DATADIR/grafana_dataowner_passwd", $dataowner_passwd;

	create_or_die "$grafana_datadir/grafana_dataowner_has_been_setup";
}

sub setup_grafana_org () {
	my $grafana_datadir = "$DATADIR/grafana_var_lib_grafana";
	return if -f "$grafana_datadir/grafana_org_has_been_setup";
	print "[setup_grafana_org]\n";

	print "searching organization $GRAFANA_ORG...";
	my $res = req_grafanaadminapi_search_all_orgs;
	my $target_org_id;
	foreach my $org ( @$res ){
		next unless $$org{name} eq $GRAFANA_ORG;
		$target_org_id = $$org{id};
		last;
	}

	if    ( defined $target_org_id ){
		print "found.\n";
		# nothing to do
	}else{
		print "not found. creating...";
		my $res = req_grafanaadminapi_create_org $GRAFANA_ORG;
		$target_org_id = $$res{orgId};
		sleep 3;
		print "ok.\n";
	}

	print "searching user $GRAFANA_DATAOWNER in members of $GRAFANA_ORG...";
	my $res = req_grafanaadminapi_search_all_members_in_org $target_org_id;
	my $target_user_id;
	foreach my $user ( @$res ){
		next unless $$user{name} eq $GRAFANA_DATAOWNER;
		$target_user_id = $$user{userId};
		last;
	}

	if    ( defined $target_user_id ){
		print "found.\n";
		# nothing to do
	}else{
		print "not found. joining...";
		my $res = req_grafanaadminapi_join_org $GRAFANA_DATAOWNER, "Admin", $target_org_id;
		$target_user_id = $$res{userId};
		sleep 3;
		print "ok.\n";
	}

	print "switch context of user $GRAFANA_DATAOWNER to organization $GRAFANA_ORG...";
	my $res = req_grafanaadminapi_switch_user_context $target_user_id, $target_org_id;
	sleep 3;
	print "ok.\n";

	create_or_die "$grafana_datadir/grafana_org_has_been_setup";
}

sub setup_grafana_datasource () {
	my $grafana_datadir = "$DATADIR/grafana_var_lib_grafana";
	return if -f "$grafana_datadir/grafana_datasource_has_been_setup";
	print "[setup_grafana_datasource]\n";

	my $influxdb_token = read_or_die "$DATADIR/influxdb_token";

	print "getting id of organization $GRAFANA_ORG...";
	my $res = req_grafanaadminapi_get_id_of_org $GRAFANA_ORG;
	my $org_id = $$res{id};
	print "found. Id is $org_id.\n";

	print "searching data source $GRAFANA_DATASOURCE...";
	my $res = req_grafanasaapi_search_datasources;
	my $target_id;
	foreach my $datasource ( @$res ){
		next unless $$datasource{name} eq $GRAFANA_DATASOURCE;
		$target_id = $$datasource{id};
		last;
	}

	if    ( defined $target_id ){
		print "found. Id is $target_id.\n";
		# nothing to do
	}else{
		print "not found, creating...";
		my $jsondata = {
			"version" => "Flux",
			"organization"  => $INFLUXDB_ORG,
			"defaultBucket" => $INFLUXDB_BUCKET,
			"tlsSkipVerify" => \1,
		};
		my $securejsonfield = {
			"token" => $influxdb_token,
		};
		my $res = req_grafanasaapi_create_datasource $GRAFANA_DATASOURCE,
			"influxdb", "http://ncrt-influxdb:8086", $org_id, "proxy",
			$jsondata, $securejsonfield;
		sleep 3;
		print "ok.\n";
	}
	create_or_die "$grafana_datadir/grafana_datasource_has_been_setup";
}

sub setup_grafana_serviceaccount () {
	my $grafana_datadir = "$DATADIR/grafana_var_lib_grafana";
	return if -f "$grafana_datadir/grafana_serviceaccount_has_been_setup";
	print "[setup_grafana_serviceaccount]\n";

	print "getting id of organization $GRAFANA_ORG...";
	my $res = req_grafanaadminapi_get_id_of_org $GRAFANA_ORG;
	my $org_id = $$res{id};
	print "found. Id is $org_id.\n";

	print "serching service accounts of grafana data owner...";
	my $res = req_grafanadataownerapi_search_serviceaccounts;
	my $target_sa_id;
	foreach my $sa ( @{$$res{serviceAccounts}} ){
		print ".";
		my $sa_id       = $$sa{id};
		my $sa_name     = $$sa{name};
		my $sa_login    = $$sa{login};
		my $sa_org_id   = $$sa{orgId};
		my $sa_disabled = $$sa{isDisabled};
		if( $sa_name eq "${GRAFANA_DATAOWNER}_sa" ){
			$target_sa_id = $sa_id;
			last;
		}
	}
	
	if( defined $target_sa_id ){
		print "found ${GRAFANA_DATAOWNER}_sa.\n";
	}else{
		print "not found ${GRAFANA_DATAOWNER}_sa, creating...";
		my $res = req_grafanadataownerapi_create_serviceaccount "${GRAFANA_DATAOWNER}_sa", $org_id, "Admin";
		$target_sa_id = $$res{id};
		print "ok\n";
	}

	print "serching service account tokens of ${GRAFANA_DATAOWNER}_sa...";
	my $res = req_grafanadataownerapi_search_serviceaccount_tokens_of $target_sa_id;
	my $target_token_id;
	foreach my $token ( @$res ){
		print ".";
		my $token_id   = $$token{id};
		my $token_name = $$token{name};
		my $token_created    = $$token{created};
		my $token_lastusedat = $$token{lastUsedAt};
		my $token_expiration = $$token{expiration};
		if( $token_name eq "${GRAFANA_DATAOWNER}_token" ){
			$target_token_id = $token_id;
			last;
		}
	}

	if( defined $target_token_id ){
		print "found ${GRAFANA_DATAOWNER}_token, deleting...\n";
		my $res = req_grafanadataownerapi_delete_serviceaccount_token $target_sa_id, $target_token_id;
		print "ok\n";
	}else{
		print "not found ${GRAFANA_DATAOWNER}_token.\n";
	}

	print "creating service account token ${GRAFANA_DATAOWNER}_token...";
	my $res = req_grafanadataownerapi_create_serviceaccount_token $target_sa_id, "${GRAFANA_DATAOWNER}_token";
	my $key = $$res{key};
	print "ok\n";

	write_or_die "$DATADIR/grafana_service_account_token", $key;

	create_or_die "$grafana_datadir/grafana_serviceaccount_has_been_setup";
}

####

sub list_grafana_users () {
	my $res = req_grafanaadminapi_search_all_users;
	foreach my $user ( @$res ){
		my $id    = $$user{id};
		my $login = $$user{login};
		my $email = $$user{email};
		my $is_admin     = $$user{isAdmin};
		my $is_disabled  = $$user{isDisabled};
		my $last_seen_at = $$user{lastSeenAt};
		printf "%-3d %-12s %-40s %-5s %-8s %-s\n",
			$id, $login, $email,
			$is_admin ? "admin" : "user",
			$is_disabled ? "disabled" : "enabled",
			$last_seen_at;
	}
}

sub list_grafana_orgs () {
	my $res = req_grafanaadminapi_search_all_orgs;
	foreach my $org ( @$res ){
		my $id    = $$org{id};
		my $name = $$org{name};
		printf "%-3d %-20s\n", $id, $name;
	}
}

sub list_grafana_dataowners_serviceaccounts () {
	my $res = req_grafanadataownerapi_search_serviceaccounts;
	foreach my $sa ( @{$$res{serviceAccounts}} ){
		my $id       = $$sa{id};
		my $name     = $$sa{name};
		my $login    = $$sa{login};
		my $org_id   = $$sa{orgId};
		my $disabled = $$sa{isDisabled};
		printf "%-3d %-20s %-20s %2d %s\n",
			$id, $name, $login, $org_id, $disabled ? "disabled" : "enabled";
	}
}

sub list_grafana_dataowners_serviceaccount_tokens () {
	my $res = req_grafanadataownerapi_search_serviceaccounts;
	foreach my $sa ( @{$$res{serviceAccounts}} ){
		my $id       = $$sa{id};
		my $name     = $$sa{name};
		my $login    = $$sa{login};
		my $org_id   = $$sa{orgId};
		my $disabled = $$sa{isDisabled};
		my $res = req_grafanadataownerapi_search_serviceaccount_tokens_of $id;
		foreach my $token ( @$res ){
			my $token_id   = $$token{id};
			my $token_name = $$token{name};
			my $token_created    = $$token{created};
			my $token_lastusedat = $$token{lastUsedAt};
			my $token_expiration = $$token{expiration};
			printf "%-5s %-20s %2d %-20s %-20s %-20s %-20s\n",
				"$id.$token_id", $name, $org_id, $token_name,
				$token_created, $token_lastusedat // "never_used", $token_expiration // "unlimited";
		}
	}
}

sub list_grafana_dataowners_datasources () {
	my $res = req_grafanasaapi_search_datasources;
	foreach my $org ( @$res ){
		my $id    = $$org{id};
		my $name = $$org{name};
		printf "%-3d %-20s\n", $id, $name;
	}
}

sub create_grafana_user ($$$$) {
	my ($login, $email, $passwd, $is_admin) = @_;
	my $res = req_grafanaadminapi_create_user $login, $email, $passwd, $is_admin;
}

sub update_grafana_user ($$$$) {
	my ($login, $email, $passwd, $is_admin) = @_;
	my $res = req_grafanaadminapi_search_all_users;
	foreach my $user ( @$res ){
		next unless $$user{login} eq $login;
		my $res = req_grafanaadminapi_update_user $$user{id}, $login, $email, $passwd, $is_admin;
		return;
	}
	die;
}

sub delete_grafana_user ($) {
	my ($login) = @_;
	my $res = req_grafanaadminapi_search_all_users;
	foreach my $user ( @$res ){
		next unless $$user{login} eq $login;
		my $res = req_grafanaadminapi_delete_user $$user{id};
		return;
	}
	die;
}

sub create_grafana_org ($) {
	my ($name) = @_;
	my $res = req_grafanaadminapi_create_org $name;
}

sub delete_grafana_org ($) {
	my ($name) = @_;
	my $res = req_grafanaadminapi_search_all_orgs;
	foreach my $user ( @$res ){
		next unless $$user{name} eq $name;
		my $res = req_grafanaadminapi_delete_org $$user{id};
		return;
	}
	die;
}

sub create_grafana_datasource ($$$$) {
	my ($name, $type, $url, $org) = @_;
	my $res = req_grafanadataownerapi_create_datasource $name, $type, $url, $org;
}

####

sub add_or_update_users_of_grafana (\%@) {
	my ($profiles, @users) = @_;
	return unless @users;

	print "[add_or_update_users_of_grafana]\n";

	print "getting id of organization $GRAFANA_ORG...";
	my $res = req_grafanaadminapi_get_id_of_org $GRAFANA_ORG;
	my $org_id = $$res{id};
	print "found. Id is $org_id.\n";

	print "getting all existing users...";
	my $res = req_grafanaadminapi_search_all_users;
	my %existing_user_id;
	foreach my $user ( @$res ){
		$existing_user_id{ $$user{name} } = $$user{id};
	}
	my $num = keys %existing_user_id;
	print "done. found $num users.\n";

	print "getting all members of organization $GRAFANA_ORG...";
	my %joining_user_id;
	my $res = req_grafanaadminapi_search_all_members_in_org $org_id;
	foreach my $user ( @$res ){
		$joining_user_id{ $$user{name} } = $$user{userId};
	}
	my $num = keys %existing_user_id;
	print "done. found $num members.\n";

	print "creating or updating users...";
	foreach my $profile ( sort @users ){
		my $username = $$profile{username};
		my $passwd = $$profile{password};
		print "$username";

		my $user_id = $existing_user_id{$username};
		if( defined $user_id ){
			my $res = req_grafanaadminapi_update_user
				$user_id, $username, "$username\@example.com", $passwd, 0;
		}else{
			my $res = req_grafanaadminapi_create_user
				$username, "$username\@example.com", $passwd, 0;
			$user_id = $$res{id};
		}
		print ".";

		my $member_id = $joining_user_id{$username};
		if( defined $member_id ){
			# nothing to do
		}else{
			my $res = req_grafanaadminapi_join_org $username, "Viewer", $org_id;
		}
		print ".";

		my $res = req_grafanaadminapi_switch_user_context $user_id, $org_id;
		print ".";
	}
	print "ok.\n";
}

sub remove_users_of_grafana (\%@) {
	my ($profiles, @users) = @_;
	return unless @users;

	print "[remove_users_of_grafana]\n";

	print "getting id of organization $GRAFANA_ORG...";
	my $res = req_grafanaadminapi_get_id_of_org $GRAFANA_ORG;
	my $org_id = $$res{id};
	print "found. Id is $org_id.\n";

	print "getting all existing users...";
	my $res = req_grafanaadminapi_search_all_users;
	my %existing_user_id;
	foreach my $user ( @$res ){
		$existing_user_id{ $$user{name} } = $$user{id};
	}
	my $num = keys %existing_user_id;
	print "done. found $num users.\n";

	# TODO: implement
}


####

sub setup_apache_conf () {
	return if -f "$SETTINGSDIR/naemon_etc_apache2/ncrt_has_setup_these_conf_files";
	print "[setup_apache_conf]\n";

	my $domain = $BROWSERSIDE_URL_PREFIX;
	$domain =~ s|^.*://||;
	$domain =~ s|(:\d+)?(/.*)$||;

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon a2enmod headers";

	system_or_die "sed -i " .
		"-e \"s|^  Alias /thruk|  Alias ${SERVERSIDE_PATH_PREFIX}thruk|\" " .
		"-e \"s|^  AliasMatch \\^/thruk|  AliasMatch ^${SERVERSIDE_PATH_PREFIX}thruk|\" " .
		"-e \"s|^  <Location /thruk|  <Location ${SERVERSIDE_PATH_PREFIX}thruk|\" " .
		"$SETTINGSDIR/naemon_etc_apache2/conf-available/thruk.conf";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG cp " .
		"ncrt-naemon:/usr/share/thruk/thruk_cookie_auth.include " .
		"$SETTINGSDIR/naemon_etc_apache2/thruk_cookie_auth.include";

	system_or_die "sed -i " .
		"-e 's|\\^/thruk|^${SERVERSIDE_PATH_PREFIX}thruk|' " .
		"-e 's| /thruk/| ${SERVERSIDE_PATH_PREFIX}thruk/|' " .
		"$SETTINGSDIR/naemon_etc_apache2/thruk_cookie_auth.include";

	system_or_die "sed -i " .
		"-e 's|/usr/share/thruk/|/etc/apache2/|' " .
		"$SETTINGSDIR/naemon_etc_apache2/conf-available/thruk_cookie_auth_vhost.conf";

	append_or_die "$SETTINGSDIR/naemon_etc_apache2/sites-available/000-default.conf",
		"RequestHeader set Host $domain\n" .
		"ProxyPreserveHost On\n" .
		"ProxyPass        ${SERVERSIDE_PATH_PREFIX}grafana/ http://ncrt-grafana:3000/\n" .
		"ProxyPassReverse ${SERVERSIDE_PATH_PREFIX}grafana/ http://ncrt-grafana:3000/\n" .
		"\n" .
		"ProxyPass        ${SERVERSIDE_PATH_PREFIX}grafana-dashboard-helper/ http://localhost:46846/\n" .
		"ProxyPassReverse ${SERVERSIDE_PATH_PREFIX}grafana-dashboard-helper/ http://localhost:46846/\n" .
		"\n" .
		"Alias ${SERVERSIDE_PATH_PREFIX}ncrtmaster /var/www/html/ncrtmaster\n" .
#		"\n" .
#		"<Location ${SERVERSIDE_PATH_PREFIX}thruk/cgi-bin/restricted.cgi>\n" .
#		"	Options ExecCGI FollowSymLinks\n" .
#		"	AuthName \"Thruk Monitoring\"\n" .
#		"	AuthType Basic\n" .
#		"	AuthUserFile /etc/thruk/htpasswd\n" .
#		"	Require valid-user\n" .
#		"</Location>\n" .
		"\n";

	create_or_die "$SETTINGSDIR/naemon_etc_apache2/ncrt_has_setup_these_conf_files";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/apache2 reload";
	sleep 1;
}

sub setup_naemon_conf () {
	return if -f "$SETTINGSDIR/naemon_etc_naemon/ncrt_has_setup_these_conf_files";
	print "[setup_naemon_conf]\n";

	append_or_die "$SETTINGSDIR/naemon_etc_naemon/naemon.cfg",
		"process_performance_data=1\n" .
		"service_perfdata_file_processing_command=ncrt-process-service-perfdata-naemon2influx\n" .
		"service_perfdata_file_mode=a\n" .
		"service_perfdata_file_processing_interval=5\n" .
		"service_perfdata_file_template=\$TIMET\$\\t\$HOSTNAME\$\\t\$SERVICEDESC\$\\t\$SERVICESTATE\$\\t\$SERVICEPERFDATA\$\n" .
		"service_perfdata_file=/var/lib/naemon/service-perfdata\n";

	foreach my $f ( "conf.d/localhost.cfg", "conf.d/printer.cfg", "conf.d/switch.cfg", "conf.d/windows.cfg" ){
		unlink "$SETTINGSDIR/naemon_etc_naemon/$f" if -f "$SETTINGSDIR/naemon_etc_naemon/$f";
	}
	create_or_die "$SETTINGSDIR/naemon_etc_naemon/ncrt_has_setup_these_conf_files";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/naemon reload";
	sleep 1;
}

sub setup_naemon2influx_conf () {
	return if -f "$SETTINGSDIR/naemon_etc_naemon/ncrt_has_setup_naemon2influx_conf_files";
	print "[setup_naemon2influx_conf]\n";

	my $influxdb_token = read_or_die "$DATADIR/influxdb_token";

	write_or_die "$SETTINGSDIR/naemon_etc_naemon/naemon2influx.cfg",
		"perfdata=/var/lib/naemon/service-perfdata\n" .
		"perflineregexp=^(?<time>\\S+)\\t(?<hostname>\\S+)\\t(?<servicename>\\S+)\\t(?<state>\\S+)\\t(?<data>.*)\n" .
		"enable_optional_values=1\n" .
		"\n" .
		"measurement=ncrt_<servicename>,host=<hostname>\n" .
		"fieldkey=<label>\n" .
		"\n" .
		"apiver=2\n" .
		"output=http://ncrt-influxdb:8086/\n" .
		"org=$INFLUXDB_ORG\n" .
		"bucket=$INFLUXDB_BUCKET\n" .
		"token=$influxdb_token\n" .
		"\n" .
		"* if <name_of_optional_value> ne \"\"\n" .
		"	measurement=ncrt_<servicename>,host=<hostname>,option=<name_of_optional_value>\n" .
		"	#fieldkey=<label>.<name_of_optional_value>\n" .
		"	bucket=$INFLUXDB_OPTIONALBUCKET\n";

	create_or_die "$SETTINGSDIR/naemon_etc_naemon/ncrt_has_setup_naemon2influx_conf_files";
}

sub setup_thruk_conf () {
	return if -f "$SETTINGSDIR/naemon_etc_thruk/ncrt_has_setup_these_conf_files";
	print "[setup_thruk_conf]\n";

	my $domain = $BROWSERSIDE_URL_PREFIX;
	$domain =~ s|^.*://||;
	$domain =~ s|(:\d+)?(/.*)$||;

	system_or_die "sed -i " .
		"-e 's|action_url_target=.*|action_url_target=window|' " .
		"$SETTINGSDIR/naemon_etc_thruk/cgi.cfg";

#	system_or_die "sed -i " .
#		"-e \"s|^url_prefix = /|url_prefix = ${SERVERSIDE_PATH_PREFIX}|\" " .
#		"$SETTINGSDIR/naemon_etc_thruk/thruk.conf";
#
	write_or_die "$SETTINGSDIR/naemon_etc_default/thruk",
		"STARTURL=\"http://localhost${SERVERSIDE_PATH_PREFIX}thruk/cgi-bin/remote.cgi?startup\"";

	append_or_die "$SETTINGSDIR/naemon_etc_thruk/thruk_local.conf",
		"use_frames = 0\n" .
		"url_prefix = ${SERVERSIDE_PATH_PREFIX}\n" .
		"cookie_path = ${SERVERSIDE_PATH_PREFIX}thruk\n" .
		"cookie_auth_domain = $domain\n" .
		"cookie_auth_login_url = thruk/cgi-bin/login.cgi\n" .
		"cookie_auth_restricted_url = http://localhost${SERVERSIDE_PATH_PREFIX}thruk/cgi-bin/restricted.cgi\n" .
		"group_paging_overview = *30, 100, all\n" .
		"group_paging_summary  = *50, 100, all\n" .
		"group_paging_grid     = *30, 100, all\n" .
		"\n";

	create_or_die "$SETTINGSDIR/naemon_etc_thruk/htpasswd" unless -f "$SETTINGSDIR/naemon_etc_thruk/htpasswd";
	create_or_die "$SETTINGSDIR/naemon_etc_thruk/ncrt_has_setup_these_conf_files";

	foreach my $i ( 1..60 ){
		my $stdout = `$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/thruk reload`;
		my $r = $?;
		return 1 if $r == 0;
		print "setup_thruk_conf: $stdout (rc=$r), retrying...";
		sleep 1;
	}
	die "setup_thruk_conf: failed to reload thruk, stopped";
}

sub setup_grafana_dashboard_helper_conf () {
	return if -f "$SETTINGSDIR/naemon_etc_grafana-dashboard-helper/ncrt_has_setup_these_conf_files";
	print "[setup_grafana_dashboard_helper_conf]\n";

	my $satoken = read_or_die "$DATADIR/grafana_service_account_token";
	my $influxdb_token = read_or_die "$DATADIR/influxdb_token";

	write_or_die "$SETTINGSDIR/naemon_etc_grafana-dashboard-helper/grafana-dashboard-helper.conf",
		"GDHLISTENADDR=0.0.0.0\n" .
		"GDHLISTENPORT=46846\n" .
		"GDHURL=${BROWSERSIDE_URL_PREFIX}grafana-dashboard-helper/\n" .
		"GDHGRAFANAURL=${BROWSERSIDE_URL_PREFIX}grafana/\n" .
		"\n" .
		"GRAFANAURL=http://ncrt-grafana:3000/\n" .
		"GRAFANATOKEN=$satoken\n" .
		"GRAFANADATASOURCE=$GRAFANA_DATASOURCE\n" .
		"\n" .
		"INFLUXDBURL=http://ncrt-influxdb:8086/\n" .
		"INFLUXDBBUCKET=$INFLUXDB_BUCKET\n" .
		"INFLUXDBORG=$INFLUXDB_ORG\n" .
		"INFLUXDBTOKEN=$influxdb_token\n" .
		"\n" .
		"DEBUG=1\n" .
		"\n" .
		"PLUGIN_NCRT_OPTIONALBUCKET=$INFLUXDB_OPTIONALBUCKET\n" .
		"PLUGIN_NCRT_GENERIC_PANELPRIORITY=50\n" .
		"PLUGIN_GENERIC_PANELPRIORITY=90\n";

	create_or_die "$SETTINGSDIR/naemon_etc_grafana-dashboard-helper/ncrt_has_setup_these_conf_files";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/grafana-dashboard-helper reload";
	sleep 1;
}

sub setup_nullmailer_conf () {
	my $smtp_server = $CONFIG{SMTP_SERVER};
	my $smtp_origindomain = $CONFIG{SMTP_ORIGINDOMAIN};
	return if $smtp_server eq "";

	return if -f "$SETTINGSDIR/naemon_etc_nullmailer/ncrt_has_setup_these_conf_files";
	print "[setup_nullmailer_conf]\n";

	write_or_die "$SETTINGSDIR/naemon_etc_nullmailer/remotes", "$smtp_server\n";

	write_or_die "$SETTINGSDIR/naemon_etc_nullmailer/defaulthost", "$smtp_origindomain\n"
		if $smtp_origindomain ne "";

	create_or_die "$SETTINGSDIR/naemon_etc_nullmailer/ncrt_has_setup_these_conf_files";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/nullmailer reload";

	foreach my $i ( 1..10 ){
		sleep 1;
		return if nullmailer_is_running;
	}
	die "nullmailer is not running, stopped";
}

sub setup_syslogng () {
	my $syslog_server = $CONFIG{SYSLOG_SERVER};
	return if $syslog_server eq "";

	return if -f "$SETTINGSDIR/naemon_etc_syslog-ng/ncrt_has_setup_these_conf_files";
	print "[setup_syslog-ng]\n";

	write_or_die "$SETTINGSDIR/naemon_etc_syslog-ng/syslog.conf",
		"\@version: 3.38\n" .
		"\n" .
		"options { chain_hostnames(off); flush_lines(0); use_dns(no); use_fqdn(no); dns_cache(no); owner(\"root\"); group(\"adm\"); perm(0640); stats_freq(0); };\n" .

		"\n" .
		"source s_src { system(); };\n" .
		"\n" .
		"destination d_syslog { file(\"/var/log/syslog\"); };\n" .
		"destination d_auth { file(\"/var/log/auth.log\"); };\n" .
		"destination d_cron { file(\"/var/log/cron.log\"); };\n" .
		"destination d_mail { file(\"/var/log/mail.log\"); };\n" .
		"destination d_user { file(\"/var/log/user.log\"); };\n" .
		"\n" .
		"filter f_syslog { facility(syslog, daemon) and not level(debug); };\n" .
		"filter f_auth { facility(auth, authpriv) and not level(debug); };\n" .
		"filter f_cron { facility(cron) and not level(debug); };\n" .
		"filter f_mail { facility(mail) and not level(debug); };\n" .
		"filter f_user { not facility(syslog, daemon, auth, authpriv, cron, mail) and not level(debug); };\n" .
		"\n" .
		"log { source(s_src); filter(f_syslog); destination(d_syslog); };\n" .
		"log { source(s_src); filter(f_auth); destination(d_auth); };\n" .
		"log { source(s_src); filter(f_cron); destination(d_cron); };\n" .
		"log { source(s_src); filter(f_mail); destination(d_mail); };\n" .
		"log { source(s_src); filter(f_user); destination(d_user); };\n" .
		"\n" .
		"\@include \"/etc/syslog-ng/conf.d/*.conf\"\n" .
		"\n";

	create_or_die "$SETTINGSDIR/naemon_etc_syslog-ng/ncrt_has_setup_these_conf_files";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/syslog-ng restart";
	sleep 1;
}

sub setup_cron () {
	return if -f "$SETTINGSDIR/naemon_etc_cron.d_ncrtmaster";
	print "[setup_cron]\n";

	write_or_die "$SETTINGSDIR/naemon_etc_cron.d_ncrtmaster",
		"* * * * * naemon /opt/ncrtmaster/bin/ncrtreport cron\n";
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG cp $SETTINGSDIR/naemon_etc_cron.d_ncrtmaster ncrt-naemon:/etc/cron.d/ncrtmaster";
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/cron reload";
	sleep 1;
}


####

sub cmp_old_and_new_userprofiles () {
	my %new_profiles  = load_userprofiles "$PLUGINSCONFDIR/mastertype/docker.userprofiles";
	my %last_profiles = load_userprofiles "$SETTINGSDIR/userprofiles";

	my @addlist;
	while( my ($username, $p) = each %new_profiles ){
		push @addlist, $p unless defined $last_profiles{$username};
	}
	my @removelist;
	while( my ($username, $p) = each %last_profiles ){
		push @removelist, $p unless defined $new_profiles{$username};
	}
	my @updatelist;
	while( my ($username, $new_profile) = each %new_profiles ){
		my $last_profile = $last_profiles{$username};
		next unless defined $last_profile;

		my $new_p  = $JSON->encode( $new_profile );
		my $last_p = $JSON->encode( $last_profile );
		next if $new_p eq $last_p;

		push @updatelist, $new_profile;
	}

	return \%new_profiles, \@addlist, \@removelist, \@updatelist;
}

sub add_users_of_thruk_htpasswd (\%@) {
	my ( $profiles, @addlist ) = @_;
	return unless @addlist;
	print "[add_users_of_thruk]\n";

	foreach my $profile ( @addlist ){
		my $username = $$profile{username};
		my $password = $$profile{password};
		system_or_die "htpasswd -b -2 $SETTINGSDIR/naemon_etc_thruk/htpasswd $username \Q$password\E";
	}
}

sub remove_users_of_thruk_htpasswd (\%@) {
	my ( $profiles, @removelist ) = @_;
	return unless @removelist;
	print "[remove_users_of_thruk]\n";
	# TODO: implement
}

sub update_users_of_thruk_htpasswd (\%@) {
	my ( $profiles, @updatelist ) = @_;
	return unless @updatelist;
	print "[update_users_of_thruk]\n";
	foreach my $profile ( @updatelist ){
		my $username = $$profile{username};
		my $password = $$profile{password};
		system_or_die "htpasswd -b -2 $SETTINGSDIR/naemon_etc_thruk/htpasswd $username \Q$password\E";
	}
}

sub replace_old_userprofiles_with_new () {
	system_or_die "cp $PLUGINSCONFDIR/mastertype/docker.userprofiles $SETTINGSDIR/userprofiles";
}

####

sub setup_influxdb () {
	setup_influxdb_admin;
	setup_influxdb_bucket;
	setup_influxdb_token;
}

sub setup_grafana () {
	setup_grafana_admin;
	setup_grafana_dataowner;
	setup_grafana_org;
	setup_grafana_serviceaccount;
	setup_grafana_datasource;
}

sub setup_userprofiles () {
	my ($profiles, $addlist, $removelist, $updatelist) = cmp_old_and_new_userprofiles;

	create_or_die "$SETTINGSDIR/naemon_etc_thruk/htpasswd" unless -f "$SETTINGSDIR/naemon_etc_thruk/htpasswd";
	add_users_of_thruk_htpasswd    %$profiles, @$addlist;
	remove_users_of_thruk_htpasswd %$profiles, @$removelist;
	update_users_of_thruk_htpasswd %$profiles, @$updatelist;

	add_or_update_users_of_grafana %$profiles, @$addlist, @$updatelist;
	remove_users_of_grafana        %$profiles, @$removelist;

	replace_old_userprofiles_with_new;
}

sub setup () {
	exit 2 unless docker_is_running;

	foreach my $i ( 1..60 ){
		last if apache2_is_running and naemon_is_running;
		sleep 1;
	}
	setup_influxdb;
	setup_grafana;
	setup_apache_conf;
	setup_naemon_conf;
	setup_thruk_conf;
	setup_naemon2influx_conf;
	setup_grafana_dashboard_helper_conf;
	setup_syslogng;
	setup_nullmailer_conf;
	setup_cron;
	setup_userprofiles;

	return;
}

sub unsetup () {
	exit 4 if docker_is_running;
	foreach my $d (
		"naemon_etc_apache2", "naemon_etc_default",
		"naemon_etc_grafana-dashboard-helper",
		"naemon_etc_naemon",
		"naemon_etc_nullmailer",
		"naemon_etc_thruk",
		"naemon_etc_syslog-ng",
	) {
		rm_r_or_die "$SETTINGSDIR/$d";
	}
	foreach my $f ("naemon_etc_cron.d_ncrtmaster", "userprofiles"){
		next unless -f "$SETTINGSDIR/$f";
		unlink "$SETTINGSDIR/$f" or die "cannot remove, stopped";
	}
}

sub build () {
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG build";
}

sub down () {
	return unless docker_is_running || docker_is_exited;
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG down";
}

#### Sub Commands

sub bash_in_naemonvm () {
	exit 2 unless docker_is_running;
	my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell, $expire) = getpwuid $<;

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG cp $dir/.bashrc ncrt-naemon:/root/.bashrc" 
		if -f "$dir/.bashrc";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon bash";
}

sub zsh_in_naemonvm () {
	exit 2 unless docker_is_running;
	my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell, $expire) = getpwuid $<;

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG cp $dir/.zshrc ncrt-naemon:/root/.zshrc" 
		if -f "$dir/.zshrc";

	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon zsh";
}

sub bash_in_influxdbvm () {
	exit 2 unless docker_is_running;
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-influxdb bash";
}

sub bash_in_grafanavm () {
	exit 2 unless docker_is_running;
	system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-grafana bash";
}

sub backup_workfiles ($) {
	my ($dir) = @_;
	exit 2 unless docker_is_running;
	mkdir_or_die $dir;
	system_or_die "rsync -aSx --delete --chown=root:root --blocking-io -e \Q$DOCKER_COMPOSE_CMD -f $CONFIG exec -i\E ncrt-naemon:/var/lib/naemon/.ncrt/ $dir/ncrt/";
	system_or_die "rsync -aSx --delete --chown=root:root --blocking-io -e \Q$DOCKER_COMPOSE_CMD -f $CONFIG exec -i\E ncrt-naemon:/var/www/html/ncrtmaster/ $dir/ncrtmaster/";
}

sub restore_workfiles ($) {
	my ($dir) = @_;
	exit 2 unless docker_is_running;
	system_or_die "rsync -aSx --delete --chown=naemon:naemon --blocking-io -e \Q$DOCKER_COMPOSE_CMD -f $CONFIG exec -i\E $dir/ncrt/ ncrt-naemon:/var/lib/naemon/.ncrt/";
	system_or_die "rsync -aSx --delete --chown=naemon:naemon --blocking-io -e \Q$DOCKER_COMPOSE_CMD -f $CONFIG exec -i\E $dir/ncrtmaster/ ncrt-naemon:/var/www/html/ncrtmaster/";
}

sub status () {
	exit 2 unless docker_is_running;
	exit 3 unless naemon_is_running;
	print "running.\n";
	exit 0;
}

sub reload () {
	exit 2 unless docker_is_running;

	system_or_die "rsync -ax $TOOLHOME/naemondef/  $SETTINGSDIR/naemon_etc_naemon/conf.d/";
	if( naemon_is_running ){
		system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/naemon reload";
	}else{
		system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG exec ncrt-naemon /etc/init.d/naemon start";
	}
}

sub start () {
	if( docker_is_running ){
		return;
	}

	if( docker_is_exited ){
		system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG start";
	}else{
		system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG build";
		system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG up -d";
	}

	foreach my $i ( 1..60 ){
		last if influxdb_port_is_working and grafana_port_is_working;
		sleep 1;
	}
}

sub stop () {
	if( docker_is_exited ){
		return;
	}

	if( docker_is_running ){
		system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG stop";
	}
}

sub cron_job () {
	my $r = ` docker inspect ncrt-naemon | jq -r '.[0].State.Status, .[0].State.Health.Status, .[0].State.Health.FailingStreak' `;
	my ($container_status, $status, $failnum) = split m"\n", $r;
	my $now = timestamp time;
	my $restart_status_file = "$DATADIR/ncrt-naemon_is_restaring_now";

	if( $container_status eq "exited" ){
		if( -f $restart_status_file ){
		        print "[$now] starting...";
			system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG start ncrt-naemon";
		        print "\n";
			unlink $restart_status_file;
		}

	}elsif( $status eq "healthy" ){
		unlink $restart_status_file if -f $restart_status_file;

	}elsif( $status eq "unhealthy" ){
		if( $failnum > 3 ){
		        print "[$now] restarting...";
			create_or_die $restart_status_file;
			system_or_die "$DOCKER_COMPOSE_CMD -f $CONFIG restart ncrt-naemon";
		        print "\n";
			unlink $restart_status_file;
		}

	}else{
		die;
	}
}


####

if( @ARGV < 1 ){
	usage;
}

load_config;

my $subcmd = $ARGV[0];
shift @ARGV;
if( $ARGV[0] eq "-v" ){
	$VERBOSE = 1;
	shift @ARGV;
}

if    ( $subcmd eq "start" ){
	start;
	sleep 3;
	setup;
	reload;
}elsif( $subcmd eq "stop" ){
	stop;
}elsif( $subcmd eq "restart" ){
	stop;
	start;
	sleep 3;
	setup;
	reload;
}elsif( $subcmd eq "status" ){
	status;
}elsif( $subcmd eq "setup" ){
	setup;
}elsif( $subcmd eq "reload" ){		# reload naemon settings
	reload;
}elsif( $subcmd eq "reconfigure" ){	# remove all ncrt container settings and setup
	stop;
	unsetup;
	start;
	sleep 3;
	setup;
	reload;

}elsif( $subcmd eq "rebuild" ){		# down ncrt containers and build
	build;
	down;
	unsetup;
	start;
	sleep 3;
	setup;
	reload;

## Terminal operation
}elsif( $subcmd eq "bash_in_naemonvm" ){
	bash_in_naemonvm;
}elsif( $subcmd eq "zsh_in_naemonvm" ){
	zsh_in_naemonvm;
}elsif( $subcmd eq "bash_in_influxdbvm" ){
	bash_in_influxdbvm;
}elsif( $subcmd eq "bash_in_grafanavm" ){
	bash_in_grafanavm;

## Work files operation
}elsif( $subcmd eq "backup_workfiles" ){
	my $dir = $ARGV[0];
	exit 5 if $dir eq "";
	backup_workfiles $dir;
}elsif( $subcmd eq "restore_workfiles" ){
	my $dir = $ARGV[0];
	exit 5 if $dir eq "";
	exit 6 unless -d $dir;
	restore_workfiles $dir;


## Grafana operation
}elsif( $subcmd eq "list_grafana_users" ){
	list_grafana_users;
}elsif( $subcmd eq "list_grafana_orgs" ){
	list_grafana_orgs;
}elsif( $subcmd eq "list_grafana_dataowners_serviceaccounts" ){
	list_grafana_dataowners_serviceaccounts;
}elsif( $subcmd eq "list_grafana_dataowners_serviceaccount_tokens" ){
	list_grafana_dataowners_serviceaccount_tokens;
}elsif( $subcmd eq "list_grafana_dataowners_datasources" ){
	list_grafana_dataowners_datasources;
}elsif( $subcmd eq "create_grafana_user" ){
	die if @ARGV < 4;
	my ($login, $email, $passwd, $is_admin) = @ARGV;
	create_grafana_user $login, $email, $passwd, $is_admin;
}elsif( $subcmd eq "update_grafana_user" ){
	die if @ARGV < 4;
	my ($login, $email, $passwd, $is_admin) = @ARGV;
	update_grafana_user $login, $email, $passwd, $is_admin;
}elsif( $subcmd eq "delete_grafana_user" ){
	die if @ARGV < 1;
	my ($login) = @ARGV;
	delete_grafana_user $login;
}elsif( $subcmd eq "create_grafana_org" ){
	die if @ARGV < 1;
	my ($login) = @ARGV;
	create_grafana_org $login;
}elsif( $subcmd eq "delete_grafana_org" ){
	die if @ARGV < 1;
	my ($login) = @ARGV;
	delete_grafana_org $login;
}elsif( $subcmd eq "create_grafana_datasource" ){
	die if @ARGV < 4;
	my ($name, $type, $url, $org) = @ARGV;
	create_grafana_datasource $name, $type, $url, $org;
}elsif( $subcmd eq "cron" ){
	cron_job;

##
}else{
	usage;
}


