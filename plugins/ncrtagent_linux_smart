#!/usr/bin/perl

use strict;
use JSON::PP;

if( @ARGV < 5 ){
	print "usage: % $0 CONFDIR WORKDIR MEASURE HOST SERVICE\n";
	exit 1;
}

our $CONFDIR = $ARGV[0];
our $WORKDIR = $ARGV[1];
our $MEASURE = $ARGV[2];
our $HOST    = $ARGV[3];
our $SERVICE = $ARGV[4];

our $JSONCODEC = JSON::PP->new;
our $LONGTERM_H = 24;

####
sub n ($) {
	return sprintf "%.2f", $_[0];
}
sub nP ($) {
	return sprintf "%.2f%%", $_[0];
}
sub nMB ($) {
	return sprintf "%.2fMB", $_[0];
}

sub var2ltsv ( \% ){
	my ($var) = @_;
	my @ltsv;
	push @ltsv, "timestamp:".$var->{timestamp} if defined $var->{timestamp};
	foreach my $k ( sort {$a cmp $b} keys %$var ){
		next if $k eq 'timestamp';
		push @ltsv, "$k:".$var->{$k};
	}
	return join "\t", @ltsv;
}

sub ltsv2var ( $ ){
	my ($ltsv) = @_;
	my %var;
	foreach my $kv ( split m"\t", $ltsv ){
		$kv =~ m"^([-./\[\]\w]+):(.*)$" or do {
			next;
		};
		my $k = $1;
		my $v = $2;
		$var{$k} = $v;
	}
	return %var;
}

sub calc_delta ($$\%) {
	my ($f, $longterm_h, $curr) = @_;
	my @history;

	my $now = time;
	my $longterm_limit  = $now - $longterm_h * 60 * 60;
	my $shortterm_limit = $now - 59;

	# load history
	if( open my $h, '<', $f ){
		while( <$h> ){
			chomp;
			my %v = ltsv2var $_;
			push @history, \%v;
		}
		close $h;
	}

	# search origin
	my $shortterm_origin;
	foreach my $e ( @history ){
		last	if $e->{timestamp} > $shortterm_limit;
		$shortterm_origin = $e;
	}
	my $longterm_origin;
	foreach my $e ( @history ){
		last	if $e->{timestamp} > $shortterm_limit;
		last	if $e->{timestamp} > $longterm_limit and
			defined $longterm_origin;
		$longterm_origin = $e;
	}

	# store history
	open my $h, '>', "$f.$$" or do {
		die "$f.$$: cannot open, stopped";
	};
	push @history, { 'timestamp' => $now,  %$curr };
	foreach my $e ( @history ){
		next if $e->{timestamp} < $longterm_limit;
		print $h var2ltsv( %$e ), "\n";
	}
	close $h;
	unlink $f;
	rename "$f.$$", $f;

	# calc difference
	my %shortterm_delta;
	my %shortterm_diff;
	if( $shortterm_origin ){
		my $deltat = $now - $shortterm_origin->{timestamp};
		while( my ($k, $v) = each %$curr ){
			my $v2 = $shortterm_origin->{$k} // next;
			my $deltav = $v - $v2;
			next if $deltav < 0;
			$shortterm_delta{$k} = $deltav / $deltat;
			$shortterm_diff{$k}  = $deltav;
		}
	}
	my %longterm_delta;
	my %longterm_diff;
	if( $longterm_origin ){
		my $deltat = $now - $longterm_origin->{timestamp};
		while( my ($k, $v) = each %$curr ){
			my $v2 = $longterm_origin->{$k} // next;
			my $deltav = $v - $v2;
			next if $deltav < 0;
			$longterm_delta{$k} = $deltav / $deltat;
			$longterm_diff{$k}  = $deltav;
		}
	}

	return \%shortterm_delta, \%longterm_delta, \%shortterm_diff, \%longterm_diff;
}

sub toMiB (@) {
	my @r;
	foreach( @_ ){
		unless( m"^(\d+(?:\.\d+)?)(k|ki|M|Mi|G|Gi)B$" ){
			push @r, $_;
			next;
		}
		if   ( $2 eq "k"  ){ push @r, $1 * 1000 / 1024 / 1024; }
		elsif( $2 eq "ki" ){ push @r, $1 / 1024 ; }
		elsif( $2 eq "M"  ){ push @r, $1 * 1000 * 1000 / 1024 / 1024; }
		elsif( $2 eq "Mi" ){ push @r, $1 ; }
		elsif( $2 eq "G"  ){ push @r, $1 * 1000 * 1000 * 1000 / 1024 / 1024 / 1024; }
		elsif( $2 eq "Gi" ){ push @r, $1 * 1024 ; }
	}
	return @r;
}

sub toGiB (@) {
	my @r;
	foreach( @_ ){
		unless( m"^(\d+(?:\.\d+)?)(k|ki|M|Mi|G|Gi)B$" ){
			push @r, $_;
			next;
		}
		if   ( $2 eq "k"  ){ push @r, $1 * 1000 / 1024 / 1024 / 1024; }
		elsif( $2 eq "ki" ){ push @r, $1 / 1024 / 1024 ; }
		elsif( $2 eq "M"  ){ push @r, $1 * 1000 * 1000 / 1024 / 1024 / 1024; }
		elsif( $2 eq "Mi" ){ push @r, $1 / 1024 ; }
		elsif( $2 eq "G"  ){ push @r, $1 * 1000 * 1000 * 1000 / 1024 / 1024 / 1024 / 1024; }
		elsif( $2 eq "Gi" ){ push @r, $1 ; }
	}
	return @r;
}

####

my @category_rules;
my $f = "$CONFDIR/agent/networktraffic.conf.$HOST.$SERVICE";
if( open my $h, '<', $f ){
	while( <$h> ){
		chomp;
		next if m"^\s*($|#)";
		die "$f:$.: illegal format, stopped" unless m"^(\w+)=(.*)$";
		$LONGTERM_H = 0 + $2 if $1 eq 'LONGTERM_H';
	}
	close $h;
}
#### parse setting
my $sudo;
my %must_exist;
my %must_not_exist;

my $f = "$CONFDIR/agent/smart.conf.$HOST.$SERVICE";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	next if m"^\s*(#|$)";
	if( m"^(\w+)=(.*)$" ){
		my $paramname = $1;
		my $paramvalues = $2;

		if    ( $paramname eq "SUDO" ){
			if( $paramvalues =~ m"^(yes|true)$"i ){ $sudo = 1; }
			else{ $sudo = undef; }
		}elsif( $paramname eq "MUST_EXIST" ){
			foreach my $i ( split m"(\s+|,)", $paramvalues ){
				next if $i eq "";
				$must_exist{$i} = 1;
			}
		}elsif( $paramname eq "MUST_NOT_EXIST" ){
			foreach my $i ( split m"(\s+|,)", $paramvalues ){
				next if $i eq "";
				$must_not_exist{$i} = 1;
			}
		}
	}else{
		die "$f:$.: illegal format, stopped";
	}
}
close $h;

####
my %r;
my %d;
my %existing;

my @devices;
my $cmd;
if( $sudo ){
	$cmd = "sudo /usr/sbin/smartctl --scan";
}else{
	$cmd = "/usr/sbin/smartctl --scan";
}
open my $h, '-|', $cmd or do {
	die "$cmd: cannot execute, stopped";
};
while( <$h> ){
	chomp;
	next unless m"^/dev/(\w+)\s+-d\s+(\w+)(?:\s+#\s+(.*))?$";
	my $device     = $1;
	my $devicetype = $2;
	my $comment    = $3;
	push @devices, {
		device     => $device,
		devicetype => $devicetype,
		comment    => $comment,
	};
	$existing{$device} = 1;
}
close $h;

foreach my $d ( @devices ){
	my $device     = $$d{device};
	my $devicetype = $$d{devicetype};

	my $cmd;
	if( $sudo ){ $cmd = "sudo /usr/sbin/smartctl -a /dev/$device -d $devicetype"; }
	else       { $cmd = "/usr/sbin/smartctl -a /dev/$device -d $devicetype"; }
	my %t;
	open my $h, '-|', $cmd or do {
		die "$cmd: cannot execute, stopped";
	};
	while( <$h> ){
		chomp;
		if   ( m"^(\w[^:]+):\s+(\S+)" ){ $t{$1} = $2; }
		elsif( m"^\s*\d+\s*(\w+)(?:\s+\S+){7}\s+(\d+)" ){ $t{$1} = $2; }
	}
	close $h;

	while( my ($k, $v) = each %t ){
		$k =~ tr/ /_/;
		$v =~ tr/,//d;
		if   ( $k eq "Temperature" )        { $r{"device[$device]-metric[$k]"}     = n $v; }
		elsif( $k eq "Available_Spare" )    { $r{"device[$device]-metric[$k]"} = nP $v; }
		elsif( $k eq "Total_NVM_Capacity" ) { $r{"device[$device]-metric[$k]"} = nMB $v / 1024 / 1024; }
		elsif( $k eq "Unsafe_Shutdowns" )   { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Power_On_Hours" )     { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Power_Cycles" )       { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Data_Units_Read" )    { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Data_Units_Write" )   { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Host_Read_Commands" ) { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Host_Write_Commands" ){ $d{"device[$device]-metric[$k]"} = $v; }

		elsif( $k eq "Airflow_Temperature_Cel" ){ $r{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Temperature_Celsius" )    { $r{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Start_Stop_Count" )       { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Power_On_Hours" )         { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Raw_Read_Error_Rate" )    { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Hardware_ECC_Recovered" ) { $d{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Total_LBAs_Written" )     { $r{"device[$device]-metric[$k]"} = $v; }
		elsif( $k eq "Total_LBAs_Read" )        { $r{"device[$device]-metric[$k]"} = $v; }
	}
}

while( my ($i, undef) = each %must_exist ){
	next if $existing{$i};
	$d{"device[$i]-failure-for-existing"} = 1;
}
while( my ($i, undef) = each %must_not_exist ){
	next if $existing{$i};
	$d{"device[$i]-failure-for-non-existent"} = 0;
}

# calculate differences
my ($shortd, $longd, $shortdiff, $longdiff) = calc_delta "$WORKDIR/smart.history", $LONGTERM_H, %d;
foreach my $k ( keys %$shortd ){
	my $shortv = $$shortd{$k};
	my $longv  = $$longd {$k};
	my $shortdiffv = $$shortdiff{$k};
	my $longdiffv  = $$longdiff {$k};

	if    ( $k =~m"(Power|Start|Shutdown)" ){
		$r{"recently-$k"} = n $longdiffv;
	}elsif( $k =~m"(Read|Write)" ){
		$r{"$k-mbps"}          = nMB $shortv / 1024 / 1024 * 8;
		$r{"longterm-$k-mbps"} = nMB $longv / 1024 / 1024 * 8;
	}else{
	}
}

# output
foreach my $perfname ( sort keys %r ){
	my $value = $r{$perfname};
	print "$perfname=$value\n";
}

exit 0;


