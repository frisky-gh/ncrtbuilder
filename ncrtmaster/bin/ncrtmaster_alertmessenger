#!/usr/bin/perl

use strict;
use String::Random 'random_regex';
use Encode;
use Template;
use JSON;
use URI::Escape;
use URI::Query;
use HTTP::Daemon;
use HTTP::Status;
use LWP::UserAgent;
use MIME::EncWords ':all';

$0 =~ m"^(.*)/";
our $TOOLHOME = "$1/..";
while( $TOOLHOME =~ s{(^|/)[^\.][^/]*/\.\.(/|$)}{$1} ){}
our $PLUGINSDIR = "$TOOLHOME/plugins";
our $CONFDIR = "$TOOLHOME/conf";
our $SENDMAILEXE = '/usr/lib/sendmail';


####
sub mkdir_or_die ($) {
	my ($d) = @_;
	return if -d $d;
	mkdir $d or die "$d: cannot create, stopped";
}

####
if( @ARGV < 1 ){
	print "usage: % $0 {cron|...}\n";
	exit 3;
}

# setup work directory
our $WORKDIR;
if( $ENV{'HOME'} ){ $WORKDIR = $ENV{'HOME'} . "/.ncrt"; }
else{
	my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $home, $shell, $expire ) = getpwuid $<;
	$WORKDIR = "$home/.ncrt";
}
unless( -d $WORKDIR ){ mkdir_or_die $WORKDIR; }

####
my %conf;
my $f = "$CONFDIR/servicegroup.conf";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	next if m"^\s*(#|$)";
	die unless m"^(\w+)=(.*)$";
	$conf{$1} = $2;
}
close $h;

# for debug
our $DEBUG = $conf{DEBUG} // 0;

# mail address of admin.
our $MAILFROM = $conf{MAILFROM} // "admin\@example.com";

# session directory
our $SESSIONDIR = $conf{SESSIONDIR} // "/var/www/ncrtmaster";

# session url base
our $SESSIONURLBASE = $conf{SESSIONURLBASE} // "http://example.com/ncrtmaster";

# grafana url
our $GRAFANAURL = $conf{GRAFANAURL} // "http://grafana.example.com";

# grafana API key
our $GRAFANAAPIKEY = $conf{GRAFANAAPIKEY} // "";

# grafana organization ID
our $GRAFANAORGID = $conf{GRAFANAORGID} // 1;

# naemon2influx-grafana-helper url
our $HELPERURL = $conf{HELPERURL} // "http://example.com/naemon2influx-grafana-helper";

# timestamps
sub timestamp ($) {
	my ($sec, $min, $hour, $day, $mon, $year) = localtime shift;
	return sprintf "%04d-%02d-%02d_%02d:%02d:%02d", $year+1900, $mon+1, $day, $hour, $min, $sec;
}
our $NOW = timestamp time;
our $NG_EXPIRYDATE	  = timestamp time-($conf{NG_LIFETIME}       // 6*60)*60;
our $NGHISTORY_EXPIRYDATE = timestamp time-($conf{NGHISTORY_LIFETIME}//48*60)*60;
our $SESSION_EXPIRYDATE   = timestamp time-($conf{SESSION_LIFETIME}  //24*60)*60;
our $RECIPIENT_EXPIRYDATE = timestamp time-($conf{RECIPIENT_LIFETIME}// 6*60)*60;
our $GRAPH_EXPIRYDATE     = timestamp time-($conf{GRAPH_LIFETIME}    //   10)*60;

our $MINOR_DETECTION_LIMIT = timestamp time -  8 * 60 * 60;
our $MAJOR_DETECTION_LIMIT = timestamp time -       5 * 60;
our $CRIT_DETECTION_LIMIT  = timestamp time -       1 * 60;
our $MINOR_LASTSEND_LIMIT  = timestamp time -  8 * 60 * 60;
our $MAJOR_LASTSEND_LIMIT  = timestamp time -      20 * 60;
our $CRIT_LASTSEND_LIMIT   = timestamp time -       5 * 60;
our $RESEND_LIMIT          = timestamp time - 12 * 60 * 60;
our $HEALTH_THRESHOLD = 10;

####
sub safesprintf ( @ ){
	my ($format, @args) = @_;
	my $text = sprintf $format, @args;
	$text =~ s{([\x00-\x1f\x7f])}{"\\x" . unpack('H2', $1);}eg;
	return $text;
}

our $LOG_HANDLE;
sub openlog () {
	open $LOG_HANDLE, '>>', "$WORKDIR/sg_log" or return;
	my $old = select $LOG_HANDLE;
	$| = 1;
	select $old;
}

sub debuglog ( $;@ ){
	return unless $DEBUG;
	openlog unless defined $LOG_HANDLE;
	print $LOG_HANDLE timestamp(time), " ", safesprintf(@_), "\n";
}

sub errorlog ( $;@ ){
	openlog unless defined $LOG_HANDLE;
	print $LOG_HANDLE timestamp(time), " ", safesprintf(@_), "\n";
}

sub var2ltsv ( \% ){
	my ($var) = @_;
	my @ltsv;
	push @ltsv, "timestamp:".$var->{timestamp} if defined $var->{timestamp};
	foreach my $k ( sort {$a cmp $b} keys %$var ){
		next if $k eq 'timestamp';
		push @ltsv, "$k:".$var->{$k};
	}
	return join "\t", @ltsv;
}

sub ltsv2var ( $ ){
	my ($ltsv) = @_;
	my %var;
	foreach my $kv ( split m"\t", $ltsv ){
		$kv =~ m"^([-.\w]+):(.*)$" or do {
			next;
		};
		my $k = $1;
		my $v = $2;
		$var{$k} = $v;
	}
	return %var;
}

sub sendmail ($$$) {
	my ($mail, $mailfrom, $mailto) = @_;
	my $from_quoted = quotemeta $mailfrom;
	my $to_quoted = quotemeta $mailto;

	open my $h, '|-', "$SENDMAILEXE -f $from_quoted $to_quoted" or do {
		die "$SENDMAILEXE: cannot execute, stopped";
	};
	chomp $mail;
	my @mail = split m"\n", $mail;
	while( 1 ){
		$_ = shift @mail;
		last if $_ eq '';

		my $text = encode_mimewords $_;
		print $h encode_utf8($text), "\n";
	}
	print $h "MIME-Version: 1.0\n";
	print $h "Content-Transfer-Encoding: 8bit\n";
	print $h "Content-Type: text/plain; charset=utf-8\n",
		"\n";
	while( 1 ){
		$_ = shift @mail;
		last unless defined $_;
		my $text = decode_utf8( $_ );
		print $h encode_utf8($text), "\n";
	}
	close $h;
}

sub path_encode ($) {
	my ($text) = @_;
	$text =~ s{([\x00-\x1f/\x7f])}{"\%" . unpack('H2', $1);}eg;
	return $text;
}

sub path_decode ($) {
	my ($text) = @_;
	$text =~ s{%([0-9a-fA-F]{2})}{pack('H2', $1);}eg;
	return $text;
}

#### naemon2influx-grafana-helper functions
sub query_panels_to_naemon2influx_grafana_helper ($$) {
	my ($host, $service ) = @_;
	my $ua = LWP::UserAgent->new;
	my $server_endpoint = sprintf '%s/dashboard_info.js?hostname=%s&servicedesc=%s',
		$HELPERURL, $host, $service;
	my $req = HTTP::Request->new('GET' => $server_endpoint);
	debuglog "naemon2influx-grafana-helper: url=%s, requesting...", $server_endpoint;
	my $res = $ua->request($req);
	return undef unless $res->code eq '200';
	my $obj;
	eval { $obj = decode_json $res->content; };
	return undef if $@;
	return $obj->{panels};
}

#### grafana functions
sub download_panel_png_from_grafana ($) {
	my ($url) = @_;
	my $ua = LWP::UserAgent->new;
	my $req = HTTP::Request->new('GET' => $url);
	$req->authorization_basic('api_key', $GRAFANAAPIKEY);
	debuglog "grafana: url=%s, requesting...", $url;
	my $res = $ua->request($req);
	return $res->content;
}

#### template functions
sub tmplfunc_match {
	my ($text, $re) = @_;
	my @r = $text =~ m"$re";
	if   ( @r == 0 ){ return undef; }
	elsif( @+ == 1 ){ return [$&]; }
	else            { return [$&, @r]; }
}

sub tmplfunc_sub {
	my ($text, $re, $replace) = @_;
	$text =~ s/$re/$replace/;
	return $text;
}

sub tmplfunc_gsub {
	my ($text, $re, $replace) = @_;
	$text =~ s/$re/$replace/g;
	return $text;
}

sub tmplfunc_split {
	my ($text, $re) = @_;
	return split m"$re", $text;
}

sub tmplfunc_safesprintf {
	my ($format, @args) = @_;
	return safesprintf $format, @args;
}

sub tmplfunc_urlencode {
	my ($text) = @_;
	return uri_escape $text;
}

sub generate_by_template ($%) {
	my ($template, %vars) = @_;
	my $tt = Template->new({}) or do {
		debuglog "cannot generate Template instance: %s", $Template::ERROR;
		return $template;
	};
	$vars{match}  //= \&tmplfunc_match;
	$vars{sub}    //= \&tmplfunc_sub;
	$vars{gsub}   //= \&tmplfunc_gsub;
	$vars{split}  //= \&tmplfunc_split;
	$vars{safesprintf} //= \&tmplfunc_safesprintf;
	$vars{urlencode} //= \&tmplfunc_urlencode;

	my $output;
	$tt->process( \$template, \%vars, \$output ) or do {
		debuglog "cannot process template: %s.", $tt->error();
		return $template;
	};
	return $output;
}

#### read / write functions
sub read_internal_multiline ($$@) {
	my ($f, $action, @fields) = @_;
	open my $h, '<', $f or do {
		die "$f: cannot open,stopped";
	};
	my %obj;
	while( <$h> ){
		chomp;
		my %v = ltsv2var $_;
		foreach my $i ( @fields ){
			die "$f:$.: illegal format, not exist $i, stopped" unless defined $v{$i};
		}
		my $key = &$action( \%v );
		$obj{$key} = \%v if defined $key;
	}
	close $h;
	return \%obj;
}

sub read_internal_singleline ($@) {
	my ($f, @fields) = @_;
	open my $h, '<', $f or do {
		die "$f: cannot open,stopped";
	};
	my $s = <$h>;
	chomp $s;
	my %v = ltsv2var $s;
	foreach my $i ( @fields ){
		die "$f:$.: illegal format, stopped" unless defined $v{$i};
	}
	close $h;
	return \%v;
}

sub read_internal_timestamp ($) {
	my ($f, $action, @fields) = @_;
	open my $h, '<', $f or do {
		die "$f: cannot open,stopped";
	};
	my $s = <$h>;
	chomp $s;
	my %v = ltsv2var $s;
	die "$f:$.: illegal format, stopped" unless defined $v{timestamp};
	close $h;
	return $v{timestamp};
}

sub write_internal_multiline ($$) {
	my ($f, $obj) = @_;
	if( !defined $obj || %$obj == 0 ){
		unlink $f if -f $f;
		return;
	}
	open my $h, '>', $f or do {
		die "$f: cannot open,stopped";
	};
	foreach my $k ( sort {$a cmp $b} keys %$obj ){
		print $h var2ltsv %{$obj->{$k}}, "\n";
	}
	close $h;
}

sub write_internal_singleline ($$) {
	my ($f, $obj) = @_;
	if( !defined $obj || %$obj == 0 ){
		unlink $f if -f $f;
		return;
	}
	open my $h, '>', $f or do {
		die "$f: cannot open,stopped";
	};
	print $h var2ltsv %{$obj}, "\n";
	close $h;
}

sub write_internal_timestamp ($$) {
	my ($f, $timestamp) = @_;
	if( !defined $timestamp ){
		unlink $f if -f $f;
		return;
	}
	open my $h, '>', $f or do {
		die "$f: cannot open,stopped";
	};
	my %var = ('timestamp' => $timestamp);
	print $h var2ltsv %var, "\n";
	close $h;
}

sub read_servicegroup_ngs ($) {
	my ($sg) = @_;
	my $ngs = read_internal_multiline
		"$WORKDIR/sg_ngs.$sg",
		sub {
			my $v = shift;
			return $v->{host}.",".$v->{service};
		},
		'timestamp',
		'host',
		'service',
		'state',
		'output';
	return $ngs;
}

sub write_servicegroup_ngs ($$) {
	my ($sg, $ngs) = @_;
	write_internal_multiline "$WORKDIR/sg_ngs.$sg", $ngs;
}

sub read_servicegroup_recipients ($) {
	my ($sg) = @_;
	my $recipients = read_internal_multiline
		"$WORKDIR/sg_recipients.$sg",
		sub {
			my $v = shift;
			return undef if $v->{timestamp} lt $RECIPIENT_EXPIRYDATE;
			return $v->{recipient};
		},
		'timestamp',
		'recipient';
	return $recipients;
}

sub write_servicegroup_recipients ($$) {
	my ($sg, $recipients) = @_;
	write_internal_multiline "$WORKDIR/sg_recipients.$sg", $recipients;
}

sub read_servicegroup_session ($) {
	my ($sg) = @_;
	my $session = read_internal_singleline
		"$WORKDIR/sg_session.$sg",
		'timestamp',
		'id';
	$session->{expired} = $session->{timestamp} lt $SESSION_EXPIRYDATE;
	return $session;
}

sub write_servicegroup_session ($$) {
	my ($sg, $session) = @_;
	delete $session->{expired} if defined $session;
	write_internal_singleline "$WORKDIR/sg_session.$sg", $session;
}

sub read_servicegroup_nghistory ($) {
	my ($sg) = @_;
	my $nghistory = read_internal_multiline
		"$WORKDIR/sg_nghistory.$sg",
		sub {
			my $v = shift;
			return undef if $v->{timestamp} lt $NGHISTORY_EXPIRYDATE;
			return join ',', $v->{timestamp}, $v->{host}, $v->{service};
		},
		'timestamp',
		'host',
		'service',
		'state',
		'laststate';
	return $nghistory;
}

sub write_servicegroup_nghistory ($$) {
	my ($sg, $nghistory) = @_;
	write_internal_multiline "$WORKDIR/sg_nghistory.$sg", $nghistory;
}

sub read_servicegroup_graphs ($) {
	my ($sg) = @_;
	my $f = "$WORKDIR/sg_graphs.$sg";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	my $ltsv = <$h>;
	close $h;

	chomp $ltsv;
	my %v = ltsv2var $ltsv;
	my $timestamp = $v{timestamp};
	my $expired = $timestamp lt $GRAPH_EXPIRYDATE;
	my $graphs = {
		'timestamp' => $timestamp,
		'expired'   => $expired,
		'id'	=> $v{id},
	};
	return $graphs;
}

sub read_recipient_ngs ($$) {
	my ($sg, $recipient) = @_;
	my $ngs = read_internal_multiline
		"$WORKDIR/sg_recipient_ngs.$sg.$recipient",
		sub {
			my $v = shift;
			return join ',', $v->{host}, $v->{service};
		},
		'timestamp',
		'host',
		'service',
		'state',
		'output';
	return $ngs;
}

sub write_recipient_ngs ($$$) {
	my ($sg, $recipient, $ngs) = @_;
	write_internal_multiline "$WORKDIR/sg_recipient_ngs.$sg.$recipient", $ngs;
}

sub read_servicegroup_lastchange ($) {
	my ($sg) = @_;
	return read_internal_timestamp "$WORKDIR/sg_lastchange.$sg";
}

sub write_servicegroup_lastchange ($$) {
	my ($sg, $lastchange) = @_;
	write_internal_timestamp "$WORKDIR/sg_lastchange.$sg", $lastchange;
}

sub read_recipient_lastchange ($$) {
	my ($sg, $recipient) = @_;
	return read_internal_timestamp "$WORKDIR/sg_recipient_lastchange.$sg.$recipient";
}

sub write_recipient_lastchange ($$$) {
	my ($sg, $recipient, $lastchange) = @_;
	write_internal_timestamp "$WORKDIR/sg_recipient_lastchange.$sg.$recipient", $lastchange;
}

sub read_recipient_lastsend ($$) {
	my ($sg, $recipient) = @_;
	return read_internal_timestamp "$WORKDIR/sg_recipient_lastsend.$sg.$recipient";
}

sub write_recipient_lastsend ($$$) {
	my ($sg, $recipient, $lastchange) = @_;
	write_internal_timestamp "$WORKDIR/sg_recipient_lastsend.$sg.$recipient", $lastchange;
}

sub read_recipient_minor_detection_timestamp ($$) {
	my ($sg, $recipient) = @_;
	my $f = "$WORKDIR/sg_recipient_minor_detection.$sg.$recipient";
	return read_internal_timestamp $f;
}

sub write_recipient_minor_detection_timestamp ($$$) {
	my ($sg, $recipient, $timestamp) = @_;
	write_internal_timestamp "$WORKDIR/sg_recipient_minor_detection.$sg.$recipient", $timestamp;
}

sub read_recipient_major_detection_timestamp ($$) {
	my ($sg, $recipient) = @_;
	my $f = "$WORKDIR/sg_recipient_major_detection.$sg.$recipient";
	return read_internal_timestamp $f;
}

sub write_recipient_major_detection_timestamp ($$$) {
	my ($sg, $recipient, $timestamp) = @_;
	write_internal_timestamp "$WORKDIR/sg_recipient_major_detection.$sg.$recipient", $timestamp;
}

sub read_recipient_crit_detection_timestamp ($$) {
	my ($sg, $recipient) = @_;
	my $f = "$WORKDIR/sg_recipient_crit_detection.$sg.$recipient";
	return read_internal_timestamp $f;
}

sub write_recipient_crit_detection_timestamp ($$$) {
	my ($sg, $recipient, $timestamp) = @_;
	write_internal_timestamp "$WORKDIR/sg_recipient_crit_detection.$sg.$recipient", $timestamp;
}

sub write_plain ($$) {
	my ($f, $html) = @_;
	if( !defined $f ){
		unlink $f if -f $f;
		return;
	}
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	print $h $html;
	close $h;
}

sub read_plain ($) {
	my ($f, $html) = @_;
	unless( -f $f ){
		return undef;
	}
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	my $r = join '', <$h>;
	close $h;
	return $r;
}

#### service groups functions
sub load_servicegroups () {
	my %sgs;
	opendir my $d, $WORKDIR or do {
		return undef;
	};
	while( my $e = readdir $d ){
		if    ( $e =~ m"^sg_changes\.(\w+)$" ){
			my $sg = $1;
			$sgs{$sg}->{has_changes} = 1;
		}elsif( $e =~ m"^sg_lastchange\.(\w+)$" ){
			my $sg = $1;
			my $lastchange = read_servicegroup_lastchange $sg;
			$sgs{$sg}->{lastchange} = $lastchange;
		}elsif( $e =~ m"^sg_ngs\.(\w+)$" ){
			my $sg = $1;
			my $ngs = read_servicegroup_ngs $sg;
			$sgs{$sg}->{ngs} = $ngs;
		}elsif( $e =~ m"^sg_nghistory\.(\w+)$" ){
			my $sg = $1;
			my $nghistory = read_servicegroup_nghistory $sg;
			$sgs{$sg}->{nghistory} = $nghistory;
		}elsif( $e =~ m"^sg_recipients\.(\w+)$" ){
			my $sg = $1;
			my $recipients = read_servicegroup_recipients $sg;
			$sgs{$sg}->{recipients} = $recipients;
		}elsif( $e =~ m"^sg_session\.(\w+)$" ){
			my $sg = $1;
			my $session = read_servicegroup_session $sg;
			$sgs{$sg}->{session} = $session;
		}elsif( $e =~ m"^sg_graphs\.(\w+)$" ){
			my $sg = $1;
			my $graphs = read_servicegroup_graphs $sg;
			$sgs{$sg}->{graphs} = $graphs;
		}
	}
	closedir $d;
	return \%sgs;
}

sub list_servicegroups ($) {
	my ($sgs) = @_;
	return keys %$sgs;
}

sub servicegroup_has_ngs ($$) {
	my ($sgs, $sg) = @_;
	return defined $sgs->{$sg}->{ngs};
}

sub servicegroup_has_changes ($$) {
	my ($sgs, $sg) = @_;
	return 1 if $sgs->{$sg}->{has_changes};

	# if servicegroup has expired NGs
	my $ngs = $sgs->{$sg}->{ngs};
	while( my ($k, $v) = each %$ngs ){
		return 1 if $v->{timestamp} lt $NG_EXPIRYDATE;
	}
	return undef;
}

sub servicegroup_has_session ($$) {
	my ($sgs, $sg) = @_;
	return defined $sgs->{$sg}->{session};
}

sub servicegroup_has_expired_session ($$) {
	my ($sgs, $sg) = @_;
	return undef unless defined $sgs->{$sg}->{session};
	return $sgs->{$sg}->{session}->{expired};
}

sub get_servicegroup_status ($$) {
	my ($sgs, $sg) = @_;
	return undef unless defined $sgs->{$sg};
	my %status = (
		'servicegroup' => $sg,
		'sid'          => $sgs->{$sg}->{session}->{id},
		'ngs'	       => $sgs->{$sg}->{ngs},
		'nghistory'    => $sgs->{$sg}->{nghistory},
		'lastchange'   => $sgs->{$sg}->{lastchange},
	);
	return \%status;
}

sub get_servicegroup_session_id ($$) {
	my ($sgs, $sg) = @_;
	return $sgs->{$sg}->{session}->{id};
}

sub set_servicegroup_session_id ($$$) {
	my ($sgs, $sg, $sid) = @_;
	my %session = (
		'id' => $sid,
		'timestamp' => $NOW,
	);
	$sgs->{$sg}->{session} = \%session;
	write_servicegroup_session $sg, \%session;
}

sub list_servicegroup_recipients ($$) {
	my ($sgs, $sg) = @_;
	return () unless defined $sgs->{$sg}->{recipients};
	return keys %{$sgs->{$sg}->{recipients}};
}

sub update_servicegroup ($$) {
	my ($sgs, $sg) = @_;
	my $recipients = $sgs->{$sg}->{recipients};
	my $ngs	= $sgs->{$sg}->{ngs};
	my $nghistory  = $sgs->{$sg}->{nghistory};
	my $lastchange = $sgs->{$sg}->{lastchange};
	my $f = "$WORKDIR/sg_changes.$sg";
	my $g = "$WORKDIR/sg_changes.$sg.tmp";
	rename $f, $g or do {
		die "$f: cannot rename, stopped";
	};
	open my $h, '<', $g or do {
		die "$g: cannot open, stopped";
	};

	my $ngnum = keys %$ngs;
	while( <$h> ){
		chomp;
		my %v = ltsv2var $_;
		my $timestamp = $v{timestamp};
		my $recipient = $v{recipient};
		my $host    = $v{HOSTNAME};
		my $service = $v{SERVICEDESC};
		my $output  = $v{SERVICEOUTPUT};
		my $state   = $v{SERVICESTATE};
		unless( defined $timestamp and defined $recipient and
			defined $host and defined $service and 
			defined $output and $state ){
			print "$f:$.: not exist timestamp.\n" unless defined $timestamp;
			print "$f:$.: not exist recipient.\n" unless defined $recipient;
			print "$f:$.: not exist HOSTNAME.\n" unless defined $host;
			print "$f:$.: not exist SERVICEDESC.\n" unless defined $service;
			print "$f:$.: not exist SERVICEOUTPUT.\n" unless defined $output;
			print "$f:$.: not exist SERVICESTATE.\n" unless defined $state;
			next;
		}

		# current state = OK, last state = OK
		if    ( $state eq 'OK' && ! defined $ngs->{"$host,$service"} ){
			debuglog "update_servicegroup: %s,%s: %s(OK)->%s(OK)",
				$host, $service, $ngs->{"$host,$service"}, $state;
			# nothing to do
		# current state = OK, last state = NG
		}elsif( $state eq 'OK' && defined $ngs->{"$host,$service"} ){
			debuglog "update_servicegroup: %s,%s: %s(NG)->%s(OK)",
				$host, $service, $ngs->{"$host,$service"}->{state}, $state;
			debuglog "update_servicegroup: add nghistory: %s,%s,%s",
				$timestamp, $host, $service;
			$nghistory->{"$timestamp,$host,$service"} = {
				'timestamp' => $timestamp,
				'host' => $host,
				'service' => $service,
				'state' => $state,
				'laststate' => $ngs->{"$host,$service"}->{state},
			};
			delete $ngs->{"$host,$service"};
			$lastchange = $timestamp;

			if( $ngnum-- == $HEALTH_THRESHOLD ){
				delete $ngs->{"-,HEALTH"};
				$nghistory->{"$timestamp,-,HEALTH"} = {
					'timestamp' => $timestamp,
					'host' => '-',
					'service' => 'HEALTH',
					'state' => 'OK',
					'laststate' => 'NG',
				};
			}
		# current state = NG, last state = OK
		}elsif( ! defined $ngs->{"$host,$service"} ){
			debuglog "update_servicegroup: %s,%s: %s(OK)->%s(NG)",
				$host, $service, $ngs->{"$host,$service"}, $state;
			debuglog "update_servicegroup: add nghistory: %s,%s,%s",
				$timestamp, $host, $service;
			$nghistory->{"$timestamp,$host,$service"} = {
				'timestamp' => $timestamp,
				'host' => $host,
				'service' => $service,
				'state' => $state,
				'laststate' => 'OK',
			};
			$ngs->{"$host,$service"} = {
				'timestamp' => $timestamp,
				'host'      => $host,
				'service'   => $service,
				'state'     => $state,
				'output'    => $output,
			};
			$lastchange = $timestamp;

			if( ++$ngnum == $HEALTH_THRESHOLD ){
				$ngs->{"-,HEALTH"} = {
					'timestamp' => $timestamp,
					'host'      => '-',
					'service'   => 'HEALTH',
					'state'     => 'NG',
					'output'    => '',
				};
				$nghistory->{"$timestamp,-,HEALTH"} = {
					'timestamp' => $timestamp,
					'host' => '-',
					'service' => 'HEALTH',
					'state' => 'NG',
					'laststate' => 'OK',
				};
			}
		# current state = NG, last state != current state
		}elsif( $state ne $ngs->{"$host,$service"}->{state} ){
			debuglog "update_servicegroup: %s,%s: %s(NG)->%s(NG)",
				$host, $service, $ngs->{"$host,$service"}->{state}, $state;
			debuglog "update_servicegroup: add nghistory: %s,%s,%s",
				$timestamp, $host, $service;
			$nghistory->{"$timestamp,$host,$service"} = {
				'timestamp' => $timestamp,
				'host' => $host,
				'service' => $service,
				'state' => $state,
				'laststate' => $ngs->{"$host,$service"}->{state},
			};
			$ngs->{"$host,$service"} = {
				'timestamp' => $timestamp,
				'host'      => $host,
				'service'   => $service,
				'state'     => $state,
				'output'    => $output,
			};
			$lastchange = $timestamp;
		# current state = NG, last state = current state
		}else{
			debuglog "update_servicegroup: %s,%s: %s(NG)=>%s(NG)",
				$host, $service, $ngs->{"$host,$service"}->{state}, $state;
			$ngs->{"$host,$service"} = {
				'timestamp' => $timestamp,
				'host'      => $host,
				'service'   => $service,
				'state'     => $state,
				'output'    => $output,
			};
		}

		$recipients->{$recipient} = {
			'recipient' => $recipient,
			'timestamp' => $timestamp,
		};
	}
	close $h;

	# cleanup if servicegroup has expired NGs
	foreach my $k ( keys %$ngs ){
		my $v = $ngs->{$k};
		next if $v->{timestamp} gt $NG_EXPIRYDATE;

		my $timestamp = $v->{timestamp};
		my $host      = $v->{host};
		my $service   = $v->{service};
		my $laststate = $v->{state};
		delete $ngs->{$k};
		$nghistory->{"$NOW,$host,$service"} = {
			'timestamp' => $NOW,
			'host'      => $host,
			'service'   => $service,
			'state'     => 'OK',
			'laststate' => $laststate,
		};
		$lastchange = $NOW;

		if( $ngnum-- == $HEALTH_THRESHOLD ){
			delete $ngs->{"-,HEALTH"};
			$nghistory->{"$NOW,-,HEALTH"} = {
				'timestamp' => $NOW,
				'host'      => '-',
				'service'   => 'HEALTH',
				'state'     => 'OK',
				'laststate' => 'NG',
			};
		}
	}

	$sgs->{$sg}->{recipients} = $recipients;
	$sgs->{$sg}->{ngs}        = $ngs;
	$sgs->{$sg}->{lastchange} = $lastchange;
	$sgs->{$sg}->{nghistory}  = $nghistory;
	write_servicegroup_ngs	$sg, $ngs;
	write_servicegroup_nghistory  $sg, $nghistory;
	write_servicegroup_recipients $sg, $recipients;
	write_servicegroup_lastchange $sg, $lastchange;
	unlink $g or do {
		die "$g: cannot remove, stopped";
	};
	delete $sgs->{$sg}->{has_changes};
}

#### report functions

sub load_last_report_status ($$) {
	my ($sg, $recipient) = @_;

	my $ngs;
	my $lastchange;
	my $lastsend;

	if( -f "$WORKDIR/sg_recipient_ngs.$sg.$recipient" ){
		$ngs = read_recipient_ngs $sg, $recipient
	}
	if( -f "$WORKDIR/sg_recipient_lastchange.$sg.$recipient" ){
		$lastchange = read_recipient_lastchange $sg, $recipient
	}
	if( -f "$WORKDIR/sg_recipient_lastsend.$sg.$recipient" ){
		$lastsend = read_recipient_lastsend $sg, $recipient
	}

	my %status = (
		'ngs'	=> $ngs,
		'lastchange' => $lastchange,
		'lastsend'   => $lastsend,
	);
	return \%status;
}

sub load_next_report ($$) {
	my ($sg, $recipient) = @_;

	my %report = (
		'servicegroup' => $sg,
		'recipient'    => $recipient,
	);
	if( -f "$WORKDIR/sg_recipient_minor_detection.$sg.$recipient" ){
		$report{minor_detection_timestamp} = read_recipient_minor_detection_timestamp $sg, $recipient;
	}
	if( -f "$WORKDIR/sg_recipient_major_detection.$sg.$recipient" ){
		$report{major_detection_timestamp} = read_recipient_major_detection_timestamp $sg, $recipient;
	}
	if( -f "$WORKDIR/sg_recipient_crit_detection.$sg.$recipient" ){
		$report{crit_detection_timestamp} = read_recipient_crit_detection_timestamp $sg, $recipient;
	}
	return \%report;
}

sub update_next_report ($$) {
	my ($report, $changes) = @_;

	my $sg	= $report->{servicegroup};
	my $recipient = $report->{recipient};

	if    ( $changes->{minor} and not $report->{minor_detection_timestamp} ){
		$report->{minor_detection_timestamp} = $NOW;
		write_recipient_minor_detection_timestamp $sg, $recipient, $NOW;
	}elsif( not $changes->{minor} and $report->{minor_detection_timestamp} ){
		delete $report->{minor_detection_timestamp};
		write_recipient_minor_detection_timestamp $sg, $recipient, undef;
	}
	if    ( $changes->{major} and not $report->{major_detection_timestamp} ){
		$report->{major_detection_timestamp} = $NOW;
		write_recipient_major_detection_timestamp $sg, $recipient, $NOW;
	}elsif( not $changes->{major} and $report->{major_detection_timestamp} ){
		delete $report->{major_detection_timestamp};
		write_recipient_major_detection_timestamp $sg, $recipient, undef;
	}
	if    ( $changes->{crit} and not $report->{crit_detection_timestamp} ){
		$report->{crit_detection_timestamp} = $NOW;
		write_recipient_crit_detection_timestamp $sg, $recipient, $NOW;
	}elsif( not $changes->{crit} and $report->{crit_detection_timestamp} ){
		delete $report->{crit_detection_timestamp};
		write_recipient_crit_detection_timestamp $sg, $recipient, undef;
	}
}

sub parse_output ($) {
	my ($output) = @_;
	my @performances;
	my @messages;
	foreach my $field ( split m" / ", $output ){
		if( $field =~ m"^(UNKNOWN|WARNING|WARN|CRITICAL|CRIT)$" ){
			push @messages, $field;
		}elsif( $field =~ m"^
			(?<name> .*):
			(?<value> [-+]?(?:\d+\.\d+|\d|\.\d+))
			\(
				(?<side> upper|lower)-(?<priority> crit|warn)-thr:
				(?<threshold> [-+]?(?:\d+\.\d+|\d|\.\d+))
				
			\)
		$"x ){
			push @performances, {
				name      => $+{name},
				value     => $+{value},
				priority  => $+{priority},
				side      => $+{side},
				threshold => $+{threshold},
			};
		}else{
			push @messages, $field;
		}
	}
	return \@messages, \@performances;
}

sub download_session_graphs ($$$) {
	my ($ss, $sid, $status) = @_;
	my $ngs = $status->{ngs};
	my $d = "$SESSIONDIR/sess_$sid";

	debuglog "download graphs into session '%s'.", $sid;

	my $t = time;
	foreach my $k ( sort {$a cmp $b} keys %$ngs ){
		my $ng = $ngs->{$k};
		my $host    = $ng->{host};
		my $service = $ng->{service};
		my $host_encoded    = path_encode $host;
		my $service_encoded = path_encode $service;
		my $panels = query_panels_to_naemon2influx_grafana_helper $host, $service;
		next unless defined $panels;

		my $output = $ng->{output};
		my (undef, $perfs_in_ng) = parse_output $output;

		debuglog "  host:%s, service:%s", $host, $service;
		foreach my $panel ( @$panels ){
			my $id  = $panel->{id} or next;
			my $url = $panel->{url} or next;
			debuglog "    panel_id:%d", $id;

			my $perfnames_in_panel = $panel->{performancenames};
			if( @$perfs_in_ng and $perfnames_in_panel ){
				debuglog "    cheking performance names %s ...",
					"@{$perfnames_in_panel}";
				my $this_panel_is_related_to_ng;
				OUTSIDE:
				foreach my $perf_in_ng ( @$perfs_in_ng ){
					my $perfname_in_ng = $perf_in_ng->{name};
					debuglog "    performance name in NG: %s.",
						$perfname_in_ng;
					foreach my $perfname_in_panel ( @$perfnames_in_panel ){
						next unless $perfname_in_ng eq $perfname_in_panel;
						$this_panel_is_related_to_ng = 1;
						last OUTSIDE;
					}
				}
				next unless $this_panel_is_related_to_ng;
			}

			my $png = download_panel_png_from_grafana $url;
			my $f = "$host_encoded,$service_encoded,$id.png";
			write_plain "$d/$f", $png;
			my %graph = (
				'file'      => $f,
				'host'      => $host,
				'service'   => $service,
				'panel_id'  => $id,
				'timestamp' => $NOW,
			);
			$ss->{$sid}->{graphs}->{"$host,$service,$id"} = \%graph;
		}
	}

	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	my @expired;
	while( my $f = readdir $h ){
		next unless $f =~ m"^([^,]+),([^,]+),([^,]+)\.png$";
		my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,
		    $size,$atime,$mtime,$ctime,
		    $blksize,$blocks) = stat "$d/$f";
		next if $mtime > $t;
		push @expired, $f;
	}
	closedir $h;

	foreach my $f ( @expired ){ unlink "$d/$f"; }
}

sub cmp_status ($$) {
	my ($curr_status, $report_status) = @_;
	my $curr_ngs          = $curr_status->{ngs};
	my $curr_nghistory    = $curr_status->{nghistory};
	my $curr_lastchange   = $curr_status->{lastchange};
	my $report_ngs        = $report_status->{ngs};
	my $report_lastchange = $report_status->{lastchange};

	my $curr_ngnum    = keys %$curr_ngs;
	my $report_ngnum  = keys %$report_ngs;
	my $curr_health   = $curr_ngnum   < $HEALTH_THRESHOLD;
	my $report_health = $report_ngnum < $HEALTH_THRESHOLD;

	my %c;
	while( my ($k, $v) = each %$curr_ngs )  { $c{$k.",".$v->{state}} |= 1; }
	while( my ($k, $v) = each %$report_ngs ){ $c{$k.",".$v->{state}} |= 2; }

	my $minor_change = $curr_lastchange gt $report_lastchange;
	my @major_change;
	while( my ($k, $v) = each %c ){ push @major_change, "$k/$v" unless $v == 3; }
	my $major_change = @major_change;
	my $crit_change = $curr_health != $report_health;

	debuglog "minor change has been detected: %s gt %s",
		$curr_lastchange, $report_lastchange if $minor_change;
	debuglog "major change has been detected: %s",
		join(' ', @major_change) if $major_change;
	debuglog "crit change has been detected: %d -> %d",
		$report_health, $curr_health if $crit_change;

	unless( $curr_health ){
		$minor_change = undef;
		$major_change = undef;
	}
	return undef unless $minor_change or $major_change or $crit_change;

	my %changes = (
		'minor' => $minor_change,
		'major' => $major_change,
		'crit'  => $crit_change,
	);
	return \%changes;
}

sub report ($$$$) {
	my ($reason, $status, $next_report, $last_report_status) = @_;

	my $recipient  = $next_report->{recipient};
	my $sg	       = $status->{servicegroup};
	my $sid	       = $status->{sid};
	my $ngs	       = $status->{ngs};
	my $nghistory  = $status->{nghistory};
	my $status_lastchange = $status->{lastchange};
	my $report_lastchange = $last_report_status->{lastchange};

	# mail message
	my @ngs;
	foreach my $k ( sort keys %$ngs ){
		my $orig_ng = $ngs->{$k};
		my ($messages, $perfs) = parse_output $orig_ng->{output};
		push @ngs, {
			timestamp    => $orig_ng->{timestamp},
			host         => $orig_ng->{host},
			service      => $orig_ng->{service},
			state        => $orig_ng->{state},
			output       => $orig_ng->{output},
			performances => $perfs,
			messages     => $messages,
		};
	}
	my @nghistory;
	foreach my $k (
		sort {
			$nghistory->{$a}->{timestamp} cmp $nghistory->{$b}->{timestamp}
		} keys %$nghistory
	){
		next if $nghistory->{$k}->{timestamp} le $report_lastchange;
		push @nghistory, $nghistory->{$k};
	}
	my $template = read_plain "$CONFDIR/servicegroup_mail.tt";
	my $sessionurl = "$SESSIONURLBASE/sess_$sid/";
	my $mail = generate_by_template $template,
		'reason' => $reason,
		'ngs' => \@ngs, 'nghistory' => \@nghistory,
		'MAILFROM' => $MAILFROM, 'MAILTO' => $recipient,
		'SERVICEGROUP' => $sg, 'SESSIONURL' => $sessionurl;

	debuglog "sendmail: from=%s", $MAILFROM;
	debuglog "sendmail: to=%s", $recipient;
	debuglog "sendmail: message=%s", $mail;
	sendmail $mail, $MAILFROM, $next_report->{recipient};

	# clear next report status
	delete $next_report->{minor_detection_timestamp};
	write_recipient_minor_detection_timestamp $sg, $recipient, undef;
	delete $next_report->{major_detection_timestamp};
	write_recipient_major_detection_timestamp $sg, $recipient, undef;
	delete $next_report->{crit_detection_timestamp};
	write_recipient_crit_detection_timestamp $sg, $recipient, undef;

	# update last report status
	$last_report_status->{lastchange} = $status_lastchange;
	write_recipient_lastchange $sg, $recipient, $status_lastchange;
	$last_report_status->{lastsend} = $NOW;
	write_recipient_lastsend $sg, $recipient, $NOW;
	$last_report_status->{ngs} = $ngs;
	write_recipient_ngs $sg, $recipient, $ngs;
}

sub waiting_to_report {
	my ($next_report, $last_report_status) = @_;

	# detection waiting
	my $lastsend_limit;
	if( defined $next_report->{minor_detection_timestamp} and $next_report->{minor_detection_timestamp} lt $MINOR_DETECTION_LIMIT ){
		$lastsend_limit = $MINOR_LASTSEND_LIMIT;
	}
	if( defined $next_report->{major_detection_timestamp} and $next_report->{major_detection_timestamp} lt $MAJOR_DETECTION_LIMIT ){
		$lastsend_limit = $MAJOR_LASTSEND_LIMIT;
	}
	if( defined $next_report->{crit_detection_timestamp} and $next_report->{crit_detection_timestamp} lt $CRIT_DETECTION_LIMIT ){
		$lastsend_limit = $CRIT_LASTSEND_LIMIT;
	}
	return 1 unless defined $lastsend_limit;

	# report waiting
	my $lastsend = $last_report_status->{lastsend};
	debuglog "waiting_to_report: %s gt %s?", $lastsend, $lastsend_limit;
	return undef unless defined $lastsend;
	return $lastsend gt $lastsend_limit;
}

sub last_report_is_expired ($) {
	my ($status) = @_;
	my $lastsend = $status->{lastsend};

	return $lastsend lt $RESEND_LIMIT;
}

#### session functions

sub generate_session_page ($$$) {
	my ($ss, $sid, $status) = @_;
	my $ngs = $status->{ngs};
	my @ngs;
	foreach my $k ( sort keys %$ngs ){
		my $orig_ng = $ngs->{$k};
		my ($messages, $perfs) = parse_output $orig_ng->{output};
		push @ngs, {
			timestamp    => $orig_ng->{timestamp},
			host         => $orig_ng->{host},
			service      => $orig_ng->{service},
			state        => $orig_ng->{state},
			output       => $orig_ng->{output},
			performances => $perfs,
			messages     => $messages,
		};
	}
	my $graphs = $ss->{$sid}->{graphs};
	my @graphs;
	foreach my $k ( sort {$a cmp $b} keys %$graphs ){ push @graphs, $graphs->{$k}; }

	my $template = read_plain "$CONFDIR/servicegroup_status.tt";
	my $html = generate_by_template $template,
		'SERVICEGROUP' => $status->{servicegroup},
		'ngs'    => \@ngs,
		'graphs' => \@graphs;
	write_plain "$SESSIONDIR/sess_$sid/index.html", $html;
}


sub session_has_page ($$) {
	my ($ss, $sid) = @_;
	return $ss->{$sid}->{has_page};
}

sub session_has_graphs ($$) {
	my ($ss, $sid) = @_;
	return $ss->{$sid}->{graphs};
}

sub session_has_expired_graphs ($$) {
	my ($ss, $sid) = @_;
	return $ss->{$sid}->{has_expired_graphs};
}

sub session_is_expired ($$) {
	my ($ss, $sid) = @_;
	return 1 unless defined $ss->{$sid}->{timestamp};
	return $ss->{$sid}->{timestamp} lt $SESSION_EXPIRYDATE;
}

sub session_is_in_transition ($$) {
	my ($ss, $sid) = @_;
	return $ss->{$sid}->{mode} eq 'transition';
}

sub session_is_current ($$) {
	my ($ss, $sid) = @_;
	return $ss->{$sid}->{mode} eq 'current';
}

sub generate_session ($$) {
	my ($ss, $sg) = @_;
	my $new_sid = random_regex "[0-9a-zA-Z]{32}";
	my $d = "$SESSIONDIR/sess_$new_sid";
	mkdir_or_die $d;

	my %info = ( 'timestamp' => $NOW, 'mode' => 'current', 'servicegroup' => $sg );
	$ss->{$new_sid}->{servicegroup} = \%info;
	write_internal_singleline "$d/info.ltsv", \%info;
	return $new_sid;
}

sub renewal_session ($$$) {
	my ($ss, $old_sid, $sg) = @_;
	my $old_d = "$SESSIONDIR/sess_$old_sid";
	opendir my $h, $old_d or do{
		die "$old_d: cannot open, stopped";
	};
	my @f;
	while( my $f = readdir $h ){
		next if $f eq '..';
		next if $f eq '.';
		next if $f eq 'info.ltsv';
		push @f, $f;
	}
	close $h;
	foreach my $f ( @f ){ unlink "$old_d/$f"; }

	my $new_sid = random_regex "[0-9a-zA-Z]{32}";
	my $d = "$SESSIONDIR/sess_$new_sid";
	mkdir_or_die $d;

	my %info = ( 'timestamp' => $NOW, 'mode' => 'current', 'servicegroup' => $sg );
	$ss->{$new_sid}->{servicegroup} = \%info;
	write_internal_singleline "$d/info.ltsv", \%info;

	my $sessionurl = "$SESSIONURLBASE/sess_$new_sid/";
	my $template = read_plain "$CONFDIR/servicegroup_jump.tt";
	my $html = generate_by_template $template,
		 'new_sid' => $new_sid, 'SESSIONURL' => $sessionurl;
	my $old_d = "$SESSIONDIR/sess_$old_sid";
	write_plain "$old_d/index.html", $html;
	my %old_info = ( 'timestamp' => $NOW, 'mode' => 'transition', 'servicegroup' => $sg );
	$ss->{$old_sid}->{servicegroup} = \%old_info;
	write_internal_singleline "$old_d/info.ltsv", \%old_info;

	return $new_sid;
}

sub load_sessions () {
	my %ss;
	opendir my $h, $SESSIONDIR or do {
		return undef;
	};
	while( my $e = readdir $h ){
		next unless $e =~ m"^sess_([0-9a-zA-Z]+)$";
		my $id = $1;
		my %session;
		my $d = "$SESSIONDIR/$e";

		opendir my $i, $d or do {
			die "$d: cannot open, stopped";
		};
		while( my $f = readdir $i ){
			if( $f eq "index.html" ){
				my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,
				    $size,$atime,$mtime,$ctime,
				    $blksize,$blocks) = stat "$d/index.html";
				$session{has_page} = 1;
				$session{page_timestamp} = timestamp $mtime;
			}elsif( $f eq "info.ltsv" ){
				my $info = read_internal_singleline
					"$d/info.ltsv",
					'timestamp', 'servicegroup', 'mode';
				$session{timestamp}    = $info->{timestamp};
				$session{servicegroup} = $info->{servicegroup};
				$session{mode}         = $info->{mode};
			}elsif( $f =~ m"^([^,]+),([^,]+),([^,]+)\.png$" ){
				my $host     = $1;
				my $service  = $2;
				my $panel_id = $3;
				my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,
				    $size,$atime,$mtime,$ctime,
				    $blksize,$blocks) = stat "$d/$f";
				my $t = timestamp $mtime;
				my $u = $session{graphs_timestamp};
				$session{graphs_timestamp} = $t if $t gt $u;
				$session{graphs}->{"$host,$service,$panel_id"} = {
					'file'      => $f,
					'host'      => path_decode $host,
					'service'   => path_decode $service,
					'panel_id'  => $panel_id,
					'timestamp' => $t,
				};
			}else{
				#print "DEBUG: $f\n";
			}
		}
		close $i;
		$session{is_expired} = $session{timestamp} lt $SESSION_EXPIRYDATE;
		$session{has_expired_graphs} = $session{graphs_timestamp} lt $GRAPH_EXPIRYDATE;
		$ss{$id} = \%session;
	}
	close $h;
	return \%ss;
}

sub remove_session ($$) {
	my ($ss, $sid) = @_;
	my $d = "$SESSIONDIR/sess_$sid";
	opendir my $h, $d or do{
		die "$d: cannot open, stopped";
	};
	my @f;
	while( my $f = readdir $h ){
		next if $f eq '..';
		next if $f eq '.';
		push @f, $f;
	}
	close $h;
	foreach my $f ( @f ){ unlink "$d/$f"; }
	rmdir $d;
}

sub list_sessions ($) {
	my ($ss) = @_;
	return keys %$ss;
}

#sub set_session_servicegroup ($$$) {
#	my ($ss, $sid, $sg) = @_;
#	my %info = (
#		'timestamp'    => $NOW,
#		'servicegroup' => $sg,
#		'mode'         => 'current',
#	);
#	$ss->{$sid}->{servicegroup} = \%info;
#	write_internal_singleline "$SESSIONDIR/sess_$sid/info.ltsv", \%info;
#}

sub get_session_servicegroup ($$) {
	my ($ss, $sid) = @_;
	my $info = read_internal_singleline
		"$SESSIONDIR/sess_$sid/info.ltsv",
		'timestamp',
		'mode',
		'servicegroup';
	return $info->{servicegroup};
}

#### graphs download functions
sub graphs_are_expired () {
	my $timestamp;
	$timestamp = read_internal_timestamp "$WORKDIR/sg_graphs" if -f "$WORKDIR/sg_graphs";
	return $timestamp lt $GRAPH_EXPIRYDATE;
}

sub set_graphs_timestamp ($) {
	my ($timestamp) = @_;
	write_internal_timestamp "$WORKDIR/sg_graphs", $timestamp;
}


####

my $sgs = load_servicegroups;
my $ss = load_sessions;
foreach my $sg ( list_servicegroups $sgs ){
	debuglog "service group %s has been found.", $sg;
	my $servicegroup_has_changes = servicegroup_has_changes $sgs, $sg;

	update_servicegroup $sgs, $sg if $servicegroup_has_changes;
	my $status = get_servicegroup_status $sgs, $sg;

	my $sid;
	unless( servicegroup_has_session $sgs, $sg ){
		$sid = generate_session $ss, $sg;
		set_servicegroup_session_id $sgs, $sg, $sid;
	}else{
		$sid = get_servicegroup_session_id $sgs, $sg;
	}

	generate_session_page $ss, $sid, $status if $servicegroup_has_changes;
	generate_session_page $ss, $sid, $status unless session_has_page $ss, $sid;
}

foreach my $sg ( list_servicegroups $sgs ){
	my $status = get_servicegroup_status      $sgs, $sg;
	my @recipients = list_servicegroup_recipients $sgs, $sg;
	foreach my $recipient ( @recipients ){
		my $last_report_status = load_last_report_status  $sg, $recipient;
		my $changes = cmp_status $status, $last_report_status;
		my $next_report = load_next_report $sg, $recipient;
		update_next_report $next_report, $changes;

		if( defined $changes ){
			debuglog "changes have been found for %s in service group %s.", $recipient, $sg;
			debuglog "checking a necessity of waiting to report...";
			next if waiting_to_report $next_report, $last_report_status;

			debuglog "reporting...";
			report 'CHANGE', $status, $next_report, $last_report_status;
		}else{
			next unless servicegroup_has_ngs $sgs, $sg;
			next unless last_report_is_expired $last_report_status;
			debuglog "reporting...";
			report 'KEEP', $status, $next_report, $last_report_status;
		}
	}
}

foreach my $sid ( list_sessions $ss ){
	next unless session_is_expired $ss, $sid;
	if    ( session_is_current $ss, $sid ){
		my $sg  = get_session_servicegroup $ss, $sid;
		my $new_sid = renewal_session $ss, $sid, $sg;
		set_servicegroup_session_id $sgs, $sg, $new_sid;
		debuglog "A session %s has been expired and replaced to %s.", $sid, $new_sid;
	}elsif( session_is_in_transition $ss, $sid ){
		remove_session $ss, $sid;
		debuglog "A session %s has been removed.", $sid;
	}
}

debuglog "downloading graphs for new sessions...";
foreach my $sid ( list_sessions $ss ){
	next if session_is_expired $ss, $sid;
	next if session_is_in_transition $ss, $sid;
	next if session_has_graphs $ss, $sid;
	my $sg     = get_session_servicegroup $ss, $sid;
	my $status = get_servicegroup_status  $sgs, $sg;
	download_session_graphs $ss, $sid, $status;
}

debuglog "replacing expired graphs to downloaded graphs...";
if( graphs_are_expired ){
	foreach my $sid ( list_sessions $ss ){
		next if session_is_expired $ss, $sid;
		next if session_is_in_transition $ss, $sid;
		set_graphs_timestamp timestamp time;
		my $sg     = get_session_servicegroup $ss, $sid;
		my $status = get_servicegroup_status  $sgs, $sg;
		download_session_graphs $ss, $sid, $status;
	}
	set_graphs_timestamp timestamp time;
}


