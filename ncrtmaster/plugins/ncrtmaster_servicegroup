#!/usr/bin/perl

use strict;

our ($TOOLHOME, $PLUGINSDIR, $CONFDIR, $WORKDIR);
BEGIN {
	$0 =~ m"^(.*)/";
	$TOOLHOME = "$1/..";
	while( $TOOLHOME =~ s{(^|/)[^\.][^/]*/\.\.(/|$)}{$1} ){}
	$PLUGINSDIR = "$TOOLHOME/plugins";
	$CONFDIR = "$TOOLHOME/conf";
}
use lib "$TOOLHOME/lib/perl5";

use NCRTCommon;
use NCRTStackMachine;
use NCRTTimeSeries;

use Socket;
use Encode;
use LWP::UserAgent;
use JSON::XS;
use URI::Escape;
use MIME::Base64;
use MIME::EncWords ':all';
use Template;

if( @ARGV < 2 ){
	print "usage: % $0 CONFDIR WORKDIR\n";
	exit 1;
}

$CONFDIR = $ARGV[0];
$WORKDIR = $ARGV[1];

#### load global conf.

sub read_conffile (\%$) {
	my ($confref, $filename) = @_;
	my $f = "$CONFDIR/$filename";
	open my $h, '<', $f or do {
		#die "$f: cannot open, stopped";
		return;
	};
	while( <$h> ){
		chomp;
		next if m"^\s*($|#)";
		die "$f:$.: illegal format, stopped" unless m"^(\w+)=(.*)$";
		$$confref{$1} = $2;
	}
	close $h;
}

my %conf;
read_conffile %conf, "ncrtbuild.conf";
read_conffile %conf, "reporter/servicegroup.conf";

#### global variables

# for debug
our $DEBUG = $conf{DEBUG} // 0;

#
our $SENDMAILEXE = $conf{SENDMAIL} // '/usr/lib/sendmail';

# session directory
our $SESSIONDIR = $conf{SESSIONDIR} // $WORKDIR;

# session url base
our $SESSIONURLBASE = $conf{SESSIONURLBASE} // "http://example.com/ncrtmaster";

# grafana url
our $GRAFANAURL = $conf{GRAFANAURL} // "http://grafana.example.com";

# grafana API key
our $GRAFANAAPIKEY = $conf{GRAFANAAPIKEY} // "";

# grafana organization ID
our $GRAFANAORGID = $conf{GRAFANAORGID} // 1;

# grafana-dashboard-helper url
our $HELPERURL = $conf{HELPERURL} // "http://example.com/grafana-dashboard-helper";

# semaphore is expired after 30 min.
our $SEMAPHORETIMESPAN = $conf{SEMAPHORETIMESPAN} // 30*60;



####
sub ns ($) {
	return sprintf "%.2fs", $_[0];
}

sub nB ($) {
	return sprintf "%dB", $_[0];
}

####
sub timestamp ($) {
	my ($sec, $min, $hour, $day, $mon, $year) = localtime shift;
	return sprintf "%04d-%02d-%02d_%02d:%02d:%02d", $year+1900, $mon+1, $day, $hour, $min, $sec;
}

sub safesprintf ( @ ){
	my ($format, @args) = @_;
	my $text = sprintf $format, @args;
	$text =~ s{([\x00-\x1f\x7f])}{"\\x" . unpack('H2', $1);}eg;
	return $text;
}

our $LOG_HANDLE;
sub openlog () {
	open $LOG_HANDLE, '>>', "$WORKDIR/servicegroup.log" or return;
	my $old = select $LOG_HANDLE;
	$| = 1;
	select $old;
}

sub debuglog ( $;@ ){
	return unless $DEBUG;
	openlog unless defined $LOG_HANDLE;
	print $LOG_HANDLE timestamp(time), " ", safesprintf(@_), "\n";
}

sub errorlog ( $;@ ){
	openlog unless defined $LOG_HANDLE;
	print $LOG_HANDLE timestamp(time), " ", safesprintf(@_), "\n";
}

sub var2ltsv ( \% ){
	my ($var) = @_;
	my @ltsv;
	push @ltsv, "timestamp:".$var->{timestamp} if defined $var->{timestamp};
	foreach my $k ( sort {$a cmp $b} keys %$var ){
		next if $k eq 'timestamp';
		push @ltsv, "$k:".$var->{$k};
	}
	return join "\t", @ltsv;
}

sub ltsv2var ( $ ){
	my ($ltsv) = @_;
	my %var;
	foreach my $kv ( split m"\t", $ltsv ){
		$kv =~ m"^([-.\w]+):(.*)$" or do {
			next;
		};
		my $k = $1;
		my $v = $2;
		$var{$k} = $v;
	}
	return %var;
}

sub sendmail ($$$) {
	my ($mail, $mailfrom, $mailto) = @_;
	my $from_quoted = quotemeta $mailfrom;
	my $to_quoted = quotemeta $mailto;

	open my $h, '|-', "$SENDMAILEXE -f $from_quoted $to_quoted" or do {
		die "$SENDMAILEXE: cannot execute, stopped";
	};
	chomp $mail;
	my @mail = split m"\n", $mail;
	while( 1 ){
		$_ = shift @mail;
		last if $_ eq '';

		my $text;
		while( m"\G(?:(\s+)|([-:<>.\@_a-zA-Z0-9\x7F-\xFF]+)|(\S+))"g ){
			if   ( $1 ne '' ){ $text .= $1; }
			elsif( $2 ne '' ){ $text .= $2; }
			else{ $text .= encode_mimeword $3, 'B', 'UTF-8'; }
		}
		print $h $text, "\n";
	}
	print $h "MIME-Version: 1.0\n";
	print $h "Content-Transfer-Encoding: 8bit\n";
	print $h "Content-Type: text/plain; charset=utf-8\n",
		"\n";
	while( 1 ){
		$_ = shift @mail;
		last unless defined $_;
		my $text = decode_utf8( $_ );
		print $h encode_utf8($text), "\n";
	}
	close $h;
}

sub path_encode ($) {
	my ($text) = @_;
	$text =~ s{([\x00-\x1f/\x7f])}{"\%" . unpack('H2', $1);}eg;
	return $text;
}

sub path_decode ($) {
	my ($text) = @_;
	$text =~ s{%([0-9a-fA-F]{2})}{pack('H2', $1);}eg;
	return $text;
}

#### load conf rules for each servicegroups.

sub load_confrules () {
	my $f = "$CONFDIR/reporter/servicegroup.rules";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	my @confrules;
	my $sg_regexp;
	while( <$h> ){
		chomp;
		next if m"^\s*(#|$)";
		if    ( m"^===\s+(\S+)\s+===$" ){
			$sg_regexp = qr"^$1$";
		}elsif( m"^(\w+)=(.*)$" ){
			push @confrules, {
				type => 'PARAM',
				sg_regexp => $sg_regexp,
				key => $1, value => $2,
			};
		}elsif( m"^(?:(\S+\@\S+)|mail\s+(\S+))$" ){
			push @confrules, {
				type => 'EMAIL',
				sg_regexp => $sg_regexp,
				email => ($1 ne '' ? $1 : $2),
			};
		}elsif( m"^slack\s+(\S+)$" ){
			push @confrules, {
				type => 'SLACK',
				sg_regexp => $sg_regexp,
				url => $1,
			};
		}else{
			die "$f:$.: illegal format, stopped";
		}
	}
	close $h;

	return \@confrules;
}

sub apply_confrules ($$) {
	my ($rules, $sg) = @_;
	my %param;
	my @email;
	my @slack;

	foreach my $rule ( @$rules ){
		my $regexp = $$rule{sg_regexp};
		next unless $sg =~ m"$regexp";

		if    ( $$rule{type} eq "PARAM" ){
			$param{ $$rule{key} } = $$rule{value};
		}elsif( $$rule{type} eq "EMAIL" ){
			push @email, $$rule{email};
		}elsif( $$rule{type} eq "SLACK" ){
			push @slack, $$rule{url};
		}
	}

	return \%param, \@email, \@slack;
}

#### I/O functions

sub mkdir_or_die ($) {
	my ($d) = @_;
	return if -d $d;
	mkdir $d or die "$d: cannot create, stopped";
}

sub write_plain ($$) {
	my ($f, $html) = @_;
	if( !defined $f ){
		unlink $f if -f $f;
		return;
	}
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	print $h $html;
	close $h;
}

sub read_plain ($) {
	my ($f, $html) = @_;
	unless( -f $f ){
		return undef;
	}
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	my $r = join '', <$h>;
	close $h;
	return $r;
}

#### template functions

sub tmplfunc_match {
	my ($text, $re) = @_;
	my @r = $text =~ m"$re";
	if   ( @r == 0 ){ return undef; }
	elsif( @+ == 1 ){ return [$&]; }
	else            { return [$&, @r]; }
}

sub tmplfunc_sub {
	my ($text, $re, $replace) = @_;
	$text =~ s/$re/$replace/;
	return $text;
}

sub tmplfunc_gsub {
	my ($text, $re, $replace) = @_;
	$text =~ s/$re/$replace/g;
	return $text;
}

sub tmplfunc_split {
	my ($text, $re) = @_;
	return split m"$re", $text;
}

sub tmplfunc_safesprintf {
	my ($format, @args) = @_;
	return safesprintf $format, @args;
}

sub tmplfunc_urlencode {
	my ($text) = @_;
	return uri_escape $text;
}

sub tmplfunc_localtime {
	my ($unixtime) = @_;
	return timestamp $unixtime;
}

sub tmplfunc_obj2json {
	my ($obj) = @_;
	my $json = encode_json $obj;
	return $json;
}

sub generate_by_template ($%) {
	my ($template, %vars) = @_;
	my $tt = Template->new({}) or do {
		debuglog "cannot generate Template instance: %s", $Template::ERROR;
		return $template;
	};
	$vars{match}  //= \&tmplfunc_match;
	$vars{sub}    //= \&tmplfunc_sub;
	$vars{gsub}   //= \&tmplfunc_gsub;
	$vars{split}  //= \&tmplfunc_split;
	$vars{safesprintf} //= \&tmplfunc_safesprintf;
	$vars{urlencode} //= \&tmplfunc_urlencode;
	$vars{localtime} //= \&tmplfunc_localtime;
	$vars{obj2json} //= \&tmplfunc_obj2json;

	my $output;
	$tt->process( \$template, \%vars, \$output ) or do {
		debuglog "cannot process template: %s.", $tt->error();
		return $template;
	};
	return $output;
}

####

sub req_unix ($) {
	my ($url) = @_;

	socket my $h, PF_UNIX, SOCK_STREAM, 0 or return 3, 0;
	connect $h, sockaddr_un($url)         or return 2, 0;
	$h->autoflush(1);
	print $h "GET services\n";
	print $h "Columns: service_groups host_name description custom_variables state state_type last_hard_state perf_data\n";
	print $h "\n";
	shutdown $h, 1;

	my %sgname2servicenames;
	my %servicename2perfnames;
	my %servicedetails;
	my %perfdetails;
	while( <$h> ){
		chomp;
		unless( m"^([^;]*);([^;]+);([^;]+);([^;]+);(\d*);(\d*);(\d*);(.*)$" ){
			return 1;
		}

		my $service_groups   = $1;
		my $host             = $2;
		my $service          = $3;
		my $custom_variables = $4;
		my $state            = $5;
		my $state_type       = $6;
		my $last_hard_state  = $7;
		my $perf_data        = $8;
		my $hard_state = $state_type == 1 ? $state : $last_hard_state;
		next if $service_groups eq '';
		
		#
		my @service_groups = split m"\s+", $service_groups;

		#
		my %custom_variables;
		if( $custom_variables ne '' ){
			foreach my $kv ( split m",", $custom_variables ){
				$kv =~ m"^(\w+)\|(.*)$" or die;
				$custom_variables{$1} = $2;
			}
		}
		my $measure = $custom_variables{MEASURE};
		next unless defined $measure;

		#
		$servicedetails{"$measure:$host:$service"} = {
			fullname => "$measure:$host:$service",
			measure => $measure,
			host    => $host,
			service => $service,
			state   => $state,
			state_type      => $state_type,
			last_hard_state => $last_hard_state,
			hard_state => $hard_state,
		};
		my @perfnames;
		foreach my $p ( split m"\s+", $perf_data ){
			die "$p, stopped" unless $p =~ m"^
				([^=]+)=(-?\d[^;]*)(?:s|ms|us|%|B|KB|MB|GB|TB|c)?
				;(?:([^;:]*)(?::([^;:]*))?)
				;(?:([^;:]*)(?::([^;:]*))?)
			"x;
			my $k = $1;
			my $v = $2;
			my $warn_min = $3;
			my $warn_max = $4;
			my $warn = $3 ne '' ? "[$3,$4]" : undef;
			my $crit_min = $5;
			my $crit_max = $6;
			my $crit = $6 ne '' ? "[$5,$6]" : undef;
			my $perf_state = 0;
			my $perf_statetext;
			if    ( $crit_min ne '' && $v < $crit_min ){
				$perf_state = 2; $perf_statetext = 'under_crit';
			}elsif( $crit_max ne '' && $v > $crit_max ){
				$perf_state = 2; $perf_statetext = 'over_crit';
			}elsif( $warn_min ne '' && $v < $warn_min ){
				$perf_state = 1; $perf_statetext = 'under_warn';
			}elsif( $warn_max ne '' && $v > $warn_max ){
				$perf_state = 1; $perf_statetext = 'over_warn';
			}
			$perfdetails{"$measure:$host:$service:$k"} = {
				fullname => "$measure:$host:$service:$k",
				measure => $measure,
				host    => $host,
				service => $service,
				name      => $k,
				value     => $v,
				state     => $perf_state,
				statetext => $perf_statetext,
				warn_min  => $warn_min,
				warn_max  => $warn_max,
				warn      => $warn,
				crit_min  => $crit_min,
				crit_max  => $crit_max,
				crit      => $crit,
			};
			push @perfnames, "$measure:$host:$service:$k";
		}
		$servicename2perfnames{"$measure:$host:$service"} = \@perfnames;

		#
		foreach my $sg ( @service_groups ){
			push @{$sgname2servicenames{$sg}}, "$measure:$host:$service";
		}
	}
	close $h;
	return 0, \%sgname2servicenames, \%servicename2perfnames,
		\%servicedetails, \%perfdetails;
}

sub req_httpapi ($$$) {
	my ($url, $host, $desc) = @_;

	my $ua = LWP::UserAgent->new;
	$ua->agent("NCRTSessionGroupPlugin/1.0");
	$ua->timeout(60);
	my $u = $url;
	$u .= "/" unless $u =~ m"/$";
	$u .= "services?Filter[]=host_name %3d $host&Filter[]=description %3d $desc";
	my $req = HTTP::Request->new(GET => $u);
	my $res = $ua->request($req);
	return 4, 0 unless $res->is_success;

	my $obj;
	eval {
		$obj = JSON::XS->new->decode( $res->content );
	};
	return 3, 0 unless defined $obj;
	return 2, 0 if $$obj{success} eq "true";

	my %r;
	my $s = 0;
	foreach my $c ( @{$$obj{content}} ){
		my $perf_data = $$c{perf_data};
		foreach my $p ( split m"\s+", $perf_data ){
			next unless $p =~ m"^([^=]+)=(\d[^;]+)";
			my $k = $1;
			my $v = $2;
			$r{$k} = $v;
		}
		$s = $$obj{state} if $$obj{state} > $s;
		$r{"livestatus-service[$host][$desc]-state"} = $$obj{state};
	}
	return 0, $s, %r;
}

sub req ($) {
	my ($url) = @_;
	if    ( $url =~ m"^https?://" ){
		#return req_httpapi $url, $host, $desc;
	}elsif( $url =~ m"^/" ){
		return req_unix $url;
	}
	die;
}

#### functions for Critical Setion

sub start_criticalsection () {
	my $f = "$WORKDIR/servicegroup_semaphore";
	my $t = time;
	my $timestamp = timestamp $t;
	my $d = "pid=$$ unixtime=$t timestamp=$timestamp";
	symlink $d, $f and return 1;
	debuglog "$f: semaphore is used.";
	return undef unless -l $f;
	my $l = readlink $f;
	debuglog "$f: semaphore is '$l'.";
	return undef unless $l =~ m"^pid=(\S+) unixtime=(\S+) timestamp=(\S+)";
	my $last_t = $2;
	return undef unless $t - $last_t > $SEMAPHORETIMESPAN;
	unlink $f or return undef;
	debuglog "$f: semaphore is removed.";
	symlink $d, $f and return 1;
	return undef;
}

sub criticalsection_has_been_kept () {
	my $f = "$WORKDIR/servicegroup_semaphore";
	return undef unless -l $f;
	my $l = readlink $f;
	return undef unless $l =~ m"^pid=(\S+) unixtime=(\S+) timestamp=(\S+)";
	my $last_pid = $1;
	return 1 if $last_pid == $$;
	return undef;
}

sub end_criticalsection () {
	my $f = "$WORKDIR/servicegroup_semaphore";
	return undef unless -l $f;
	my $l = readlink $f;
	return undef unless $l =~ m"^pid=(\S+) unixtime=(\S+) timestamp=(\S+)";
	my $last_pid = $1;
	unlink $f if $last_pid == $$;
}

sub start_criticalsection_for_session ($) {
	my ($session) = @_;
	my $f = "$SESSIONDIR/sess_$session/.semaphore";
	my $t = time;
	my $timestamp = timestamp $t;
	my $d = "pid=$$ unixtime=$t timestamp=$timestamp";
	symlink $d, $f and return 1;
	debuglog "$f: semaphore is used.";
	return undef unless -l $f;
	my $l = readlink $f;
	debuglog "$f: semaphore is '$l'.";
	return undef unless $l =~ m"^pid=(\S+) unixtime=(\S+) timestamp=(\S+)";
	my $last_t = $2;
	return undef unless $t - $last_t > $SEMAPHORETIMESPAN;
	unlink $f or return undef;
	debuglog "$f: semaphore is removed.";
	symlink $d, $f and return 1;
	return undef;
}

sub end_criticalsection_for_session ($) {
	my ($session) = @_;
	my $f = "$SESSIONDIR/sess_$session/.semaphore";
	return undef unless -l $f;
	my $l = readlink $f;
	return undef unless $l =~ m"^pid=(\S+) unixtime=(\S+) timestamp=(\S+)";
	my $last_pid = $1;
	unlink $f if $last_pid == $$;
}

sub start_criticalsection_for_report ($$) {
	my ($servicegroup, $reporttype) = @_;
	my $f = "$WORKDIR/servicegroup_semaphore_for_report.$reporttype.$servicegroup";
	my $t = time;
	my $timestamp = timestamp $t;
	my $d = "pid=$$ unixtime=$t timestamp=$timestamp";
	symlink $d, $f and return 1;
	debuglog "$f: semaphore is used.";
	return undef unless -l $f;
	my $l = readlink $f;
	debuglog "$f: semaphore is '$l'.";
	return undef unless $l =~ m"^pid=(\S+) unixtime=(\S+) timestamp=(\S+)";
	my $last_t = $2;
	return undef unless $t - $last_t > $SEMAPHORETIMESPAN;
	unlink $f or return undef;
	debuglog "$f: semaphore is removed.";
	symlink $d, $f and return 1;
	return undef;
}

sub end_criticalsection_for_report ($$) {
	my ($servicegroup, $reporttype) = @_;
	my $f = "$WORKDIR/servicegroup_semaphore_for_report.$reporttype.$servicegroup";
	return undef unless -l $f;
	my $l = readlink $f;
	return undef unless $l =~ m"^pid=(\S+) unixtime=(\S+) timestamp=(\S+)";
	my $last_pid = $1;
	unlink $f if $last_pid == $$;
	unlink $f if $last_pid == $$;
}

#### functions for Service Details / Perf Details

sub load_servicedetails () {
	my $json = read_plain "$WORKDIR/servicegroup_servicedetails.json";
	return {} if $json eq '';
	return eval {
		my $obj = decode_json $json;
		return $obj;
	};
}

sub store_servicedetails ($) {
	my ($servicedetails) = @_;
	return unless criticalsection_has_been_kept;
	eval {
		my $json = encode_json $servicedetails;
		write_plain "$WORKDIR/servicegroup_servicedetails.json", $json;
	};
}

sub load_perfdetails () {
	my $json = read_plain "$WORKDIR/servicegroup_perfdetails.json";
	return {} if $json eq '';
	return eval {
		my $obj = decode_json $json;
		return $obj;
	};
}

sub store_perfdetails ($) {
	my ($perfdetails) = @_;
	return unless criticalsection_has_been_kept;
	eval {
		my $json = encode_json $perfdetails;
		write_plain "$WORKDIR/servicegroup_perfdetails.json", $json;
	};
}

sub cmp_keys ($$) {
	my ($old, $new) = @_;
	my %t;
	while( my ($k, $v) = each %$old ){ $t{$k} += 1; }
	while( my ($k, $v) = each %$new ){ $t{$k} += 2; }
	my @removed;
	my @added;
	my @keeped;
	while( my ($k, $v) = each %t ){
		if   ( $v == 1 ){ push @removed, $k; }
		elsif( $v == 2 ){ push @added,   $k; }
		else            { push @keeped,  $k; }
	}
	return \@removed, \@added, \@keeped;
}

sub cmp_servicestates ($$) {
	my ($old, $new) = @_;
	my ($removed, $added, $keeped) = cmp_keys $old, $new;
	my $ng = 0;
	my @changes;
	my @events;
	foreach my $k ( sort @$keeped ){
		my $o = $$old{$k}->{hard_state};
		my $n = $$new{$k}->{hard_state};
		my ($measure, $host, $service) = $k =~ m"^([^:]+):([^:]+):([^:]+)$";
		push @changes, {
			type => "servicestate_change", timestamp => time,
			event => "changes",
			name => $k,
			old => $o,
			new => $n,
			measure => $measure, host => $host, service => $service,
		} unless $o eq $n;
		$ng++ unless $n == 0;
	}
	foreach my $k ( sort @$removed ){
		my ($measure, $host, $service) = $k =~ m"^([^:]+):([^:]+):([^:]+)$";
		push @events, {
			type => "servicestate_event", timestamp => time,
			event => "removed",
			name => $k,
			measure => $measure, host => $host, service => $service,
		};
	}
	foreach my $k ( sort @$added ){
		my ($measure, $host, $service) = $k =~ m"^([^:]+):([^:]+):([^:]+)$";
		push @events, {
			type => "servicestate_event", timestamp => time,
			event => "added",
			name => $k,
			measure => $measure, host => $host, service => $service,
		};
		my $n = $$new{$k}->{hard_state};
		push @changes, {
			type => "servicestate_change", timestamp => time,
			event => "changes",
			name => $k,
			new => $n,
			measure => $measure, host => $host, service => $service,
		} unless $n == 0;
		$ng++ unless $n == 0;
	}
	return $ng, \@changes, \@events;
}

sub cmp_perfstates ($$) {
	my ($old, $new) = @_;
	my ($removed, $added, $keeped) = cmp_keys $old, $new;
	my $ng = 0;
	my @changes;
	my @events;
	foreach my $k ( sort @$keeped ){
		my ($measure, $host, $service, $perf) = $k =~ m"^([^:]+):([^:]+):([^:]+):(.*)$";
		my $o = $$old{$k}->{state};
		my $n = $$new{$k}->{state};
		push @changes, {
			type => "perfstate_change", timestamp => time,
			event => "changes",
			name => $k,
			old => $o,
			new => $n,
			measure => $measure, host => $host, service => $service,
			perf => $perf,
		} unless $o eq $n;
		$ng++ unless $n == 0;
	}
	foreach my $k ( sort @$removed ){
		my ($measure, $host, $service, $perf) = $k =~ m"^([^:]+):([^:]+):([^:]+):(.*)$";
		push @events, {
			type => "perfstate_event", timestamp => time,
			event => "removed",
			name => $k,
			measure => $measure, host => $host, service => $service,
			perf => $perf,
		};
	}
	foreach my $k ( sort @$added ){
		my ($measure, $host, $service, $perf) = $k =~ m"^([^:]+):([^:]+):([^:]+):(.*)$";
		push @events, {
			type => "perfstate_event", timestamp => time,
			event => "added",
			name => $k,
			measure => $measure, host => $host, service => $service,
			perf => $perf,
		};
		my $n = $$new{$k}->{state};
		push @changes, {
			type => "perfstate_change", timestamp => time,
			event => "changes",
			name => $k,
			new => $n,
			measure => $measure, host => $host, service => $service,
			perf => $perf,
		} unless $n == 0;
		$ng++ unless $n == 0;
	}
	return $ng, \@changes, \@events;
}

sub trim_perfstate_events ($$$) {
	my ($perfstate_events, $old_servicestates, $new_servicestates) = @_;
	my @t;
	foreach my $ev ( @$perfstate_events ){

		my $measure = $$ev{measure};
		my $host    = $$ev{host};
		my $service = $$ev{service};
		my $event   = $$ev{event};

		my $name = "$measure:$host:$service";
		my $old  = $$old_servicestates{$name}->{hard_state};
		my $new  = $$new_servicestates{$name}->{hard_state};
		next if $old == 0 && $new != 0 && $event eq 'removed';
		next if $old != 0 && $new == 0 && $event eq 'added';
		push @t, $ev;
	}
	return \@t;
}

sub mkdir_for_session ($) {
	my ($sid) = @_;
	my $d = "$SESSIONDIR/sess_$sid";
	return if -d $d;
	mkdir_or_die $d;
}

sub rmdir_for_session ($) {
	my ($sid) = @_;
	my $d = "$SESSIONDIR/sess_$sid";
	return unless -d $d;
	opendir my $h, $d or do{
		die "$d: cannot open, stopped";
	};
	my @f;
	while( my $f = readdir $h ){
		next if $f eq '..';
		next if $f eq '.';
		push @f, $f;
	}
	close $h;
	foreach my $f ( @f ){ unlink "$d/$f"; }
	rmdir $d;
}

sub load_trashbox () {
	my $json = read_plain "$WORKDIR/servicegroup_trashbox.json";
	return {} if $json eq '';
	return eval {
		return decode_json $json;
	};
}

sub store_trashbox ($) {
	my ($trashbox) = @_;
	return unless criticalsection_has_been_kept;
	eval {
		my $json = encode_json $trashbox;
		write_plain "$WORKDIR/servicegroup_trashbox.json", $json;
	};
}

sub move_session_into_trashbox ($$$$) {
	my ($trashbox, $session, $next_session, $expire_timespan) = @_;
	my $entry;
	if( $next_session eq '' ){
		$entry = {
			type       => 'CLOSED',
			createtime => time,
			expire_timespan => $expire_timespan,
		};
	}else{
		$entry = {
			type            => 'RENAMED',
			createtime      => time,
			expire_timespan => $expire_timespan,
			next            => $next_session,
		};
		my $template = read_plain
			"$CONFDIR/reporter/servicegroup_inactivesession.tt";
		my $html = generate_by_template $template,
			session      => $session,
			next_session => $next_session;
		write_plain
			"$SESSIONDIR/sess_$session/index.html", $html;
	}
	$$trashbox{sessions}->{$session} = $entry;
}

sub get_expired_from_trashbox ($) {
	my ($trashbox) = @_;
	my $sessions = $$trashbox{sessions};
	my $now = time;
	my @r;
	while( my ($k, $v) = each %$sessions ){
		my $createtime      = $$v{createtime};
		my $expire_timespan = $$v{expire_timespan};
		push @r, $k if $now - $createtime > $expire_timespan*60;
	}
	return \@r;
}

sub remove_session_from_trashbox ($$) {
	my ($trashbox, $session) = @_;
	my $sessions = $$trashbox{sessions};
	rmdir_for_session $session;
	delete $$sessions{$session};
}


#### funtions for Service Group Status Files
sub create_sgstate ($) {
	return {};
}

sub load_sgstate ($) {
	my ($service_group) = @_;
	my $json = read_plain "$WORKDIR/servicegroup_sg_$service_group.json";
	return {} if $json eq '';
	return eval {
		my $obj = decode_json $json;
		return $obj;
	};
}

sub store_sgstate ($$) {
	my ($service_group, $sgstate) = @_;
	return unless criticalsection_has_been_kept;
	eval {
		my $json = encode_json $sgstate;
		write_plain "$WORKDIR/servicegroup_sg_$service_group.json", $json;
	};
}

sub create_session () {
	my $random = pack('nnn', int rand 65536, $$ & 65535, int rand 65536);
	my $session = encode_base64($random, '');
	$session =~ s|\+|_|g;
	$session =~ s|/|-|g;
	return $session;
}

sub get_session_from_sgstate ($) {
	my ($sgstate) = @_;
	return $$sgstate{session};
}

sub set_session_into_sgstate ($$) {
	my ($sgstate, $session) = @_;
	$$sgstate{session} = $session;
}

sub get_servicestates ($$) {
	my ($servicedetails, $servicenames) = @_;
	my %r;
	foreach my $servicename ( @$servicenames ){
		$r{$servicename} = $$servicedetails{$servicename};
	}
	return \%r;
}

sub get_perfstates ($$$) {
	my ($perfdetails, $servicenames, $servicename2perfnames) = @_;
	my %r;
	foreach my $servicename ( @$servicenames ){
		my $perfnames = $$servicename2perfnames{$servicename};
		foreach my $perfname ( @$perfnames ){
			$r{$perfname} = $$perfdetails{$perfname};
		}
	}
	return \%r;
}

sub set_servicestates_into_sgstate ($$) {
	my ($sgstate, $servicestates) = @_;
	$$sgstate{servicestates} = $servicestates;
}

sub set_perfstates_into_sgstate ($$) {
	my ($sgstate, $perfstates) = @_;
	$$sgstate{perfstates} = $perfstates;
}

sub get_servicestates_from_sgstate ($) {
	my ($sgstate) = @_;
	return $$sgstate{servicestates} // {};
}

sub get_perfstates_from_sgstate ($) {
	my ($sgstate) = @_;
	return $$sgstate{perfstates} // {};
}

sub get_num_of_ng_from_sgstate ($) {
	my ($sgstate) = @_;
	my $num_of_ng_in_services = $$sgstate{num_of_ng_in_services};
	my $num_of_ng_in_perfs    = $$sgstate{num_of_ng_in_perfs};
	my $ng_timestamp          = $$sgstate{ng_timestamp};
	return $num_of_ng_in_services, $num_of_ng_in_perfs, $ng_timestamp;
}

sub set_num_of_ng_into_sgstate ($$$$) {
	my ($sgstate, $num_of_ng_in_services, $num_of_ng_in_perfs, $ng_timestamp) = @_;
	my $last_num_of_ng_in_services = $$sgstate{num_of_ng_in_services};
	my $last_num_of_ng_in_perfs    = $$sgstate{num_of_ng_in_perfs};
	$$sgstate{num_of_ng_in_services} = $num_of_ng_in_services;
	$$sgstate{num_of_ng_in_perfs}    = $num_of_ng_in_perfs;
	$$sgstate{ng_timestamp} = $ng_timestamp;
}

sub get_reporttime_from_sgstate ($) {
	my ($sgstate) = @_;
	return $$sgstate{reporttime};
}

sub set_reporttime_into_sgstate ($$) {
	my ($sgstate, $time) = @_;
	$$sgstate{reporttime} = $time;
}

sub set_servicestate_history ($$) {
	my ($sgstate, $servicestate_history) = @_;
	$$sgstate{servicestate_history} = $servicestate_history;
}

sub set_perfstate_history ($$) {
	my ($sgstate, $perfstate_history) = @_;
	$$sgstate{perfstate_history} = $perfstate_history;
}

sub get_servicestate_history ($) {
	my ($sgstate) = @_;
	return $$sgstate{servicestate_history} // [];
}

sub get_perfstate_history ($) {
	my ($sgstate) = @_;
	return $$sgstate{perfstate_history} // [];
}

sub set_highlighted_servicenames ($$) {
	my ($sgstate, $highlighted_servicenames) = @_;
	$$sgstate{highlighted_servicenames} = $highlighted_servicenames;
}

sub set_highlighted_perfnames ($$) {
	my ($sgstate, $highlighted_perfnames) = @_;
	$$sgstate{highlighted_perfnames} = $highlighted_perfnames;
}

sub get_highlighted_servicenames ($) {
	my ($sgstate) = @_;
	return $$sgstate{highlighted_servicenames} // {};
}

sub get_highlighted_perfnames ($) {
	my ($sgstate) = @_;
	return $$sgstate{highlighted_perfnames} // {};
}

sub verify_highlighted ($$) {
	my ($highlighted, $states) = @_;
	while( my ($k, $v) = each %$states ){
		if( defined $$v{hard_state} ){
			next if $$highlighted{$k};
			next if $$v{hard_state} == 0;
			$$highlighted{$k} = 1;
			debuglog "verify_highlighted: %s: completed.", $k;
		}elsif( defined $$v{state} ){
			next if $$highlighted{$k};
			next if $$v{state} == 0;
			$$highlighted{$k} = 1;
			debuglog "verify_highlighted: %s: completed.", $k;
		}
	}
}

sub get_highlighted ($$) {
	my ($highlighted, $d) = @_;
	my %r;
	foreach my $i ( keys %$highlighted ){ $r{$i} = $$d{$i}; }
	return \%r;
}

sub merge_highlighted ($$) {
	my ($last_highlighted, $changed) = @_;
	my %r;
	foreach my $i ( keys %$last_highlighted ){ $r{$i}        = 1; }
	foreach my $c ( @$changed )              { $r{$$c{name}} = 1; }
	return \%r;
}

sub merge_history ($$) {
	my ($left, $right) = @_;
	my @merged = sort {
		$$a{timestamp} <=> $$b{timestamp} ||
		$$a{type} cmp $$b{type} ||
		$$a{name} cmp $$b{name};
	} (@$left, @$right);
	return \@merged;
}

sub trim_history ($$) {
	my ($history, $timestamp) = @_;
	my @r;
	return [] unless defined $history;
	foreach my $h (@$history){
		push @r, $h if $$h{timestamp} > $timestamp;
	}
	return \@r;
}

sub select_ngservice_from_servicestates ($) {
	my ($states) = @_;
	my @r;
	foreach my $name ( sort keys %$states ){
		my $detail = $$states{$name};
		next if $$detail{hard_state} == 0;
		push @r, $detail;
	}
	return \@r;
}

sub select_ngperf_from_perfstates ($) {
	my ($states) = @_;
	my @r;
	foreach my $name ( sort keys %$states ){
		my $detail = $$states{$name};
		next if $$detail{state} == 0;
		push @r, $detail;
	}
	return \@r;
}

sub get_sessiontime_from_sgstate ($) {
	my ($sgstate) = @_;
	return $$sgstate{sessioncreatetime}, $$sgstate{sessionupdatetime};
}

sub set_sessiontime_into_sgstate ($$$) {
	my ($sgstate, $createtime, $updatetime) = @_;
	$$sgstate{sessioncreatetime} = $createtime;
	$$sgstate{sessionupdatetime} = $updatetime;
}

#### functions related reporting

sub load_reporttime ($$) {
	my ($servicegroup, $reporttype) = @_;
	my $f = "$WORKDIR/servicegroup_reporttime.$reporttype.$servicegroup";
	my ( $dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	     $atime,$mtime,$ctime,$blksize,$blocks ) = stat $f;
	return $mtime;
}

sub store_reporttime ($$) {
	my ($servicegroup, $reporttype) = @_;
	my $f = "$WORKDIR/servicegroup_reporttime.$reporttype.$servicegroup";
	open my $h, '>', $f or return undef;
	close $h;
	return 1;
}

sub load_reportstatus ($$) {
	my ($servicegroup, $reporttype) = @_;
	my $f = "$WORKDIR/servicegroup_reportstatus.$reporttype.$servicegroup";
	my ( $dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	     $atime,$mtime,$ctime,$blksize,$blocks ) = stat $f;
     	return undef, undef unless defined $mtime;

     	open my $h, "<", $f or die;
	my $status = <$h>;
	chomp $status;
	close $h;

	return $mtime, $status;
}

sub store_reportstatus ($$$) {
	my ($servicegroup, $reporttype, $status) = @_;
	my $f = "$WORKDIR/servicegroup_reportstatus.$reporttype.$servicegroup";
	open my $h, '>', $f or return undef;
	print $h $status;
	close $h;
	return 1;
}

#### functions related to mail reporting

sub eval_history ($$$$$$) {
	my ( $servicestate_history, $perfstate_history,
	     $threshold_for_ok,
	     $threshold_for_warn,
	     $threshold_for_crit,
	     $threshold_for_unknown ) = @_;
	my $now = time;

	my $servicestate_changes_ok      = 0;
	my $servicestate_changes_warn    = 0;
	my $servicestate_changes_crit    = 0;
	my $servicestate_changes_unknown = 0;
	my $perfstate_changes_ok         = 0;
	my $perfstate_changes_warn       = 0;
	my $perfstate_changes_crit       = 0;
	my $perfstate_changes_unknown    = 0;

	foreach my $i ( @$servicestate_history ){
		my $type       = $$i{type};
		my $timestamp  = $$i{timestamp};
		my $event      = $$i{event};
		my $name       = $$i{name};
		my $state      = $$i{new};
		if   ( $state == 0 ){ $servicestate_changes_ok++; }
		elsif( $state == 1 ){ $servicestate_changes_warn++; }
		elsif( $state == 2 ){ $servicestate_changes_crit++; }
		elsif( $state == 3 ){ $servicestate_changes_unknown++; }
		else{ die; }
	}
	foreach my $i ( @$perfstate_history ){
		my $type       = $$i{type};
		my $timestamp  = $$i{timestamp};
		my $event      = $$i{event};
		my $name       = $$i{name};
		my $state      = $$i{new};
		if   ( $state == 0 ){ $perfstate_changes_ok++; }
		elsif( $state == 1 ){ $perfstate_changes_warn++; }
		elsif( $state == 2 ){ $perfstate_changes_crit++; }
		elsif( $state == 3 ){ $perfstate_changes_unknown++; }
		else{ die; }
	}

	return 1 if $servicestate_changes_ok      >= $threshold_for_ok;
	return 1 if $servicestate_changes_warn    >= $threshold_for_warn;
	return 1 if $servicestate_changes_crit    >= $threshold_for_crit;
	return 1 if $servicestate_changes_unknown >= $threshold_for_unknown;
	return undef;
}

sub report_by_mail ($$$$$$$$$) {
	my (
		$param, $sg, $session, $reporting_plan,
	       	$trimed_servicestate_history, $trimed_perfstate_history,
		$highlighted_services, $highlighted_perfs,
		$emails
	) = @_;

	my $mailfrom = $$param{MAILFROM};
	my $history = merge_history
		$trimed_servicestate_history, $trimed_perfstate_history;
	my $template = read_plain "$CONFDIR/reporter/servicegroup_mail.tt";

	foreach my $recipient ( @$emails ){

		my $mail = generate_by_template $template,
			'highlighted_services' => $highlighted_services,
			'highlighted_perfs'    => $highlighted_perfs,
			'servicestate_history' => $trimed_servicestate_history,
			'perfstate_history'    => $trimed_perfstate_history,
			'history'              => $history,
			'reason'               => $reporting_plan,
			'NOW'                  => time,
			'SESSIONURL' => "$SESSIONURLBASE/sess_$session/",
			'MAILFROM' => $mailfrom, 'MAILTO' => $recipient,
			'SERVICEGROUP' => $sg;

		debuglog "sendmail: from=%s", $mailfrom;
		debuglog "sendmail: to=%s", $recipient;
		debuglog "sendmail: message=%s", $mail;
		sendmail $mail, $mailfrom, $recipient;
	}
}

sub create_reporting_plan_by_mail ($$$$$$) {
	my (
		$param, $sg, $session, $session_plan,
	       	$servicestate_history, $perfstate_history
	) = @_;

	my $now = time;
	my $last_reporttime = load_reporttime $sg, "mail";
	my $elapsed = $now - $last_reporttime;

	my $trimed_servicestate_history = trim_history
		$servicestate_history, $last_reporttime;
	my $trimed_perfstate_history = trim_history
		$perfstate_history, $last_reporttime;

	# params related to reporting via mail
	my $resend_timespan       = $$param{RESEND_TIMESPAN} // 30;
	my $min_resend_timespan   = $$param{MIN_RESEND_TIMESPAN} // 3;
	my $threshold_for_ok      = $$param{RESEND_THRESHOLD_FOR_OK} // 5;
	my $threshold_for_warn    = $$param{RESEND_THRESHOLD_FOR_WARN} // 5;
	my $threshold_for_crit    = $$param{RESEND_THRESHOLD_FOR_CRIT} // 1;
	my $threshold_for_unknown = $$param{RESEND_THRESHOLD_FOR_UNKNOWN} // 1;

	if    ( $session_plan eq 'OPEN' ){
		return 'open';
	}elsif( $session_plan eq 'CLOSE' ){
	       	return 'close' if @$trimed_servicestate_history;
	       	return 'close' if @$trimed_perfstate_history;
		return undef;
	}elsif( $session_plan eq 'KEEP' || $session_plan eq 'UPDATE' ||
	       	$session_plan eq 'RENAME' ){
		return undef  if $elapsed < $min_resend_timespan*60;
		return 'keep' if $elapsed > $resend_timespan*60;

		return 'change' if eval_history
			$trimed_servicestate_history,
		       	$trimed_perfstate_history,
			$threshold_for_ok,
			$threshold_for_warn,
			$threshold_for_crit,
			$threshold_for_unknown;
	}
	return undef;
}

sub execute_reporting_plan_by_mail ($$$$$$$$$) {
	my (
		$param, $sg, $session, $reporting_plan,
	       	$servicestate_history, $perfstate_history,
		$highlighted_services, $highlighted_perfs,
		$emails
	) = @_;

	return if fork;

	unless( start_criticalsection_for_report $sg, "mail" ){
		errorlog "REPORTING_ERROR: mail, sg=$sg: cannot start criticalsection.";
		exit 0;
	}

	my $last_reporttime = load_reporttime $sg, "mail";
	my $trimed_servicestate_history = trim_history
		$servicestate_history, $last_reporttime;
	my $trimed_perfstate_history = trim_history
		$perfstate_history, $last_reporttime;

	report_by_mail $param, $sg, $session, $reporting_plan,
	       	$trimed_servicestate_history, $trimed_perfstate_history,
		$highlighted_services, $highlighted_perfs,
		$emails;

	store_reporttime $sg, "mail";
	end_criticalsection_for_report $sg, "mail";

	exit 0;
}

#### functions for Slack

sub post_http_to_url ($$$) {
	my ($url, $message, $param) = @_;

	my $timeout = $$param{SLACK_TIMEOUT} // 60;
	my $proxy   = $$param{SLACK_PROXY};

	my $ua = LWP::UserAgent->new;
	$ua->agent("NCRTSessionGroupPlugin/1.0");
	$ua->timeout($timeout);
	$ua->proxy(['http', 'https'], $proxy) if $proxy;

	my $header = [
		'Content-type' => 'application/json',
	];

	my $req = HTTP::Request->new('POST', $url, $header, $message);
	my $res = $ua->request($req);
	return undef unless $res->is_success;
	my $res_content = $res->content;
	return undef unless $res_content eq 'ok';
	return 1;
}

sub report_by_slack ($$$$$) {
	my ( $param, $sg, $session, $reporting_plan, $urls) = @_;
	return unless defined $urls;

	my $f = "$CONFDIR/reporter/servicegroup_slack_$reporting_plan.tt";
	my $template = read_plain $f;
	return if $template eq '';
	my $json = generate_by_template $template,
		'reason'       => $reporting_plan,
		'SERVICEGROUP' => $sg,
		'SESSIONURL' => "$SESSIONURLBASE/sess_$session/",
		'NOW' => time;

	foreach my $url ( @$urls ){
		my $r = post_http_to_url $url, $json, $param;
		debuglog "report_by_slack: sg=%s action=%s result=%s",
			$sg, $reporting_plan, $r;
	}
}

sub create_reporting_plan_by_slack ($$$$) {
	my ($param, $sg, $session, $session_plan) = @_;

	my ($last_time, $last_status) =	load_reportstatus $sg, 'slack';

     	my $plan;
	if    ( $session_plan eq 'OPEN' ){
		$plan = 'open';
	}elsif( $session_plan eq 'CLOSE' ){
		$plan = 'close';
	}elsif( $session_plan eq 'RENAME' ){
		$plan = 'rename';
	}
	if( defined $plan ){
		return undef if $last_status eq "$plan $session";
		store_reportstatus $sg, 'slack', "$plan $session";
		return $plan;
	}

	return undef unless defined $last_time;
	return undef if $last_status eq "";

	my ($last_plan, $last_session) = split m" ", $last_status;
	return undef unless $session eq $last_session;

	return undef unless $last_time < time - 5*60;

	store_reportstatus $sg, 'slack', "$last_plan $session";
	return $last_plan;
}

sub execute_reporting_plan_by_slack ($$$$$) {
	my ($param, $sg, $session, $reporting_plan, $urls) = @_;

	return if fork;
	unless( start_criticalsection_for_report $sg, "slack" ){
		errorlog "REPORTING_ERROR: ".
	       		"slack, sg=%s: cannot start criticalsection.", $sg;
		end_criticalsection_for_report $sg, "slack";
		exit 0;
	}

	my $r = report_by_slack $param, $sg, $session, $reporting_plan, $urls;
	unless( $r ){
		errorlog "REPORTING_ERROR: ".
			"slack, sg=%s: failed(rc=%d).", $sg, $r;
		end_criticalsection_for_report $sg, "slack";
		exit 0;
	}

	store_reportstatus $sg, "slack", "";
	end_criticalsection_for_report $sg, "slack";
	exit 0;
}


#### functions for Alert Settion Web Page

sub generate_html_for_session ($$$$$$){
	my ($sg, $session, $highlighted_services, $highlighted_perfs, $perf2graphs_cache, $now) = @_;

	my @graphlist;
	foreach my $name ( sort keys %$highlighted_perfs ){
		push @graphlist, @{ $$perf2graphs_cache{$name} };
	}
	my @servicelist;
	foreach my $name ( sort keys %$highlighted_services ){
		push @servicelist, $$highlighted_services{$name};
	}
	my @perflist;
	foreach my $name ( sort keys %$highlighted_perfs ){
		push @perflist, $$highlighted_perfs{$name};
	}
	my $template = read_plain "$CONFDIR/reporter/servicegroup_activesession.tt";
	my $html = generate_by_template $template,
		'servicelist' => \@servicelist,
		'perflist'    => \@perflist,
		'graphlist'   => \@graphlist,
		'perf2graphs' => $perf2graphs_cache,
		'SERVICEGROUP' => $sg,
		'NOW' => $now;

	my $d = "$SESSIONDIR/sess_$session";
	write_plain "$d/index.html", $html;
}

sub download_panel_png_from_grafana ($) {
	my ($url) = @_;
	my $ua = LWP::UserAgent->new;
	my $req = HTTP::Request->new('GET' => "$url&from=now-6h&to=now");
	$req->header( Authorization => "Bearer $GRAFANAAPIKEY" );
	debuglog "grafana: url=%s, requesting...", $url;
	my $res = $ua->request($req);
	return $res->content;
}

sub query_panels_to_grafana_dashboard_helper ($$) {
	my ($host, $service ) = @_;
	my $ua = LWP::UserAgent->new;
	my $server_endpoint = sprintf
		'%s/dashboard_info.js?hostname=%s&servicedesc=%s',
		$HELPERURL, $host, $service;
	my $req = HTTP::Request->new('GET' => $server_endpoint);
	debuglog "grafana-dashboard-helper: url=%s, requesting...", $server_endpoint;
	my $res = $ua->request($req);
	return undef unless $res->code eq '200';
	my $obj;
	eval { $obj = decode_json $res->content; };
	return undef if $@;
	return $$obj{panels};
}

sub update_perf2graphs_cache ($$) {
	my ($perf2graphs_cache, $highlighted_perfnames) = @_;
	while( my ($name, undef) = each %$highlighted_perfnames ){
		next if defined $$perf2graphs_cache{$name};

		unless( $name =~ m"^(\w+):([^:]+):([^:]+):(.*)$" ){
			die "$name: stopped";
		}
		my ($measure, $host, $service, $perfname) = ($1, $2, $3, $4);
		my $host_encoded    = path_encode $host;
		my $service_encoded = path_encode $service;
		my $panels = query_panels_to_grafana_dashboard_helper
			$host_encoded, $service_encoded;
		foreach my $panel ( @{$panels // []} ){
			my $id = $$panel{id};
			my $i = {
				title => $$panel{title},
				id    => $id,
				url   => $$panel{url},
				perfs => $$panel{performancenames},
				name  => "$host_encoded,$service_encoded,$id",
			};
			foreach my $p ( @{$$panel{performancenames} // []} ){
				my $k = "$measure:$host:$service:$p";
				push @{$$perf2graphs_cache{$k}}, $i;
			}
		}

		unless( defined $$perf2graphs_cache{$name} ){
			$$perf2graphs_cache{$name} = [];
		}
	}
}

sub generate_graphs_for_session ($$$) {
	my ($session, $perf2graphs_cache, $hilighted_perfnames) = @_;
	my $d = "$SESSIONDIR/sess_$session";

	my $t = time;
	foreach my $name ( sort keys %$hilighted_perfnames ){
		my $graphs = $$perf2graphs_cache{$name};

		unless( $name =~ m"^(\w+):([^:]+):([^:]+):(.*)$" ){
			die "$name: stopped";
		}
		my ($measure, $host, $service, $perfname) = ($1, $2, $3, $4);
		my $host_encoded    = path_encode $host;
		my $service_encoded = path_encode $service;
		foreach my $graph ( @$graphs ){
			my $id  = $$graph{id}  or next;
			my $url = $$graph{url} or next;
			debuglog "    panel_id:%d", $id;
			debuglog "    performance name in NG: %s.", $name;
			my $png = download_panel_png_from_grafana $url;
			my $f = "$host_encoded,$service_encoded,$id.png";
			write_plain "$d/$f", $png;
		}
	}
}

sub generate_graphinfos_for_session ($$$) {
	my ($session, $perf2graphs_cache, $hilighted_perfs) = @_;

	my $t = time;
	my @r;
	foreach my $name ( sort keys %$hilighted_perfs ){
		my $perf   = $$hilighted_perfs{$name};
		my $graphs = $$perf2graphs_cache{$name};

		unless( $name =~ m"^(\w+):([^:]+):([^:]+):(.*)$" ){
			die "$name: stopped";
		}
		my ($measure, $host, $service, $perfname) = ($1, $2, $3, $4);
		my $host_encoded    = path_encode $host;
		my $service_encoded = path_encode $service;
		foreach my $graph ( @$graphs ){
			my $id  = $$graph{id}  or next;
			my $url = $$graph{url} or next;
			push @r, {
				session => $session,
				url => $url,
				filename => "$host_encoded,$service_encoded,$id.png",
			};
			debuglog "    panel_id:%d", $id;
			debuglog "    performance name in NG: %s.", $name;
		}
	}
	return @r;
}

#
# Data Structure:
#
#     Service Group State
#         Service Group Name
#         Session
#         All Service States
#         All Perf States
#         NG Service Names
#         NG Performance Names
#         History
#         Highlighted
#         		* History and Highlighted are forgotten if
#         		NG service/perf doesn't exist within same length of
#         		time as the session was closed.
#
#
#

#### Main Entry Point
start_criticalsection or exit 1;

my $socket = "/var/cache/naemon/live";
my (
	$e,
	$sgname2servicenames, $servicename2perfnames,
	$servicedetails, $perfdetails
) = req $socket;

if( $e ){
	end_criticalsection;
	die "error:$e, stopped";
}

#### 1.
my $last_servicedetails = load_servicedetails;
my $last_perfdetails    = load_perfdetails;
my ($servicedetail_ng, $servicedetail_changes, $servicedetail_events) =
	cmp_servicestates $last_servicedetails, $servicedetails;
my ($perfdetail_ng, $perfdetail_changes, $perfdetail_events) =
	cmp_perfstates $last_perfdetails, $perfdetails;
if( @$servicedetail_changes || @$servicedetail_events ){
	store_servicedetails $servicedetails;
}
if( @$perfdetail_changes || @$perfdetail_events ){
	store_perfdetails $perfdetails;
}

#
my $trashbox = load_trashbox;
my $trashbox_has_been_updated;
my $perf2graphs_cache = {};

my $now = time;
my @page_update_plan;

#
my $confrules = load_confrules;

foreach my $sg ( sort keys %$sgname2servicenames ){
	my $sgstate      = create_sgstate $sg;
	my $last_sgstate = load_sgstate $sg;
	my $sgstate_has_been_updated;

	my ($param, $emails, $slackurls) = apply_confrules $confrules, $sg;

	#### 2. get last service states

	my $last_servicestates = get_servicestates_from_sgstate $last_sgstate;
	my $last_perfstates    = get_perfstates_from_sgstate    $last_sgstate;
	my ($last_sessioncreatetime, $last_sessionupdatetime) =
		get_sessiontime_from_sgstate $last_sgstate;
	my ($last_num_of_service_ng, $last_num_of_perf_ng, $last_ngchangetime) =
		get_num_of_ng_from_sgstate $last_sgstate;
	my $last_num_of_ng = $last_num_of_service_ng + $last_num_of_perf_ng;

	my $last_servicestate_history = get_servicestate_history $last_sgstate;
	my $last_perfstate_history    = get_perfstate_history    $last_sgstate;
	my $last_highlighted_servicenames = get_highlighted_servicenames
		$last_sgstate;
	my $last_highlighted_perfnames    = get_highlighted_perfnames
		$last_sgstate;

	my ($last_session, $last_sessionstarttime) =
		get_session_from_sgstate $last_sgstate;

	#### 3. get current service states

	my $servicenames = $$sgname2servicenames{$sg};
	my $servicestates = get_servicestates
		$servicedetails, $servicenames;
	my $perfstates = get_perfstates
		$perfdetails, $servicenames, $servicename2perfnames;

	set_servicestates_into_sgstate $sgstate, $servicestates;
	set_perfstates_into_sgstate    $sgstate, $perfstates;

	#### 4. calculate changes of service states

	my ($num_of_service_ng, $servicestate_changes, $servicestate_events) =
		cmp_servicestates $last_servicestates, $servicestates;
	my ($num_of_perf_ng, $perfstate_changes, $perfstate_events) =
		cmp_perfstates $last_perfstates, $perfstates;

	my $ngchangetime = $last_ngchangetime;

	if(
		@$servicestate_changes				||
		@$perfstate_changes 				||
		$num_of_service_ng != $last_num_of_service_ng	||
		$num_of_perf_ng    != $last_num_of_perf_ng
	){
		$sgstate_has_been_updated = 1;
		$ngchangetime = time;
debuglog "DEBUG: STORE_SGSTATE $sg: num of ng changed: $last_num_of_service_ng->$num_of_service_ng,  $last_num_of_perf_ng->$num_of_perf_ng\n";
	}
	set_num_of_ng_into_sgstate $sgstate,
		 $num_of_service_ng, $num_of_perf_ng, $ngchangetime;
	my $num_of_ng = $num_of_service_ng + $num_of_perf_ng;

	#### 5. calculate histories and highlited

	my $servicestate_history = $last_servicestate_history;
	my $highlighted_servicenames = $last_highlighted_servicenames;
	if( @$servicestate_changes ){
		$servicestate_history = merge_history
			$last_servicestate_history, $servicestate_changes;
		$highlighted_servicenames = merge_highlighted
	       		$last_highlighted_servicenames, $servicestate_changes;
	}
	verify_highlighted $highlighted_servicenames, $servicestates;
	set_servicestate_history     $sgstate, $servicestate_history;
	set_highlighted_servicenames $sgstate, $highlighted_servicenames;

	my $perfstate_history = $last_perfstate_history;
	my $highlighted_perfnames = $last_highlighted_perfnames;
	if( @$perfstate_changes ){
		$perfstate_history = merge_history
			$last_perfstate_history, $perfstate_changes;
		$highlighted_perfnames = merge_highlighted
			$last_highlighted_perfnames, $perfstate_changes;
	}
	verify_highlighted $highlighted_perfnames, $perfstates;
	set_perfstate_history        $sgstate, $perfstate_history;
	set_highlighted_perfnames    $sgstate, $highlighted_perfnames;

	#### 6. make plan of session
	my $update_timespan = $$param{UPDATE_TIMESPAN} // 5;
	my $resend_timespan = $$param{RESEND_TIMESPAN} // 30;
	my $close_timespan  = $$param{CLOSE_TIMESPAN}  // 30;
	my $rename_timespan = $$param{RENAME_TIMESPAN} // 720;
	my $expire_timespan = $$param{EXPIRE_TIMESPAN} // 720;

	my $session_plan;
	my $session;
	if( $last_session eq '' ){
		if    ( $num_of_service_ng >  0 ){
			$session_plan = 'OPEN';
			$session = create_session;

		}elsif(	$num_of_perf_ng == 0 && (
				@$servicestate_history      > 0	||
				@$perfstate_history         > 0
			) &&
			$now - $last_ngchangetime > $close_timespan*60
		){
			$session_plan = 'FORGET';
		}else{
		}

	}elsif( $last_num_of_service_ng == 0 && $num_of_service_ng == 0 &&
		$now - $last_ngchangetime > $close_timespan*60 ){
		$session_plan = 'CLOSE';
		$session = $last_session;

	}elsif( $now - $last_sessionupdatetime > $update_timespan*60 ){
		$session_plan = 'UPDATE';
		$session = $last_session;

	}elsif( $now - $last_sessioncreatetime > $rename_timespan*60 ){
		$session_plan = 'RENAME';
		$session = create_session;

	}else{
		$session_plan = 'KEEP';
		$session = $last_session;
	}

	#### 7. update session
debuglog "DEBUG: SERVICEGROUP %s: target:%s id:%s->%s",
$sg, $session_plan, $last_session, $session
if $last_session ne '' || $session ne '';
	my $highlighted_services = get_highlighted
		$highlighted_servicenames, $servicestates;
	my $highlighted_perfs    = get_highlighted
		$highlighted_perfnames,    $perfstates;
	my $sessioncreatetime;
	my $sessionupdatetime;

	if    ( $session_plan eq 'OPEN' ){
		mkdir_for_session $session;
		set_session_into_sgstate $sgstate, $session;
		$sessioncreatetime = $now;
		$sessionupdatetime = $now;
		push @page_update_plan, [
			$sg, $session,
			$highlighted_services, $highlighted_perfs
		];
		$sgstate_has_been_updated = 1;

	}elsif( $session_plan eq 'CLOSE' ){
		set_session_into_sgstate $sgstate, undef;
		$sessioncreatetime = undef;
		$sessionupdatetime = undef;
		move_session_into_trashbox $trashbox,
			$last_session, undef, $expire_timespan;
		push @page_update_plan, [
			$sg, $session,
			$highlighted_services, $highlighted_perfs
		];
		$sgstate_has_been_updated = 1;
		$trashbox_has_been_updated = 1;

	}elsif( $session_plan eq 'UPDATE' ){
		mkdir_for_session $session;
		set_session_into_sgstate $sgstate, $session;
		$sessioncreatetime = $last_sessioncreatetime;
		$sessionupdatetime = $now;
		push @page_update_plan, [
			$sg, $session,
			$highlighted_services, $highlighted_perfs
		];
		$sgstate_has_been_updated = 1;

	}elsif( $session_plan eq 'RENAME' ){
		mkdir_for_session $session;
		set_session_into_sgstate $sgstate, $session;
		$sessioncreatetime = $now;
		$sessionupdatetime = $now;
		move_session_into_trashbox $trashbox,
			$last_session, $session, $expire_timespan;
		push @page_update_plan, [
			$sg, $session,
			$highlighted_services, $highlighted_perfs
		];
		$sgstate_has_been_updated = 1;
		$trashbox_has_been_updated = 1;

	}elsif( $session_plan eq 'KEEP' ){
		set_session_into_sgstate $sgstate, $session;
		$sessioncreatetime = $last_sessioncreatetime;
		$sessionupdatetime = $last_sessionupdatetime;

	}elsif( $session_plan eq 'FORGET' ){
		$sessioncreatetime = undef;
		$sessionupdatetime = undef;
		set_highlighted_servicenames $sgstate, {};
		set_highlighted_perfnames    $sgstate, {};
		set_servicestate_history     $sgstate, [];
		set_perfstate_history        $sgstate, [];
		$sgstate_has_been_updated = 1;
	}

	set_sessiontime_into_sgstate $sgstate,
       		$sessioncreatetime, $sessionupdatetime;

	# store servicegroup state
	if( $sgstate_has_been_updated ){
		store_sgstate $sg, $sgstate;
	}

	#### 8. reporting plan

	# 8-a. reporting by mail
	my $reporting_plan = create_reporting_plan_by_mail
		$param, $sg, $session, $session_plan,
		$servicestate_history, $perfstate_history;
	if( defined $reporting_plan ){
		execute_reporting_plan_by_mail
			$param, $sg, $session, $reporting_plan,
			$servicestate_history, $perfstate_history,
			$highlighted_services, $highlighted_perfs,
			$emails;
	}

	# 8-b. reporting by slack
	my $reporting_plan = create_reporting_plan_by_slack
		$param, $sg, $session, $session_plan;
	if( defined $reporting_plan ){
		execute_reporting_plan_by_slack
			$param, $sg, $session, $reporting_plan,
			$slackurls;
	}

}

#### 9. trashbox

my $expired = get_expired_from_trashbox $trashbox;
if( $expired ){
	$trashbox_has_been_updated = 1;
	foreach my $session ( @$expired ){
		remove_session_from_trashbox $trashbox, $session;
	}
}
if( $trashbox_has_been_updated ){
	store_trashbox $trashbox;
}

end_criticalsection;

#### 10. update page resource (download graphs)

foreach my $e ( @page_update_plan ){
	my ($sg, $session, $highlighted_services, $highlighted_perfs) = @$e;
	start_criticalsection_for_session $session or next;
	update_perf2graphs_cache $perf2graphs_cache, $highlighted_perfs;
	generate_graphs_for_session $session,
		$perf2graphs_cache, $highlighted_perfs;
	generate_html_for_session $sg, $session,
		$highlighted_services, $highlighted_perfs,
		$perf2graphs_cache, $now;
	end_criticalsection_for_session $session;
}

exit 0;



