#!/usr/bin/perl

use Cwd 'abs_path';
our $TOOLHOME;
BEGIN {
	$0 =~ m"^(.*)/";
	$TOOLHOME = abs_path "$1/..";
	while( $TOOLHOME =~ s{(^|/)[^\.][^/]*/\.\.(/|$)}{$1} ){}
	$TOOLHOME =~ s{/$}{};
}
use lib "$TOOLHOME/lib/perl5";

use strict;
use Getopt::Long;
use URI::Escape;
use Socket;
use Template;

our $TMPDIR = "/tmp";
our $WORKDIR = "$TMPDIR/ncrt_work.$$";

our $PLUGINSDIR = "$TOOLHOME/plugins";
our $CONFDIR = "$TOOLHOME/conf";
our $PLAYBOOKSDIR = "$TOOLHOME/playbooks";
our $SRCDIR = "$TOOLHOME/src";
our $AGENTCONFDIR = "$TOOLHOME/ncrtagent/conf";
our $MASTERCONFDIR = "$TOOLHOME/ncrtmaster/conf";
 
my $workdir;
my $master_only;
my $agent_only;
my $target_agent = qr"^.*$";
my $target_master = qr"^.*$";
my $threshold_only;
my $dryrun;
my $quick;
my $no_cleanup;
GetOptions (
	'workdir=s' => \$workdir,
	'master-only' => \$master_only,
	'agent-only' => \$agent_only,
	'target-agent=s' => sub { my $re = $_[1]; $target_agent = qr"^$re$"; },
	'target-master=s' => sub { my $re = $_[1]; $target_master = qr"^$re$"; },
	'threshold-only' => \$threshold_only,
	'no-cleanup' => \$no_cleanup,
	'dryrun' => \$dryrun,
	'quick' => \$quick,
) or die "Invalid command line options, stopped";


my %plan = (
	'Step0'  => 1, # Step0.  read ncrtbuilder conf (*)
	'Step1'  => 1, # Step1.  generate packages and certs
	'Step2'  => 1, # Step2.  create work dir structure
	'Step3'  => 1, # Step3.  run agenttype plugins
	'Step4'  => 1, # Step4.  run measure plugins
	'Step5'  => 1, # Step5.  run contact plugins
	'Step6'  => 1, # Step6.  run mastertype plugins
	'Step7'  => 1, # Step7.  read confs generated by plugins (*)
	'Step8'  => 1, # Step8.  generate plugin settings of agent measurement
	'Step9'  => 1, # Step9.  generate plugin settings of agentless measurement
	'Step10' => 1, # Step10. generate plugin settings of indirect measurement
	'Step11' => 1, # Step11. generate plugin settings of agenttype
	'Step12' => 1, # Step12. generate plugin settings of mastertype
	'Step13' => 1, # Step13. generate metricfilter / thresholdfilter settings
	'Step14' => 1, # Step14. generate thresholds settings
	'Step15' => 1, # Step15. generate setting of ncrtagent daemons
	'Step16' => 1, # Step16. generate naemon config files for agents
	'Step17' => 1, # Step17. generate settings of masters
	'Step18' => 1, # Step18. generate hosts.yml / vars.yml
	'Step19' => 1, # Step19. deploy ncrtmasters
	'Step20' => 1, # Step20. deploy ncrtagents
	'Step21' => 1, # Step21. clean up work dir
);

if( $dryrun ){ $plan{Step20} = 0; $plan{Step19} = 0; }
if( $master_only ){ $plan{Step20} = 0; }
if( $agent_only ) { $plan{Step19} = 0; }
if( $workdir ){ $WORKDIR = $workdir; }
if( $no_cleanup ){ $plan{Step21} = 0; }

####
sub rm_r ($) {
	my ($r) = @_;
	return unless -d $r;
	opendir my $d, $r or do {
		die "$r: cannot open, stopped";
	};
	my @e = readdir $d;
	foreach my $e ( @e ){
		next if $e eq '..' || $e eq '.';
		if( -d "$r/$e" ){
			rm_r( "$r/$e" );
		}else{
			unlink "$r/$e" or die "$r/$e, stopped";
		}
	}
	closedir $d;
	rmdir $r or die "$r: cannot remove, stopped";
}

sub mkdir_or_die ($) {
	my ($d) = @_;
	return if -d $d;
	mkdir $d or die "$d: cannot create, stopped";
}

sub create_or_die ($) {
	my ($f) = @_;
	open my $h, '>', $f or die "$f: cannot create, stopped";
	close $h;
}

sub system_or_die ($) {
	my ($cmd) = @_;
	my $r = system $cmd;
	if   ($? == -1){
		die sprintf "%s: failed to execute: %d, stopped",
			$cmd, $!;
	}elsif($? & 127){
		die sprintf
			"%s: child died with signal %d, %s coredump, stopped",
			$cmd, ($? & 127), ($? & 128) ? 'with' : 'without';
	}elsif( ($?>>8) != 0){
		 die sprintf "%s: child exited with value %d, stopped",
			$cmd, $? >> 8;
	}
}

sub _parse_option ($) {
	( $_ ) = @_;
	my %opt;
	my %templateopt;
	while( m{\G
		($|\s+
			(\@)?(\w+)=
			(?:
				"([^\\"]*(?:(?:\\\\|\\")+[^\\"]*)*)"|
				([\w\!\#-\&\(-\/\:-\@\[-\_\{-\~]+)
			)
		)
	}gx ){
		return \%opt, \%templateopt if $1 eq '';

		my $template = $2;
		my $key = $3;
		my $value = $4 ne '' ? $4 : $5;

		if( $template ){ $templateopt{$key} = $value; }
		else           { $opt{$key} = $value; }
	}
	return undef;
}

sub parse_itementry ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef if m"^\s*(#|$)";
	return undef, "illegal format" unless m"^(\w+)"g;
	my $item = $1;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $item, $opt, $topt;
}

sub parse_addressentry ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef if m"^\s*(#|$)";
	return undef, "illegal format" unless m"^(\S+\@[-.a-zA-Z0-9]+)"g;
	my $item = $1;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $item, $opt, $topt;
}

sub parse_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, "illegal format" unless m"^(\S+)\s+([\w,]+)"g;
	my $from = $1;
	my $to = $2;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $from, $to, $opt, $topt;
}

sub parse_3items_with_option_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, "illegal format" unless m"^(\S+)\s+(\S+)\s+(\S+)";
	my $first  = $1;
	my $second = $2;
	my $third  = $3;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $first, $second, $third, $opt, $topt;
}

sub parse_host2item_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, "illegal format" unless m"^(\S+)\s+(\S+)$";
	return $1, $2, undef;
}

sub parse_host2service2item_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, undef, "illegal format" unless m"^(\S+)\s+([\w,]+)\s+(\S+)$";
	return $1, $2, $3, undef;
}

sub expand_importspec (@){
	my @importmacros;
	foreach my $i ( @_ ){
		my ($host, $service, $prefix) = @$i;

		# TODO: check host / service

		push @importmacros,
			"$host:$service:$prefix \$SERVICEPERFDATA:$host:$service\$";
	}
	my $importmacro = join " ", @importmacros;
	return $importmacro;
}

sub expand_params ($\%) {
	my ($text, $params) = @_;
	$text =~ s{ <(\w+)> }{ $params->{$1}; }egx;
	return $text;
}

######## Step0. ########

exit 0 unless $plan{Step0};

#### load template conf.
my %ncrtconf;
my $f = "$CONFDIR/ncrtbuild.conf";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	next if m"^\s*(#|$)";
	m"^(\w+)=(.*)$" or die "$f:$.: illegal format, stopped";
	$ncrtconf{$1} = $2;
}
close $h;

our $ANSIBLEOPTIONS      = $ncrtconf{'ANSIBLEOPTIONS'};

our $NCRTAGENTHOME       = $ncrtconf{'NCRTAGENTHOME'};

our $NCRTMASTERHOME      = $ncrtconf{'NCRTMASTERHOME'};

our $HELPERURL                   = $ncrtconf{'HELPERURL'} //
	'http://example.com/grafana-dashboard-helper';
our $HELPERURL_JUMP_TO_DASHBOARD = $ncrtconf{'HELPERURL_JUMP_TO_DASHBOARD'} //
	'http://example.com/grafana-dashboard-helper/jump_to_dashboard.html?dashboard=<hostname>,<servicedesc>';
our $HELPERURL_SEARCH_PANELS     = $ncrtconf{'HELPERURL_SEARCH_PANELS'} //
	'http://example.com/grafana-dashboard-helper/search_panels.json?retention_policy=one_year&measurement=<hostname>,<servicedesc>&field_key=<performancename>';

sub get_naemon2influx_deb ($) {
	my ($d) = @_;
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	while( my $e = readdir $h ){
		next unless $e =~ m"^naemon2influx-\d.*\.deb$";
		return $e;
	}
	closedir $h;
	return undef;
}

sub get_grafana_dashboard_helper_deb ($) {
	my ($d) = @_;
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	while( my $e = readdir $h ){
		next unless $e =~ m"^grafana-dashboard-helper_.*\.deb$";
		return $e;
	}
	closedir $h;
	return undef;
}

our $NAEMON2INFLUX_DEB            = get_naemon2influx_deb $CONFDIR;
our $GRAFANA_DASHBOARD_HELPER_DEB = get_grafana_dashboard_helper_deb $CONFDIR;

#### find all build plugins
my @agenttype_plugins;
my @agenttypes;
my @mastertype_plugins;
my @mastertypes;
my @agent_plugins;
my @agentless_plugins;
my @indirect_plugins;
my @contact_plugins;
my @reporter_plugins;
opendir my $d, $PLUGINSDIR or do {
	die "$PLUGINSDIR: cannot open, stopped";
};
while( my $e = readdir $d ){
	next unless $e =~ m"^ncrtbuild_(?:(agent)|(agentless)|(indirect)|(agenttype)|(mastertype)|(contact)|(reporter))_([-\w]+)$";
	push @agent_plugins,      $e if $1;
	push @agentless_plugins,  $e if $2;
	push @indirect_plugins,   $e if $3;
	push @agenttype_plugins,  $e if $4;
	push @agenttypes, $8         if $4;
	push @mastertype_plugins, $e if $5;
	push @mastertypes, $8        if $5;
	push @contact_plugins,    $e if $6;
	push @reporter_plugins,   $e if $7;
}
closedir $d;

######## Step1. ########

if( $plan{Step1} ){

	#### build naemon2influx package
	if( not defined $NAEMON2INFLUX_DEB ){
		unless( -d "$SRCDIR/naemon2influx" ){
			system_or_die "git clone --depth=1 https://github.com/frisky-gh/naemon2influx.git $SRCDIR/naemon2influx";
		}
		system_or_die "make deb -C $SRCDIR/naemon2influx";
		$NAEMON2INFLUX_DEB = get_naemon2influx_deb "$SRCDIR/naemon2influx";
		defined $NAEMON2INFLUX_DEB or
			die "naemon2influx: cannot build package, stopped";
		system_or_die "cp $SRCDIR/naemon2influx/$NAEMON2INFLUX_DEB $CONFDIR/$NAEMON2INFLUX_DEB";
	}

	#### build grafana-dashboard-helper package
	if( not defined $GRAFANA_DASHBOARD_HELPER_DEB ){
		unless( -d "$SRCDIR/grafana-dashboard-helper" ){
			system_or_die "git clone --depth=1 https://github.com/frisky-gh/grafana-dashboard-helper.git $SRCDIR/grafana-dashboard-helper";
		}
		system_or_die "cd $SRCDIR/grafana-dashboard-helper && dpkg-buildpackage -us -uc";
		$GRAFANA_DASHBOARD_HELPER_DEB = get_grafana_dashboard_helper_deb $SRCDIR;
		defined $GRAFANA_DASHBOARD_HELPER_DEB or
			die "grafana-dashboard-helper: cannot build package, stopped";
		system_or_die "cp $SRCDIR/$GRAFANA_DASHBOARD_HELPER_DEB $CONFDIR/$GRAFANA_DASHBOARD_HELPER_DEB";
	}

	#### create server cert. if not exists
	if( ! -f "$CONFDIR/ncrt_key.pem" ){
		system_or_die "openssl req -verbose -subj '/C=JP/ST=Kanagawa-ken/O=Watao Family/CN=*' -x509 -newkey rsa:2048 -nodes -keyout $CONFDIR/ncrt_key.pem -out $CONFDIR/ncrt_cert.pem -days 36525";
	}
}

######## Step2. ########

if( $plan{Step2} ){

	#### initialize fixed work dirs and files
	rm_r $WORKDIR if -d $WORKDIR;
	mkdir_or_die $WORKDIR;
	mkdir_or_die "$WORKDIR/ncrtagent";
	mkdir_or_die "$WORKDIR/ncrtmaster";

	# agenttype list
	create_or_die "$WORKDIR/agenttypes";

	# mastertype list
	create_or_die "$WORKDIR/mastertypes";

	# measure list
	create_or_die "$WORKDIR/measures";

	# hostname -> agenttype mappings
	create_or_die "$WORKDIR/agenthosts";

	# hostname -> mastertype mappings
	create_or_die "$WORKDIR/masterhosts";

	# agenttype -> configuration file multi-mappings
	create_or_die "$WORKDIR/agenttype2conf";

	# mastertype -> configuration file multi-mappings
	create_or_die "$WORKDIR/mastertype2conf";

	# measure -> configuration file multi-mappings
	create_or_die "$WORKDIR/measure2conf";

	# hostname -> service multi-mapping
	create_or_die "$WORKDIR/host2service2measure";

	# hostname -> contact multi-mapping
	create_or_die "$WORKDIR/host2contact";

	# hostname -> service -> contact multi-mapping
	create_or_die "$WORKDIR/host2service2contact";

	# hostname -> groupname multi-mapping
	create_or_die "$WORKDIR/host2group";

	# hostname -> service -> groupname multi-mapping
	create_or_die "$WORKDIR/host2service2group";

	# username list
	create_or_die "$WORKDIR/users";

	# email address list
	create_or_die "$WORKDIR/addresses";

	#### write templates
	my %param = (
		hostname    => '$_HOSTURLENCODED$',
		servicedesc => '$_SERVICEURLENCODED$',
	);
	my $action_url = expand_params $HELPERURL_JUMP_TO_DASHBOARD, %param;
	my $f = "$WORKDIR/ncrt_hosttemplates.cfg";
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	print $h <<"EOF";
# host settings for Nagios / Naemon

define host {
	name				ncrt-generic-host
	
	check_command			ncrtmaster_do_nothing
	check_interval			4
	retry_interval			1
	max_check_attempts		3
	check_period			24x7

	notifications_enabled		1
	notification_interval		60
	notification_options		d,u,r
	notification_period		24x7
	contact_groups			

	process_perf_data		1
	event_handler_enabled		1	; Host event handler is enabled
	flap_detection_enabled		1	; Flap detection is enabled
	retain_nonstatus_information	1       ; Retain non-status information across program restarts
	retain_status_information	1       ; Retain status information across program restarts

	register			0	; DONT REGISTER THIS DEFINITION - ITS NOT A REAL HOST, JUST A TEMPLATE!

}

EOF
	close $h;
	my $f = "$WORKDIR/ncrt_servicetemplates.cfg";
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	print $h <<"EOF";
# service settings for Nagios / Naemon

define service {
	name				ncrt-generic-service

	active_checks_enabled		1
	passive_checks_enabled		1
	check_freshness			0       ; Default is to NOT check service 'freshness'
	check_interval			4
	retry_interval			1
	max_check_attempts		3
	check_period			24x7

	notifications_enabled		1
	notification_interval		60
	notification_options		w,u,c,r
	notification_period		24x7
	contact_groups			

	is_volatile			0       ; The service is not volatile
	obsess_over_service		1       ; We should obsess over this service (if necessary)
	process_perf_data		1
	event_handler_enabled		1       ; Service event handler is enabled
	flap_detection_enabled		1       ; Flap detection is enabled
	retain_nonstatus_information	1       ; Retain non-status information across program restarts
	retain_status_information	1       ; Retain status information across program restarts

	action_url			$action_url

	register			0	; DONT REGISTER THIS DEFINITION - ITS NOT A REAL SERVICE, JUST A TEMPLATE!
}

EOF
	close $h;

}

######## Step3. ########

if( $plan{Step3} ){
	#### run agenttype plugins
	foreach my $e ( sort @agenttype_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		system_or_die "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
	}
}

######## Step4. ########

if( $plan{Step4} ){
	#### run measurement plugins
	foreach my $e ( sort @agent_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		system_or_die "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
	}
	foreach my $e ( sort @agentless_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		system_or_die "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
	}
	foreach my $e ( sort @indirect_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		system_or_die "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
	}
}

######## Step5. ########

if( $plan{Step5} ){
	foreach my $e ( sort @contact_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		system_or_die "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
	}
	foreach my $e ( sort @reporter_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		system_or_die "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
	}
}

######## Step6. ########

if( $plan{Step6} ){
	#### run mastertype plugins
	foreach my $e ( sort @mastertype_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		system_or_die "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
	}
}

######## Step7. ########

#### read agent type related work files
my %host2agenttype;
my %agenttype2hosts;
my $agenttype_has_collision;
my @ncrtagents;
do {
	my $f = "$WORKDIR/agenthosts";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		my ($host, $agenttype) = split m"\s+";
		if( not defined $host2agenttype{$host} ){
			$host2agenttype{$host} = $agenttype;
			push @{$agenttype2hosts{$agenttype}}, $host;
		}elsif( $host2agenttype{$host} ne $agenttype ){
			print "ERROR: host $host has multiple agenttypes.\n";
			$agenttype_has_collision = 1;
		}
	}
	close $h;
	while( my ($h, $t) = each %host2agenttype ){
		push @ncrtagents, $h;
	}
};

die "Some agenttype have collisions, stopped" if $agenttype_has_collision;

my %agenttype2opts         = ( 'virtual' => {
	'display_name' => 'Virtual:<hostname>',
	'address' => '127.0.0.1',
	'check_command' => 'ncrtmaster_do_nothing',
} );
my %agenttype2templateopts = ( 'virtual' => {
} );
do {
	my $f = "$WORKDIR/agenttypes";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		my ($agenttype, $opts, $templateopts) = parse_itementry $_;
		print "$f:$.:$opts\n" if !defined $agenttype && defined $opts;
		next unless $agenttype;
		$agenttype2opts{$agenttype} = $opts;
		$agenttype2templateopts{$agenttype} = $templateopts;
	}
	close $h;
};

#### read master type related work files
my %host2mastertype;
my %mastertype2hosts;
my $mastertype_has_collision;
my @ncrtmasters;
my @ncrtmasteraddrs;
do {
	my $f = "$WORKDIR/masterhosts";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		my ($host, $mastertype) = split m"\s+";
		if( not defined $host2mastertype{$host} ){
			$host2mastertype{$host} = $mastertype;
			push @{$mastertype2hosts{$mastertype}}, $host;
		}elsif( $host2mastertype{$host} ne $mastertype ){
			print "ERROR: host $host has multiple mastertypes.\n";
			$mastertype_has_collision = 1;
		}
	}
	close $h;

	while( my ($h, $t) = each %host2mastertype ){
		push @ncrtmasters, $h;
		my ( $name, $aliases, $addrtype, $length, @addrs ) = gethostbyname $_;
		foreach my $addr ( @addrs ){
			my $a = inet_ntoa $addr;
			push @ncrtmasteraddrs, $a;
		}
	}
};

die "Some agenttype have collisions, stopped" if $agenttype_has_collision;

my %mastertype2opts         = ();
my %mastertype2templateopts = ();
do {
	my $f = "$WORKDIR/mastertypes";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		my ($mastertype, $opts, $templateopts) = parse_itementry $_;
		print "$f:$.:$opts\n" if !defined $mastertype && defined $opts;
		next unless $mastertype;
		$mastertype2opts{$mastertype} = $opts;
		$mastertype2templateopts{$mastertype} = $templateopts;
	}
	close $h;
};

#### read measurement / service / host related work files
my %measure2measuretype;
my %measure2opts;
my %measure2templateopts;
my $f = "$WORKDIR/measures";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($measure, $measuretype, $opts, $templateopts) = parse_mapping $_;
	print "$f:$.:$opts\n" if !defined $measure && defined $opts;
	next unless $measure;
	$measure2measuretype{$measure} = $measuretype;
	$measure2opts{$measure} = $opts;
	$measure2templateopts{$measure} = $templateopts;
}
close $h;

my %host2service2measure;
my @host_service_measure_opts;
my $f = "$WORKDIR/host2service2measure";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $service, $measure, $opts) = parse_3items_with_option_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	$host2service2measure{$host}->{$service} = $measure;
	push @host_service_measure_opts, [$host, $service, $measure, $opts];
}
close $h;

my %host2contact;
my $f = "$WORKDIR/host2contact";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $contact, $opts) = parse_host2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$host2contact{$host}}, $contact;
}
close $h;

my %host2service2contact;
my $f = "$WORKDIR/host2service2contact";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $service, $contact, $opts) = parse_host2service2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$host2service2contact{$host}->{$service}}, $contact;
}
close $h;

my %group2host;
my $f = "$WORKDIR/host2group";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $group, $opts) = parse_host2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$group2host{$group}}, $host;
}
close $h;

my %group2host2service;
my $f = "$WORKDIR/host2service2group";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $service, $group, $opts) = parse_host2service2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	$group2host2service{$group}->{$host}->{$service} = 1;
}
close $h;

my %users = ( nobody => "" );
my $f = "$WORKDIR/users";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($user, $opts) = parse_itementry $_;
	print "$f:$.:$opts\n" if !defined $user && defined $opts;
	next unless $user;
	$users{$user} = $opts;
}
close $h;

my %addresses;
my $f = "$WORKDIR/addresses";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($address, $opts) = parse_addressentry $_;
	print "$f:$.:$opts\n" if !defined $address && defined $opts;
	next unless $address;
	$addresses{$address} = $opts;
}
close $h;

####
my %agenttype2conf;
do {
	my $f = "$WORKDIR/agenttype2conf";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		my ($agenttype, $conf) = split m"\s+";
		push @{$agenttype2conf{$agenttype}}, $conf;
	}
	close $h;
};

my %mastertype2conf;
do {
	my $f = "$WORKDIR/mastertype2conf";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		my ($mastertype, $conf) = split m"\s+";
		push @{$mastertype2conf{$mastertype}}, $conf;
	}
	close $h;
};

my %measure2conf;
do {
	my $f = "$WORKDIR/measure2conf";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		my ($measure, $conf) = split m"\s+";
		push @{$measure2conf{$measure}}, $conf;
	}
	close $h;
};

#### read rules for option parameters of naemon setting
sub read_rules4option () {
	##
	my $d = "$CONFDIR/option";
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	my @files = sort readdir $h;
	closedir $h;

	my @rules;
	foreach my $e ( @files ){
		next unless $e =~ m"^\w.*\.optionrules$";
		my $f = "$d/$e";
		open my $h, "<", $f or do {
			die "$f: cannot open, stopped";
		};
		my $vhost_re;
		my $vservice_re;
		while( <$h> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhost_re = qr"^$1$";
				$vservice_re = qr"^$2$";
			}elsif( m"^option\s+(\S+(\s+\S+)*)" ){
				my $options = $1;
				my %options;
				foreach my $option ( split m"\s+", $1 ){
					die unless $option =~ m"^(\w+)=(.*)$";
					$options{$1} = $2;
				}
				push @rules, [$vhost_re, $vservice_re, %options];
			}else{
				die "$f:$.: illegal format, stopped";
			}
		}
		close $h;
	}
	return \@rules;
}
my $rules4option = read_rules4option;

######## Step8. ########

#### generate confs for which service type is agent
sub generate_agentconf_for_agent ($$$) {
	my ($conf, $measure, $host2agenttype) = @_;
	my @rules;
	my $f = "$CONFDIR/$conf";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		next if m"^\s*(#|$)";
		m"^(\S+)\s+(.*)" or
			die "$f:$.: illegal format, stopped";
		push @rules, [qr"^$1$", $2];
	}
	close $h;

	while( my ($host, $agenttype) = each %$host2agenttype ){
		my $f = "$WORKDIR/ncrtagent/$host/$conf.$measure.$host";
		open my $h, '>', $f or do {
			die "$f: cannot open, stopped";
		};
		foreach my $rule ( @rules ){
			next unless $host =~ $rule->[0];
			print $h $rule->[1], "\n";
		}
		close $h;
		system_or_die "cp $f $WORKDIR/ncrtagent/$host/$conf";
	}
}

if( $plan{Step8} ){
	foreach my $h ( @ncrtagents ){
		mkdir_or_die "$WORKDIR/ncrtagent/$h";
		mkdir_or_die "$WORKDIR/ncrtagent/$h/agent";
		mkdir_or_die "$WORKDIR/ncrtagent/$h/indirect";
		mkdir_or_die "$WORKDIR/ncrtagent/$h/threshold";
		mkdir_or_die "$WORKDIR/ncrtagent/$h/metricfilter";
		mkdir_or_die "$WORKDIR/ncrtagent/$h/thresholdfilter";
		mkdir_or_die "$WORKDIR/ncrtagent/$h/agenttype";
		system_or_die "rsync -aSvx $AGENTCONFDIR/ $WORKDIR/ncrtagent/$h/";
	}

	while( my ($measure, $measuretype) = each %measure2measuretype ){
		next unless $measuretype eq 'agent';
		my @confs = @{$measure2conf{$measure} // []};

		foreach my $conf ( @confs ){
			generate_agentconf_for_agent $conf, $measure, \%host2agenttype;
		}
	}
}

######## Step9. ########

#### generate confs for which service type is agentless
sub generate_masterconf_for_agentless ($$@) {
	my ($measure, $conf, @ncrtmasters) = @_;
	my %vhost2rules;
	my $vhost;
	my $f = "$CONFDIR/$conf";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		next if m"^\s*(#|$)";
		if( m"^===\s+(\S+)\s+===$" ){
			$vhost = $1;
		}elsif( m"^(\S+)" ){
			push @{$vhost2rules{$vhost}}, $_;
		}else{
			die "$f:$.: illegal format, stopped";
		}
	}
	close $h;

	foreach my $master ( @ncrtmasters ){
		while( my ($vhost, $rules) = each %vhost2rules ){
			my $f = "$WORKDIR/ncrtmaster/$master/$conf.$measure.$vhost";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @$rules ){
				print $h $rule, "\n";
			}
			close $h;
		}
	}
}

if( $plan{Step9} ){
	foreach my $h ( @ncrtmasters ){
		mkdir_or_die "$WORKDIR/ncrtmaster/$h";
		mkdir_or_die "$WORKDIR/ncrtmaster/$h/agentless";
		mkdir_or_die "$WORKDIR/ncrtmaster/$h/indirect";
		mkdir_or_die "$WORKDIR/ncrtmaster/$h/reporter";
		mkdir_or_die "$WORKDIR/ncrtmaster/$h/threshold";
		mkdir_or_die "$WORKDIR/ncrtmaster/$h/metricfilter";
		mkdir_or_die "$WORKDIR/ncrtmaster/$h/thresholdfilter";
		mkdir_or_die "$WORKDIR/ncrtmaster/$h/mastertype";
		system_or_die "rsync -aSvx $MASTERCONFDIR/ $WORKDIR/ncrtmaster/$h/";
	}

	while( my ($measure, $measuretype) = each %measure2measuretype ){
		next unless $measuretype eq 'agentless';
		my @confs = @{$measure2conf{$measure}};

		foreach my $conf ( @confs ){
			generate_masterconf_for_agentless $measure, $conf, @ncrtmasters;
		}
	}
}

######## Step10. ########

#### generate confs for which service type is indirect
sub diff (\%\%) {
	my ($old, $new) = @_;
	my %keys;
	my %d;
	while( my ($k) = each %$old ){ $keys{$k} = 1; }
	while( my ($k) = each %$new ){ $keys{$k} = 1; }
	while( my ($k) = each %keys ){
		my $o = $old->{$k};
		my $n = $new->{$k};
		next if $o eq $n;
		$d{$k} = $n;
	}
	return %d;
}

sub generate_agentconf_for_indirect ($$$$) {
	my ($measure, $conf, $host2agenttype, $vhostvservice2proxyhosts) = @_;
	my $vhostvservice;
	my %vhostvservice2rules;
	my %option;
	my $f = "$CONFDIR/$conf";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		next if m"^\s*(#|$)";
		if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
			$vhostvservice = "$1 $2";
			%option = ();
		}elsif( m"^(\w+)=(\S*)$" ){
			$option{$1} = $2;
		}elsif( m"^(\S+)\s+(\S.*)$" ){
			push @{$vhostvservice2rules{$vhostvservice}},
				[qr"^$1$", $2, {%option}];
		}else{
			die "$f:$.: illegal format, stopped";
		}
	}
	close $h;

	while( my ($proxyhost, $agenttype) = each %$host2agenttype ){
		foreach my $vhostvservice ( sort keys %vhostvservice2rules ){
			my ($vhost, $vservice) = split m"\s+", $vhostvservice;
			my $rules = $vhostvservice2rules{$vhostvservice};
			my %option;
			my @settings;
			foreach my $rule ( @$rules ){
				my ($proxyhost_re, $setting, $option) = @$rule;
				next unless $proxyhost =~ m"$proxyhost_re";
				my %d = diff %option, %$option;
				while( my ($k, $v) = each %d ){
					push @settings, "$k=$v";
					$option{$k} = $v;
				}
				push @settings, $setting;
			}
			next unless @settings;
			my $f = "$WORKDIR/ncrtagent/$proxyhost/$conf.$measure.$vhost.$vservice";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach( @settings ){ print $h $_, "\n"; }
			close $h;
			$$vhostvservice2proxyhosts{$vhostvservice}->{$proxyhost} = 1;
		}
	}
}

sub generate_masterconf_for_indirect ($$@) {
	my ($measure, $vhostvservice2proxyhosts, @ncrtmasters) = @_;
	foreach my $master ( @ncrtmasters ){
		foreach my $vhostvservice ( sort keys %$vhostvservice2proxyhosts ){
			my $proxyhosts = $$vhostvservice2proxyhosts{$vhostvservice};
			my ($vhost, $vservice) = split m"\s+", $vhostvservice;
			my $f = "$WORKDIR/ncrtmaster/$master/indirect/proxyhosts.$measure.$vhost.$vservice";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $proxyhost ( sort keys %$proxyhosts ){
				print $h $proxyhost, "\n";
			}
			close $h;
		}
	}
}

if( $plan{Step10} ){
	while( my ($measure, $measuretype) = each %measure2measuretype ){
		next unless $measuretype eq 'indirect';
		my @confs = @{$measure2conf{$measure}};

		my %vhostvservice2proxyhosts;
		foreach my $conf ( @confs ){
			generate_agentconf_for_indirect $measure, $conf, \%host2agenttype, \%vhostvservice2proxyhosts;
		}
		generate_masterconf_for_indirect $measure, \%vhostvservice2proxyhosts, @ncrtmasters;
	}
}

######## Step11. ########
if( $plan{Step11} ){
	# TODO
}

######## Step12. ########
if( $plan{Step12} ){
	while( my ($mastertype, $hosts) = each %mastertype2hosts ){
		my $conf = $mastertype2conf{$mastertype};
		foreach my $h ( @$hosts ){
			foreach my $i ( @$conf ){
				my $src = "$CONFDIR/mastertype/$i";
				my $dst = "$WORKDIR/ncrtmaster/$h/mastertype/$i";
				system_or_die "cp $src $dst";
			}
		}
	}
}

######## Step13. ########

#### generate metricfilter / thresholdfilter settings
sub generate_filter_settings ($\%\@) {
	my ($filtertype, $measure2measuretype, $host_service_measure_opts) = @_;

	##
	my $d = "$CONFDIR/$filtertype";
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	my @rules;
	foreach my $e ( sort readdir $h ){
		next unless $e =~ m"^\w.*\.filterrules$";
		my $f = "$d/$e";
		open my $i, "<", $f or do {
			die "$f: cannot open, stopped";
		};
		my $vhost_re;
		my $vservice_re;
		while( <$i> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhost_re = qr"^$1$";
				$vservice_re = qr"^$2$";
			}elsif( m"^filter\s+(\S+)" ){
				my $filter = $1;

				# TODO: check filter path

				push @rules, [$vhost_re, $vservice_re, $filter];
			}else{
				die "$f:$.: illegal format, stopped";
			}
		}
		close $i;
	}
	closedir $h;

	foreach my $i ( @$host_service_measure_opts ){
		my ($host, $service, $measure, $opts) = @$i;
		my $measuretype = $$measure2measuretype{$measure};

		my $f;
		if( $measuretype eq 'agent' ){
			my $f = "$WORKDIR/ncrtagent/$host/$filtertype/$filtertype.$host.$service";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				next unless $service =~ $rule->[1];
				print $h $rule->[2], "\n";
			}
			close $h;
			unlink $f unless -s $f;
		}

		foreach my $master ( @ncrtmasters ){
			my $f = "$WORKDIR/ncrtmaster/$master/$filtertype/$filtertype.$host.$service";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				next unless $service =~ $rule->[1];
				print $h $rule->[2], "\n";
			}
			close $h;
			unlink $f unless -s $f;
		}
	}
}

sub generate_masterconf_for_filter ($$$@) {
	my ($filtertype, $measure2measuretype, $host_service_measure_opts, @masters) = @_;

	##
	my $d = "$CONFDIR/$filtertype";
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	my @rules;
	foreach my $e ( sort readdir $h ){
		next unless $e =~ m"^\w.*\.filterrules$";
		my $f = "$d/$e";
		open my $i, "<", $f or do {
			die "$f: cannot open, stopped";
		};
		my $vhost_re;
		my $vservice_re;
		while( <$i> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhost_re = qr"^$1$";
				$vservice_re = qr"^$2$";
			}elsif( m"^filter\s+(\S+)" ){
				my $filter = $1;

				# TODO: check filter path

				push @rules, [$vhost_re, $vservice_re, $filter];
			}else{
				die "$f:$.: illegal format, stopped";
			}
		}
		close $i;
	}
	closedir $h;

	foreach my $i ( @$host_service_measure_opts ){
		my ($host, $service, $measure, $opts) = @$i;
		my $measuretype = $$measure2measuretype{$measure};

		foreach my $master ( @ncrtmasters ){
			my $f = "$WORKDIR/ncrtmaster/$master/$filtertype/$filtertype.$measure.$host.$service";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				next unless $service =~ $rule->[1];
				print $h $rule->[2], "\n";
			}
			close $h;
			unlink $f unless -s $f;
		}
	}
}

my %host2service2metricfilters;
if( $plan{Step13} ){
	generate_filter_settings 
		"metricfilter",
		%measure2measuretype,
		@host_service_measure_opts;

	generate_filter_settings 
		"thresholdfilter",
		%measure2measuretype,
		@host_service_measure_opts;

	generate_masterconf_for_filter 
		"metricfilter",
		\%measure2measuretype,
		\@host_service_measure_opts;

	generate_masterconf_for_filter 
		"thresholdfilter",
		\%measure2measuretype,
		\@host_service_measure_opts;
}

######## Step14. ########

#### generate thresholds settings
sub generate_masterconf_for_threshold ($$@) {
	my ($measure2measuretype, $host_service_measure_opts, @masters) = @_;
	my $f = "$CONFDIR/threshold";
	opendir my $h, $f or do {
		die "$f: cannot open, stopped";
	};
	my @rules;
	foreach my $e ( sort readdir $h ){
		next unless $e =~ m"^\w.*\.thresholds$";
		my $vhost_re;
		my $vservice_re;
		my $g = "$f/$e";
		open my $i, "<", $g or do {
			die "$f: cannot open, stopped";
		};
		while( <$i> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhost_re = qr"^$1$";
				$vservice_re = qr"^$2$";
			}elsif( m"^\S+" ){
				push @rules, [$vhost_re, $vservice_re, $_];
			}else{
				die "$g:$.: illegal format, stopped";
			}
		}
		close $i;
	}
	closedir $h;

	foreach my $i ( @$host_service_measure_opts ){
		my ($host, $service, $measure, $opts) = @$i;
		my $measuretype = $$measure2measuretype{$measure};

		my $f;
		foreach my $master ( @ncrtmasters ){
			my $f = "$WORKDIR/ncrtmaster/$master/threshold/thresholds.$measure.$host.$service";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				next unless $service =~ $rule->[1];
				print $h $rule->[2], "\n";
			}
			close $h;
		}
	}
}

my %host2service2metricfilters;
if( $plan{Step14} ){
	generate_masterconf_for_threshold \%measure2measuretype, \@host_service_measure_opts, @ncrtmasters;

	##
	my $f = "$CONFDIR/threshold";
	opendir my $h, $f or do {
		die "$f: cannot open, stopped";
	};
	my @rules;
	foreach my $e ( sort readdir $h ){
		next unless $e =~ m"^\w.*\.thresholds$";
		my $vhost_re;
		my $vservice_re;
		my $g = "$f/$e";
		open my $i, "<", $g or do {
			die "$f: cannot open, stopped";
		};
		while( <$i> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhost_re = qr"^$1$";
				$vservice_re = qr"^$2$";
			}elsif( m"^\S+" ){
				push @rules, [$vhost_re, $vservice_re, $_];
			}else{
				die "$g:$.: illegal format, stopped";
			}
		}
		close $i;
	}
	closedir $h;

	foreach my $i ( @host_service_measure_opts ){
		my ($host, $service, $measure, $opts) = @$i;
		my $measuretype = $measure2measuretype{$measure};

		my $f;
		if( $measuretype eq 'agent' ){
			my $f = "$WORKDIR/ncrtagent/$host/threshold/thresholds.$host.$service";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				next unless $service =~ $rule->[1];
				print $h $rule->[2], "\n";
			}
			close $h;
		}elsif( $measuretype eq 'agentless' || $measuretype eq 'indirect' ){
	
			foreach my $master ( @ncrtmasters ){
				my $f = "$WORKDIR/ncrtmaster/$master/threshold/thresholds.$host.$service";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				foreach my $rule ( @rules ){
					next unless $host =~ $rule->[0];
					next unless $service =~ $rule->[1];
					print $h $rule->[2], "\n";
				}
				close $h;
			}
		}else{
			die "$measuretype, stopped";
		}
	}
}

######## Step15. ########

my %host2params;
if( $plan{Step15} ){

	#### agent conf
	my $f = "$WORKDIR/agenthosts";
	open my $h, "<", $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		next if m"^\s*(#|$)";
		my ($host, $agenttype, @param) = split m"\s+";
		my $g = "$WORKDIR/ncrtagent/$host/ncrtagent_$agenttype.conf";
		open my $i, ">", $g or do {
			die "$g: cannot open, stopped";
		};
		foreach my $p ( @param ){
			print $i "$p\n";
			die unless $p =~ m"^(\w+)=(.*)$";
			my $k = $1;
			my $v = $2;
			$host2params{$host}->{$k} = $v;
		}
		close $i;
	}
	close $h;

	#### hosts conf
	my $f = "$WORKDIR/agenthosts";
	foreach my $master ( @ncrtmasters ){
		my $g = "$WORKDIR/ncrtmaster/$master/agenthosts";
		system_or_die "cp $f $g";
	}
}

#exit 0;

######## Step16. ########

sub generate_shortnamelist ($) {
	return '' unless defined $_[0];
	return join ',', @{$_[0]};
}

sub generate_naemoncfgline (\%\%) {
	my ($opts, $params) = @_;
	my @settings;
	foreach my $k ( sort keys %{$opts} ){
		my $v = $opts->{$k};
		push @settings, sprintf "\t%-23s\t%s\n",
			$k, expand_params $v, %$params;
	}
	return @settings;
}

sub generate_options ($$$;%) {
	my ($rules, $host, $service, %orig_options) = @_;
	my %options = %orig_options;
	foreach my $rule ( @$rules ){
		my ($host_re, $service_re, %add_options) = @$rule;
		next unless $host =~ m"$host_re";
		next unless $service =~ m"$service_re";
		while( my ($k, $v) = each %add_options ){ $options{$k} = $v; }
	}
	return %options;
}

####
if( $plan{Step16} ){

	#### write template settings
	my $f = "$WORKDIR/ncrt_hosttemplates.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $agenttype ( sort keys %agenttype2templateopts ){
		my %param = ( 'agenttype' => $agenttype );
		my $ht_topt = $agenttype2templateopts{$agenttype};
		my @settings = generate_naemoncfgline %$ht_topt, %param;
		####
		print $h
		"define host {\n",
		"	name			ncrt-agenttype-$agenttype\n",
		"	use			ncrt-generic-host\n",
		@settings,
		"	register		0\n",
		"}\n";
	}
	close $h;

	my $f =  "$WORKDIR/ncrt_servicetemplates.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $measure ( sort keys %measure2measuretype ){
		my %p = ( 'measure' => $measure );
		my $measuretype = $measure2measuretype{$measure};
		my $s_topt = $measure2templateopts{$measure};
		my @settings = generate_naemoncfgline %$s_topt, %p;
		####
		if( $measuretype eq 'agent' ){
			print $h
			"define service {\n",
			"	name		ncrtdetector-$measure\n",
			"	check_command	ncrtmaster_detect_by_targetagent\n",
			"	_measure	$measure\n",
			"	use		ncrt-generic-service\n",
			@settings,
			"	register	0\n",
			"}\n";
		}elsif( $measuretype eq 'agentless' ){
			print $h
			"define service {\n",
			"	name		ncrtdetector-$measure\n",
			"	check_command	ncrtmaster_detect\n",
			"	_measure	$measure\n",
			"	use		ncrt-generic-service\n",
			@settings,
			"	register	0\n",
			"}\n";
		}elsif( $measuretype eq 'indirect' ){
			print $h
			"define service {\n",
			"	name		ncrtdetector-$measure\n",
			"	check_command	ncrtmaster_detect_by_proxyagents\n",
			"	_measure	$measure\n",
			"	use		ncrt-generic-service\n",
			@settings,
			"	register	0\n",
			"}\n";
		}else{
			die;
		}
	}
	close $h;

	#### write settings

	my $f = "$WORKDIR/ncrt_hosts.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $host ( sort keys %host2service2measure ){
		my $agenttype = $host2agenttype{$host} // 'virtual';
		my %var = ( 'hostname' => $host, 'agenttype' => $agenttype );
		my %options = generate_options $rules4option,
			$host, "-", %{$agenttype2opts{$agenttype}};
		my @settings = generate_naemoncfgline %options, %var;
		my $contacts = generate_shortnamelist $host2contact{$host};
		my $_urlencoded = uri_escape_utf8($host);
		$contacts = "nobody" if $contacts eq "";
		####
		print $h
		"define host {\n",
		"	host_name		$host\n",
		"	use			ncrt-agenttype-$agenttype\n",
		"	check_command		ncrtmaster_ping\n",
		"	contacts		$contacts\n",
		"	_urlencoded		$_urlencoded\n",
		"	_agenttype		$agenttype\n",
		@settings,
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_services.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $host_service_measure_opts ( @host_service_measure_opts ){
		my ($host, $service, $measure, $hs_opts) = @$host_service_measure_opts;
		my $agenttype = $host2agenttype{$host};
		my $measuretype = $measure2measuretype{$measure};
		my %options = generate_options $rules4option,
			$host, $service,
			%{$measure2opts{$measure}}, %{$hs_opts};
		my %var = ( 'hostname' => $host, 'agenttype' => $agenttype );
		my @settings = generate_naemoncfgline %options, %var;
		my $contacts = generate_shortnamelist $host2service2contact{$host}->{$service};
		my $_urlencoded = uri_escape_utf8($service);
		$contacts = "nobody" if $contacts eq "";
		if    ( $measuretype eq "master" ){
			$agenttype = 'virtual';
		}elsif( $measuretype eq "indirect" ){
			$agenttype = 'virtual';
                }
		####
		print $h
			"define service {\n",
			"       host_name               $host\n",
			"       service_description     $service\n",
			"       use                     ncrtdetector-$measure\n",
			"       contacts                $contacts\n",
			"	_urlencoded		$_urlencoded\n",
			"	_agenttype		$agenttype\n",
			@settings,
			"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_hostgroups.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $group ( sort keys %group2host ){
		my $hosts = generate_shortnamelist $group2host{$group};
		print $h
		"define hostgroup {\n",
		"	hostgroup_name		$group\n",
		"	members			$hosts\n",
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_servicegroups.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $group ( sort keys %group2host2service ){
		my @r;
		my $host2service_map = $group2host2service{$group};
		foreach my $host ( sort keys %{$host2service_map} ){
			my $service_map = $host2service_map->{$host};
			foreach my $service ( sort keys %{$service_map} ){
				push @r, "$host,$service";
			}
		}
		my $r = join ",", @r;
		print $h
			"define servicegroup {\n",
			"	servicegroup_name	$group\n",
			"	members			$r\n",
			"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_users.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $user ( sort keys %users ){
		print $h
		"define contact {\n",
		"	contact_name		$user\n",
		"	host_notification_commands	ncrtmaster_do_nothing\n",
		"	service_notification_commands	ncrtmaster_do_nothing\n",
		"	host_notification_period	ncrt_notime\n",
		"	service_notification_period	ncrt_notime\n",
		"	host_notification_options	n\n",
		"	service_notification_options	n\n",
		"	host_notifications_enabled	0\n",
		"	service_notifications_enabled	0\n",
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_addresses.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $address ( sort keys %addresses ){
		print $h
		"define contact {\n",
		"	contact_name			$address\n",
		"	email				$address\n",
		"	host_notification_commands	ncrtmaster_do_nothing\n",
		"	service_notification_commands	ncrtmaster_do_nothing\n",
		"	host_notification_period	ncrt_anytime\n",
		"	service_notification_period	ncrt_anytime\n",
		"	host_notification_options	n\n",
		"	service_notification_options	w,u,c,r\n",
		"	host_notifications_enabled	0\n",
		"	service_notifications_enabled	1\n",
		"}\n";
	}
	close $h;
}

######## Step17. ########

if( $plan{Step17} ){
	my @masterconfs;
	my $f = "$WORKDIR/masterconfs";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$h> ){
		chomp;
		die unless -f "$CONFDIR/$_";
		push @masterconfs, $_;
	}
	close $h;

	my $f = "$WORKDIR/reporters";
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $i ( @reporter_plugins ){
		die unless $i =~ m"^ncrtbuild_reporter_(.*)$";
		print $h "$1\n";
	}
	close $h;

	####
	foreach my $master ( @ncrtmasters ){
		foreach my $f ( "reporters" ){
			system_or_die "cp $WORKDIR/$f $WORKDIR/ncrtmaster/$master/$f";
		}
	
		foreach my $f ( "ncrtbuild.conf", @masterconfs ){
			system_or_die "cp $CONFDIR/$f $WORKDIR/ncrtmaster/$master/$f";
		}
	}
}

######## Step18. ########

if( $plan{Step18} ){
	####
	my $ncrtmasterhosts = join( ',', @ncrtmasters );

	my $f = "$WORKDIR/vars.yml";
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	print $h <<"EOF";
---

 HELPERURL:           "$HELPERURL"
 HELPERURL_JUMP_TO_DASHBOARD: "$HELPERURL_JUMP_TO_DASHBOARD"
 HELPERURL_SEARCH_PANELS:     "$HELPERURL_SEARCH_PANELS"
 NCRTAGENTHOME:       "$NCRTAGENTHOME"
 NCRTMASTERHOME:      "$NCRTMASTERHOME"
 NAEMON2INFLUX_DEB:   "$NAEMON2INFLUX_DEB"
 GRAFANA_DASHBOARD_HELPER_DEB: "$GRAFANA_DASHBOARD_HELPER_DEB"

EOF
	while( my ($k, $v) = each %ncrtconf ){
		next unless $k =~ m"^(AGENT|MASTER)TYPE_[A-Z]+_";
		print $h " $k: \"$v\"\n";
	}
	close $h;
}

#exit 0;

######## Step19. ########

sub hash2yaml ($) {
	my ($params) = @_;
	my @params;
	foreach my $k ( sort keys %$params ){
		my $v = $$params{$k};
		push @params, "\"$k\":\"$v\"";
	}
	return "{" . join(", ", @params) . "}";
}

sub generate_hosts_yml ($$$$) {
	my ($name, $hosttype2hosts, $host2params, $regexp) = @_;

	my $hosts_yml = "$WORKDIR/$name.yml";
	open my $h, '>', $hosts_yml or do {
		die "$hosts_yml: cannot open, stopped";
	};
	print $h
		"all:\n",
		"  children:\n",
		"    AllHosts:\n",
		"      children:\n";
	foreach my $hosttype ( sort keys %$hosttype2hosts ){
		print $h "        $hosttype.__HOSTTYPE__:\n";
	}
	foreach my $hosttype ( sort keys %$hosttype2hosts ){
		my $hosts = $$hosttype2hosts{$hosttype};
		print $h
			"    $hosttype.__HOSTTYPE__:\n",
			"      hosts:\n";
		foreach my $host ( sort @$hosts ){
			next unless $host =~ $regexp;
			my $yaml_hash = hash2yaml $$host2params{$host};
			print $h "        $host: $yaml_hash\n";
		}
	}
	close $h;
}

sub generate_playbook ($$) {
	my ($playbookname, $hosttypes) = @_;

	my $tt = Template->new({
		INCLUDE_PATH => $PLAYBOOKSDIR,
		OUTPUT_PATH  => $WORKDIR,
	}) or do {
		die "$playbookname.yml.tt: cannot read, stopped";
	};

	my $output;
	my %vars = (
		TOOLHOME    => $TOOLHOME,
		WORKDIR     => $WORKDIR,
		HOSTTYPES   => $hosttypes,
		file_exists => sub { return -f $_[0]; },
	);
	$tt->process( "$playbookname.yml.tt", \%vars, "$playbookname.yml" ) or do {
        	die "$playbookname.yml: " . $tt->error() . ", stopped";
	};
}

####
my $tags = 'common';
unless( $quick ){
	$tags .= ',commoninstall';
}

#### run ansible for nagios master
generate_hosts_yml 'master_hosts', \%mastertype2hosts, {},
	$target_master;
generate_playbook 'build_ncrtmaster', \@mastertypes;

my $options = sprintf "%s -e WORKDIR=%s -e TOOLHOME=%s -t \"%s\"",
	$ncrtconf{'ANSIBLEOPTIONS'}, $WORKDIR, $TOOLHOME, $tags;

if( $plan{Step19} ){
	my $cmd = "ansible-playbook -v" .
		" -i $WORKDIR/master_hosts.yml" .
		" $options $WORKDIR/build_ncrtmaster.yml";
	print $cmd;
	system_or_die $cmd;
}

######## Step20. ########

#### run ansible for nrpe agent
generate_hosts_yml 'agent_hosts', \%agenttype2hosts, \%host2params,
	$target_agent;
generate_playbook 'build_ncrtagent', \@agenttypes;

my $options = sprintf "%s -e WORKDIR=%s -e TOOLHOME=%s -t \"%s\"",
	$ncrtconf{'ANSIBLEOPTIONS'}, $WORKDIR, $TOOLHOME, $tags;

if( $plan{Step20} ){
	my $cmd = "ansible-playbook -v" .
		" -i $WORKDIR/agent_hosts.yml" .
		" $options $WORKDIR/build_ncrtagent.yml";
	print $cmd;
	system_or_die $cmd;
}

######## Step21. ########
END {
	if( $plan{Step21} ){
		rm_r $WORKDIR if -d $WORKDIR;
	}
}


