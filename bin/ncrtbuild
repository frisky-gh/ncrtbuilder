#!/usr/bin/perl

use strict;
use Getopt::Long;
use Cwd 'abs_path';
use URI::Escape;

$0 =~ m"^(.*)/";
our $TOOLHOME = abs_path("$1/..");
our $PLUGINSDIR = "$TOOLHOME/plugins";
our $PLAYBOOKSDIR = "$TOOLHOME/playbooks";
our $CONFDIR = "$TOOLHOME/conf";
our $SRCDIR = "$TOOLHOME/src";
our $TMPDIR = "/tmp";
our $WORKDIR = "$TMPDIR/ncrt_work.$$";

our $AGENTCONFDIR = "$TOOLHOME/ncrtagent/conf";
our $MASTERCONFDIR = "$TOOLHOME/ncrtmaster/conf";
 
my $workdir;
my $master_only;
my $agent_only;
my $threshold_only;
my $dryrun;
my $quick;
my $no_cleanup;
GetOptions (
	'workdir=s' => \$workdir,
	'master-only' => \$master_only,
	'agent-only' => \$agent_only,
	'threshold-only' => \$threshold_only,
	'no-cleanup' => \$no_cleanup,
	'dryrun' => \$dryrun,
	'quick' => \$quick,
) or die "Invalid command line options, stopped";

# step0.  read ncrtbuilder conf (*)
# step1.  generate packages and certs
# step2.  create work dir structure
# step3.  run hosttype plugins
# step4.  run service plugins
# step5.  run contact plugins
# step6.  read confs generated by plugins (*)
# step7.  generate naemon conf
# step8.  deploy ncrtmasters
# step9.  deploy ncrtagents
# step10. clean up work dir

my %plan = (
	'step0' => 1,
	'step1' => 1,
	'step2' => 1,
	'step3' => 1,
	'step4' => 1,
	'step5' => 1,
	'step6' => 1,
	'step7' => 1,
	'step8' => 1,
	'step9' => 1,
	'step10' => 1,
);

if( $dryrun ){ $plan{step8} = 0; $plan{step9} = 0; }
if( $master_only ){ $plan{step9} = 0; }
if( $agent_only ) { $plan{step8} = 0; }
if( $workdir ){ $WORKDIR = $workdir; }
if( $no_cleanup ){ $plan{step10} = 0; }

####
sub rm_r ($) {
	my ($r) = @_;
	return unless -d $r;
	opendir my $d, $r or do {
		die "$r: cannot open, stopped";
	};
	my @e = readdir $d;
	foreach my $e ( @e ){
		next if $e eq '..' || $e eq '.';
		if( -d "$r/$e" ){
			rm_r( "$r/$e" );
		}else{
			unlink "$r/$e" or die "$r/$e, stopped";
		}
	}
	closedir $d;
	rmdir $r or die "$r: cannot remove, stopped";
}

sub mkdir_or_die ($) {
	my ($d) = @_;
	return if -d $d;
	mkdir $d or die "$d: cannot create, stopped";
}

sub create_or_die ($) {
	my ($f) = @_;
	open my $h, '>', $f or die "$f: cannot create, stopped";
	close $h;
}

sub parse_service ($) {
	my ($service) = @_;
	return $1, $1 if $service =~ m"^(\w+)$";
	return $1, $2 if $service =~ m"^(\w+),(\w+)$";
	die "$service: illegal service name, stopped";
}

sub _parse_option ($) {
	( $_ ) = @_;
	my %opt;
	my %templateopt;
	while( m{\G
		($|\s+
			(\@)?(\w+)=
			(?:
				"([^\\"]*(?:(?:\\\\|\\")+[^\\"]*)*)"|
				([\w\!\#-\&\(-\/\:-\@\[-\_\{-\~]+)
			)
		)
	}gx ){
		return \%opt, \%templateopt if $1 eq '';

		my $template = $2;
		my $key = $3;
		my $value = $4 ne '' ? $4 : $5;

		if( $template ){ $templateopt{$key} = $value; }
		else           { $opt{$key} = $value; }
	}
	return undef;
}

sub parse_itementry ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef if m"^\s*(#|$)";
	return undef, "illegal format" unless m"^(\w+)"g;
	my $item = $1;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $item, $opt, $topt;
}

sub parse_addressentry ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef if m"^\s*(#|$)";
	return undef, "illegal format" unless m"^(\S+\@[-.a-zA-Z0-9]+)"g;
	my $item = $1;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $item, $opt, $topt;
}

sub parse_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, "illegal format" unless m"^(\S+)\s+([\w,]+)"g;
	my $from = $1;
	my $to = $2;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $from, $to, $opt, $topt;
}

sub parse_host2item_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, "illegal format" unless m"^(\S+)\s+(\S+)$";
	return $1, $2, undef;
}

sub parse_hostservice2item_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, undef, "illegal format" unless m"^(\S+)\s+([\w,]+)\s+(\S+)$";
	return $1, $2, $3, undef;
}

sub expand_importspec (@){
	my @importmacros;
	my %t;
	foreach my $i ( @_ ){ $t{$i} = 1; }
	foreach my $i ( keys %t ){
		my ($host, $service, $prefix) = split m":", $i;
		push @importmacros,
			"$host:$service:$prefix \$SERVICEPERFDATA:$host:$service\$";
	}
	my $importmacro = join " ", @importmacros;
	return $importmacro;
}

sub expand_params ($\%) {
	my ($text, $params) = @_;
	$text =~ s{ \%(\w+)\% }{ $params->{$1}; }egx;
	return $text;
}

END {
	if( $plan{step10} ){
		rm_r $WORKDIR if -d $WORKDIR;
	}
}

######## Step 0. ########

exit 0 unless $plan{step0};

#### load template conf.
my %ncrtconf;
my $f = "$CONFDIR/ncrtbuild.conf";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	next if m"^\s*(#|$)";
	m"^(\w+)=(.*)$" or die "$f:$.: illegal format, stopped";
	$ncrtconf{$1} = $2;
}
close $h;

our $ANSIBLEOPTIONS = $ncrtconf{'ANSIBLEOPTIONS'};
our $NCRTAGENTHOME  = $ncrtconf{'NCRTAGENTHOME'};
our $NCRTMASTERHOME = $ncrtconf{'NCRTMASTERHOME'};
our $HELPERURL      = $ncrtconf{'HELPERURL'};
our $GRAFANADB      = $ncrtconf{'GRAFANADB'};
our $GRAFANAUSER    = $ncrtconf{'GRAFANAUSER'};
our $GRAFANAPASSWD  = $ncrtconf{'GRAFANAPASSWD'};
our $GRAFANAORGID   = $ncrtconf{'GRAFANAORGID'};
our $INFLUXDBHOST	 = $ncrtconf{'INFLUXDBHOST'} // 'localhost';
our $INFLUXDBPORT	 = $ncrtconf{'INFLUXDBPORT'} // '8086';
our $INFLUXDBADMINUSER   = $ncrtconf{'INFLUXDBADMINUSER'}   // 'admin';
our $INFLUXDBADMINPASSWD = $ncrtconf{'INFLUXDBADMINPASSWD'} // 'admin';
our $INFLUXDBUSER	 = $ncrtconf{'INFLUXDBUSER'}     // 'naemon';
our $INFLUXDBPASSWD      = $ncrtconf{'INFLUXDBPASSWD'}   // 'naemon';
our $INFLUXDBDATABASE    = $ncrtconf{'INFLUXDBDATABASE'} // 'naemon';
our $AGENTPACKAGE	 = $ncrtconf{'AGENTPACKAGE'} || 'nrpe';
our $NRPEPORT	         = $ncrtconf{'NRPEPORT'} // '5666';
our $NRPETLS	         = $ncrtconf{'NRPETLS'} // 'yes';
our $NRPEALLOWEDHOSTS	 = $ncrtconf{'NRPEALLOWEDHOSTS'};

sub get_naemon2influx_deb ($) {
	my ($d) = @_;
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	while( my $e = readdir $h ){
		next unless $e =~ m"^naemon2influx-\d.*\.deb$";
		return $e;
	}
	closedir $h;
	return undef;
}

sub get_naemon2influx_grafana_helper_deb ($) {
	my ($d) = @_;
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	while( my $e = readdir $h ){
		next unless $e =~ m"^naemon2influx-grafana-helper_.*\.deb$";
		return $e;
	}
	closedir $h;
	return undef;
}

our $NAEMON2INFLUX_DEB                = get_naemon2influx_deb $CONFDIR;
our $NAEMON2INFLUX_GRAFANA_HELPER_DEB = get_naemon2influx_grafana_helper_deb $CONFDIR;

#### load ncrtmaster.conf
my @ncrtmasters;
my @ncrtmasteraddrs;
my $f = "$CONFDIR/ncrtmasters.conf";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	next if m"^\s*(#|$)";
	push @ncrtmasters, $_;
	my ( $name, $aliases, $addrtype, $length, @addrs ) = gethostbyname $_;
	push @ncrtmasteraddrs, @addrs;
}
close $h;
$NRPEALLOWEDHOSTS = join ",", @ncrtmasteraddrs if $NRPEALLOWEDHOSTS eq '';

#### find all plugins
my @hosttype_plugins;
my @service_plugins;
my @contact_plugins;
opendir my $d, $PLUGINSDIR or do {
	die "$PLUGINSDIR: cannot open, stopped";
};
while( my $e = readdir $d ){
	next unless $e =~ m"^ncrtbuild(?:(service)|(hosttype)|(contact))_";
	push @service_plugins,  $e if $1;
	push @hosttype_plugins, $e if $2;
	push @contact_plugins,  $e if $3;
}
closedir $d;

######## Step 1. ########

if( $plan{step1} ){

	#### build naemon2influx package
	if( not defined $NAEMON2INFLUX_DEB ){
		unless( -d "$SRCDIR/naemon2influx" ){
			my $r = system "git clone --depth=1 https://github.com/hakong/naemon2influx.git $SRCDIR/naemon2influx";
			die unless $r == 0;
		}
		my $r = system "make deb -C $SRCDIR/naemon2influx";
		die unless $r == 0;
		$NAEMON2INFLUX_DEB = get_naemon2influx_deb $SRCDIR;
		defined $NAEMON2INFLUX_DEB or
			die "naemon2influx: cannot build package, stopped";
		my $r = system "cp $SRCDIR/naemon2influx/$NAEMON2INFLUX_DEB $CONFDIR/$NAEMON2INFLUX_DEB";
		die unless $r == 0;
	}

	#### build naemon2influx-grafana-helper package
	if( not defined $NAEMON2INFLUX_GRAFANA_HELPER_DEB ){
		unless( -d "$SRCDIR/naemon2influx-grafana-helper" ){
			my $r = system "git clone --depth=1 https://github.com/frisky-gh/naemon2influx-grafana-helper.git $SRCDIR/naemon2influx-grafana-helper";
			die unless $r == 0;
		}
		my $r = system "cd $SRCDIR/naemon2influx-grafana-helper && dpkg-buildpackage --no-sign";
		die unless $r == 0;
		$NAEMON2INFLUX_GRAFANA_HELPER_DEB = get_naemon2influx_grafana_helper_deb $SRCDIR;
		defined $NAEMON2INFLUX_GRAFANA_HELPER_DEB or
			die "naemon2influx-grafana-helper: cannot build package, stopped";
		my $r = system "cp $SRCDIR/$NAEMON2INFLUX_GRAFANA_HELPER_DEB $CONFDIR/$NAEMON2INFLUX_GRAFANA_HELPER_DEB";
		die unless $r == 0;
	}

	#### create server cert. if not exists
	if( ! -f "$CONFDIR/ncrt_key.pem" ){
		my $r = system "openssl req -verbose -subj '/C=JP/ST=Kanagawa-ken/O=Watao Family/CN=*' -x509 -newkey rsa:2048 -nodes -keyout $CONFDIR/ncrt_key.pem -out $CONFDIR/ncrt_cert.pem -days 36525";
		die unless $r == 0;
	}
}

######## Step 2. ########

if( $plan{step2} ){

	#### initialize fixed work dirs and files
	rm_r $WORKDIR if -d $WORKDIR;
	mkdir_or_die $WORKDIR;
	mkdir_or_die "$WORKDIR/ncrtmaster";
	mkdir_or_die "$WORKDIR/ncrtagent";

	# hostname -> hosttype mappings
	create_or_die "$WORKDIR/hosts";

	# hosttype list
	create_or_die "$WORKDIR/hosttypes";

	# service list
	create_or_die "$WORKDIR/services";

	# service -> configuration file multi-mappings
	create_or_die "$WORKDIR/service2conf";

	# hostname -> service multi-mapping
	create_or_die "$WORKDIR/host2service";

	# hostname -> contact multi-mapping
	create_or_die "$WORKDIR/host2contact";

	# (hostname, service) -> contact multi-mapping
	create_or_die "$WORKDIR/hostservice2contact";

	# hostname -> groupname multi-mapping
	create_or_die "$WORKDIR/host2group";

	# (hostname, service) -> groupname multi-mapping
	create_or_die "$WORKDIR/hostservice2group";

	# username list
	create_or_die "$WORKDIR/users";

	# email address list
	create_or_die "$WORKDIR/addresses";

	####
	my $action_url = "${HELPERURL}/redirect.html?hostname=\$_HOSTURLENCODED\$&servicedesc=\$_SERVICEURLENCODED\$";
	my $f = "$WORKDIR/ncrt_hosttemplates.cfg";
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	print $h <<"EOF";
# host settings for Nagios / Naemon

define host {
	name				ncrt-generic-host
	
	check_command			ncrt-check-host
	check_interval			4
	retry_interval			1
	max_check_attempts		3
	check_period			24x7

	notifications_enabled		1
	notification_interval		60
	notification_options		d,u,r
	notification_period		24x7
	contact_groups			

	process_perf_data		1
	event_handler_enabled		1	; Host event handler is enabled
	flap_detection_enabled		1	; Flap detection is enabled
	retain_nonstatus_information	1       ; Retain non-status information across program restarts
	retain_status_information	1       ; Retain status information across program restarts

	register			0	; DONT REGISTER THIS DEFINITION - ITS NOT A REAL HOST, JUST A TEMPLATE!

}

EOF
	close $h;
	my $f = "$WORKDIR/ncrt_servicetemplates.cfg";
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	print $h <<"EOF";
# service settings for Nagios / Naemon

define service {
	name				ncrt-generic-service

	active_checks_enabled		1
	passive_checks_enabled		1
	check_freshness			0       ; Default is to NOT check service 'freshness'
	check_interval			4
	retry_interval			1
	max_check_attempts		3
	check_period			24x7

	notifications_enabled		1
	notification_interval		60
	notification_options		w,u,c,r
	notification_period		24x7
	contact_groups			

	is_volatile			0       ; The service is not volatile
	obsess_over_service		1       ; We should obsess over this service (if necessary)
	process_perf_data		1
	event_handler_enabled		1       ; Service event handler is enabled
	flap_detection_enabled		1       ; Flap detection is enabled
	retain_nonstatus_information	1       ; Retain non-status information across program restarts
	retain_status_information	1       ; Retain status information across program restarts

	action_url			$action_url

	register			0	; DONT REGISTER THIS DEFINITION - ITS NOT A REAL SERVICE, JUST A TEMPLATE!
}

EOF
	close $h;

}

######## Step 3. ########

if( $plan{step3} ){
	#### run hosttype plugins
	foreach my $e ( sort @hosttype_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		my $r = system "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
		print "r=", $r, "\n";
		die unless $r == 0;
	}
}

######## Step 4. ########

if( $plan{step4} ){
	#### run service plugins
	foreach my $e ( sort @service_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		my $r = system "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
		print "r=", $r, "\n";
		die unless $r == 0;
	}
}

######## Step 5. ########

if( $plan{step5} ){
	#### run contact plugins
	foreach my $e ( sort @contact_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		my $r = system "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
		print "r=", $r, "\n";
		die unless $r == 0;
	}
}

######## Step 6. ########

exit 0 unless $plan{step6};

#### initialize variable work dirs.
my %host2hosttype;
my $hosttype_has_collision;
my $f = "$WORKDIR/hosts";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	my ($host, $hosttype) = split m"\s+";
	if( not defined $host2hosttype{$host} ){
		$host2hosttype{$host} = $hosttype;
	}elsif( $host2hosttype{$host} ne $hosttype ){
		print "ERROR: host $host has multiple hosttypes.\n";
		$hosttype_has_collision = 1;
	}
}
close $h;

die "Some hosttype have collisions, stopped" if $hosttype_has_collision;

my @ncrtagents;
while( my ($h, $t) = each %host2hosttype ){
	push @ncrtagents, $h unless $t eq "virtual";
}

foreach my $h ( @ncrtmasters ){
	mkdir_or_die "$WORKDIR/ncrtmaster/$h";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/master";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/gateway";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/composite";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/statistic";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/threshold";
	my $r = system "rsync -aSvx $MASTERCONFDIR/ $WORKDIR/ncrtmaster/$h/";
	die unless $r == 0;
}
foreach my $h ( @ncrtagents ){
	mkdir_or_die "$WORKDIR/ncrtagent/$h";
	mkdir_or_die "$WORKDIR/ncrtagent/$h/agent";
	mkdir_or_die "$WORKDIR/ncrtagent/$h/gateway";
	mkdir_or_die "$WORKDIR/ncrtagent/$h/statistic";
	mkdir_or_die "$WORKDIR/ncrtagent/$h/threshold";
	my $r = system "rsync -aSvx $AGENTCONFDIR/ $WORKDIR/ncrtagent/$h/";
	die unless $r == 0;
}

#### read settings generated by plugins
my %hosttype2opts         = ( 'virtual' => {
	'display_name' => 'Virtual:%hostname%',
	'address' => '127.0.0.1',
} );
my %hosttype2templateopts = ( 'virtual' => {
} );
my $f = "$WORKDIR/hosttypes";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($hosttype, $opts, $templateopts) = parse_itementry $_;
	print "$f:$.:$opts\n" if !defined $hosttype && defined $opts;
	next unless $hosttype;
	$hosttype2opts{$hosttype} = $opts;
	$hosttype2templateopts{$hosttype} = $templateopts;
}
close $h;

my %service2servicetype;
my %service2opts;
my %service2templateopts;
my $f = "$WORKDIR/services";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($service, $servicetype, $opts, $templateopts) = parse_mapping $_;
	print "$f:$.:$opts\n" if !defined $service && defined $opts;
	next unless $service;
	$service2servicetype{$service} = $servicetype;
	$service2opts{$service} = $opts;
	$service2templateopts{$service} = $templateopts;
}
close $h;

my %host2vservice2rservice;
my @host_vservice_rservice_opts;
my $f = "$WORKDIR/host2service";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $service, $opts) = parse_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	my ($rservice, $vservice) = parse_service $service;
	$host2vservice2rservice{$host}->{$vservice} = $rservice;
	push @host_vservice_rservice_opts, [$host, $vservice, $rservice, $opts];
}
close $h;

my %host2contact;
my $f = "$WORKDIR/host2contact";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $contact, $opts) = parse_host2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$host2contact{$host}}, $contact;
}
close $h;

my %hostservice2contact;
my $f = "$WORKDIR/hostservice2contact";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $service, $contact, $opts) = parse_hostservice2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$hostservice2contact{$host, $service}}, $contact;
}
close $h;

my %group2host;
my $f = "$WORKDIR/host2group";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $group, $opts) = parse_host2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$group2host{$group}}, $host;
}
close $h;

my %group2hostservice;
my $f = "$WORKDIR/hostservice2group";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $service, $group, $opts) = parse_hostservice2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$group2hostservice{$group}}, [$host, $service];
}
close $h;

my %users = ( nobody => "" );
my $f = "$WORKDIR/users";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($user, $opts) = parse_itementry $_;
	print "$f:$.:$opts\n" if !defined $user && defined $opts;
	next unless $user;
	$users{$user} = $opts;
}
close $h;

my %addresses;
my $f = "$WORKDIR/addresses";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($address, $opts) = parse_addressentry $_;
	print "$f:$.:$opts\n" if !defined $address && defined $opts;
	next unless $address;
	$addresses{$address} = $opts;
}
close $h;

####
my %service2conf;
my $f = "$WORKDIR/service2conf";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	my ($service, $conf) = split m"\s+";
	push @{$service2conf{$service}}, $conf;
}
close $h;

######## Step 7. ########

sub generate_settings (\%\%) {
	my ($opts, $params) = @_;
	my @settings;
	foreach my $k ( sort keys %{$opts} ){
		my $v = $opts->{$k};
		push @settings, sprintf "\t%-23s\t%s\n",
			$k, expand_params $v, %$params;
	}
	return @settings;
}

sub generate_shortnamelist ($) {
	return '' unless defined $_[0];
	return join ',', @{$_[0]};
}

#### generate confs for which service type is agent
while( my ($service, $servicetype) = each %service2servicetype ){
	last unless $plan{step7};
	next unless $servicetype eq 'agent';
	my @confs = @{$service2conf{$service} // []};

	foreach my $conf ( @confs ){
		my @rules;
		my $f = "$CONFDIR/$conf";
		open my $h, '<', $f or do {
			die "$f: cannot open, stopped";
		};
		while( <$h> ){
			chomp;
			next if m"^\s*(#|$)";
			m"^(\S+)\s+(.*)" or
				die "$f:$.: illegal format, stopped";
			push @rules, [qr"$1", $2];
		}
		close $h;

		while( my ($host, $hosttype) = each %host2hosttype ){
			my $f = "$WORKDIR/ncrtagent/$host/$conf";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				print $h $rule->[1], "\n";
			}
			close $h;
		}
	}
}

#### generate confs for which service type is master
my %vhosts;
while( my ($service, $servicetype) = each %service2servicetype ){
	last unless $plan{step7};
	next unless $servicetype eq 'master';
	my @confs = @{$service2conf{$service}};

	foreach my $conf ( @confs ){
		my %vhost2rules;
		my $vhost;
		my $f = "$CONFDIR/$conf";
		open my $h, '<', $f or do {
			die "$f: cannot open, stopped";
		};
		while( <$h> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+===$" ){
				$vhost = $1;
				$vhosts{$vhost} = 1;
			}elsif( m"^(\S+)" ){
				push @{$vhost2rules{$vhost}}, $_;
			}else{
				die "$f:$.: illegal format, stopped";
			}
		}
		close $h;

		foreach my $master ( @ncrtmasters ){
			while( my ($vhost, $rules) = each %vhost2rules ){
				my $f = "$WORKDIR/ncrtmaster/$master/$conf.$vhost";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				foreach my $rule ( @$rules ){
					print $h $rule, "\n";
				}
				close $h;
			}
		}
	}
}

#### generate confs for which service type is gateway
sub diff (\%\%) {
	my ($old, $new) = @_;
	my %keys;
	my %d;
	while( my ($k) = each %$old ){ $keys{$k} = 1; }
	while( my ($k) = each %$new ){ $keys{$k} = 1; }
	while( my ($k) = each %keys ){
		my $o = $old->{$k};
		my $n = $new->{$k};
		next if $o eq $n;
		$d{$k} = $n;
	}
	return %d;
}

my %vhostvservices;
while( my ($service, $servicetype) = each %service2servicetype ){
	last unless $plan{step7};
	next unless $servicetype eq 'gateway';
	my @confs = @{$service2conf{$service}};

	foreach my $conf ( @confs ){
		my %vhostvservice2rules;
		my $vhostvservice;
		my %option;
		my $f = "$CONFDIR/$conf";
		open my $h, '<', $f or do {
			die "$f: cannot open, stopped";
		};
		while( <$h> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhostvservice = "$1 $2";
				$vhostvservices{$vhostvservice} = 1;
				%option = ();
			}elsif( m"^(\w+)=(\S*)$" ){
				$option{$1} = $2;
			}elsif( m"^(\S+)\s+(\S.*)$" ){
				push @{$vhostvservice2rules{$vhostvservice}}, [$1, $2, {%option}];
			}else{
				die "$f:$.: illegal format, stopped";
			}
		}
		close $h;

		while( my ($host, $hosttype) = each %host2hosttype ){
			foreach my $vhostvservice ( sort keys %vhostvservices ){
				my ($vhost, $vservice) = split m"\s+", $vhostvservice;
				my $rules = $vhostvservice2rules{$vhostvservice};
				my $f = "$WORKDIR/ncrtagent/$host/$conf.$vhost.$vservice";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				my %option;
				foreach my $rule ( @$rules ){
					my ($targethost, $item, $targetoption) = @$rule;
					next unless $host eq $targethost;
					my %d = diff %option, %$targetoption;
					while( my ($k, $v) = each %d ){
						print $h "$k=$v\n";
						$option{$k} = $v;
					}
					print $h $item, "\n";
				}
				close $h;
			}
		}
		foreach my $master ( @ncrtmasters ){
			foreach my $vhostvservice ( sort keys %vhostvservices ){
				my ($vhost, $vservice) = split m"\s+", $vhostvservice;
				my $rules = $vhostvservice2rules{$vhostvservice};
				my $f = "$WORKDIR/ncrtmaster/$master/$conf.$vhost.$vservice";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				my %marked;
				foreach my $rule ( @$rules ){
					my $host = $rule->[0];
					next if $marked{$host};
					print $h $host, "\n";
					$marked{$host} = 1;
				}
				close $h;
			}
		}
	}
}

#### generate confs for which service type is composite
my %host2service2importspecs;
while( my ($service, $servicetype) = each %service2servicetype ){
	last unless $plan{step7};
	next unless $servicetype eq 'composite';
	my @confs = @{$service2conf{$service}};

	foreach my $conf ( @confs ){
		my %vhost2vservice2rules;
		my $vhost;
		my $vservice;
		my $f = "$CONFDIR/$conf";
		open my $h, '<', $f or do {
			die "$f: cannot open, stopped";
		};
		while( <$h> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+<\s+(\S+(\s+\S+)*)\s+===$" ){
				$vhost = $1;
				$vservice = $2;
				my $importspecs = $3;
				$vhosts{$vhost} = 1;
				push @{$host2service2importspecs{$vhost}->{$vservice}}, split m"\s+", $importspecs;
			}else{
				next if $vhost eq "";
				next if $vservice eq "";
				push @{$vhost2vservice2rules{$vhost}->{$vservice}}, $_;
			}
		}
		close $h;

		foreach my $master ( @ncrtmasters ){
			while( my ($vhost, $vservice2rules) = each %vhost2vservice2rules ){
				while( my ($vservice, $rules) = each %$vservice2rules ){
					my $f = "$WORKDIR/ncrtmaster/$master/$conf.$vhost.$vservice";
					open my $h, '>', $f or do {
						die "$f: cannot open, stopped";
					};
					foreach my $rule ( @$rules ){
						print $h $rule, "\n";
					}
					close $h;
				}
			}
		}
	}
}

#### generate thresholds for which service type is agent (DEPRECATED)
#while( my ($service, $servicetype) = each %service2servicetype ){
#	last unless $plan{step7};
#	next unless $servicetype eq 'agent';
#	my $f = "$CONFDIR/threshold/$service.thresholds";
#	open my $h, '<', $f or do {
#		die "$f: cannot open, stopped";
#	};
#	my @rules;
#	while( <$h> ){
#		chomp;
#		next if m"^\s*(#|$)";
#		if( m"^(\S+)\s+(\S.*)$" ){
#			push @rules, [qr"$1", $2];
#		}else{
#			die "$f:$.: illegal format, stopped";
#		}
#	}
#	close $h;
#
#	while( my ($host, $hosttype) = each %host2hosttype ){
#		my $f = "$WORKDIR/ncrtagent/$host/threshold/$service.thresholds";
#		open my $h, '>', $f or do {
#			die "$f: cannot open, stopped";
#		};
#		foreach my $rule ( @rules ){
#			next unless $host =~ $rule->[0];
#			print $h $rule->[1], "\n";
#		}
#		close $h;
#	}
#}

#### generate thresholds for which service type is master (DEPRECATED)
#while( my ($service, $servicetype) = each %service2servicetype ){
#	last unless $plan{step7};
#	next unless $servicetype eq 'master';
#	my $f = "$CONFDIR/threshold/$service.thresholds";
#	open my $h, '<', $f or do {
#		die "$f: cannot open, stopped";
#	};
#	my @rules;
#	my $vhost_re;
#	while( <$h> ){
#		chomp;
#		next if m"^\s*(#|$)";
#		if( m"^===\s+(\S+)\s+===$" ){
#			$vhost_re = qr"$1";
#		}elsif( m"^\S+" ){
#			push @rules, [$vhost_re, $_];
#		}else{
#			die "$f:$.: illegal format, stopped";
#		}
#	}
#	close $h;
#
#	foreach my $master ( @ncrtmasters ){
#		while( my ($vhost) = each %vhosts ){
#			my $f = "$WORKDIR/ncrtmaster/$master/threshold/$service.thresholds.$vhost";
#			open my $h, '>', $f or do {
#				die "$f: cannot open, stopped";
#			};
#	
#			foreach my $rule ( @rules ){
#				next unless $vhost =~ $rule->[0];
#				print $h $rule->[1], "\n";
#			}
#			close $h;
#		}
#	}
#}
	
#### generate thresholds for which service type is gateway / composite (DEPRECATED)
#while( my ($service, $servicetype) = each %service2servicetype ){
#	last unless $plan{step7};
#	next unless $servicetype eq 'gateway' || $servicetype eq 'composite';
#	my $f = "$CONFDIR/threshold/$service.thresholds";
#	open my $h, '<', $f or do {
#		die "$f: cannot open, stopped";
#	};
#	my @rules;
#	my $vhost_re;
#	my $vservice_re;
#	while( <$h> ){
#		chomp;
#		next if m"^\s*(#|$)";
#		if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
#			$vhost_re = qr"$1";
#			$vservice_re = qr"$2";
#		}elsif( m"^\S+" ){
#			push @rules, [$vhost_re, $vservice_re, $_];
#		}else{
#			die "$f:$.: illegal format, stopped";
#		}
#	}
#	close $h;
#
#	foreach my $master ( @ncrtmasters ){
#		foreach my $vhostvservice ( sort keys %vhostvservices ){
#			my ($vhost, $vservice) = split m"\s+", $vhostvservice;
#			my $f = "$WORKDIR/ncrtmaster/$master/threshold/$service.thresholds.$vhost.$vservice";
#			open my $h, '>', $f or do {
#				die "$f: cannot open, stopped";
#			};
#	
#			foreach my $rule ( @rules ){
#				next unless $vhost    =~ $rule->[0];
#				next unless $vservice =~ $rule->[1];
#				print $h $rule->[2], "\n";
#			}
#			close $h;
#		}
#	}
#}

#### generate statistics / thresholds
if( $plan{step7} ){
	##
	my $f = "$CONFDIR/statistic";
	opendir my $h, $f or do {
		die "$f: cannot open, stopped";
	};
	my @rules;
	foreach my $e ( sort readdir $h ){
		next unless $e =~ m"^\w.*\.statistics$";
		my $vhost_re;
		my $vservice_re;
		my $g = "$f/$e";
		open my $i, "<", $g or do {
			die "$f: cannot open, stopped";
		};
		while( <$i> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhost_re = qr"$1";
				$vservice_re = qr"$2";
			}elsif( m"^\S+" ){
				push @rules, [$vhost_re, $vservice_re, $_];
			}else{
				die "$g:$.: illegal format, stopped";
			}
		}
		close $i;
	}
	closedir $h;

	foreach my $i ( @host_vservice_rservice_opts ){
		my ($host, $vservice, $rservice, $opts) = @$i;
		my $servicetype = $service2servicetype{$rservice};

		my $f;
		if( $servicetype eq 'agent' ){
			my $f = "$WORKDIR/ncrtagent/$host/statistic/statistics.$vservice";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				next unless $vservice =~ $rule->[1];
				print $h $rule->[2], "\n";
			}
			close $h;
			unlink $f unless -s $f;
		}elsif( $servicetype eq 'master' || $servicetype eq 'gateway' || $servicetype eq 'composite' ){
			foreach my $master ( @ncrtmasters ){
				my $f = "$WORKDIR/ncrtmaster/$master/statistic/statistics.$host.$vservice";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				foreach my $rule ( @rules ){
					next unless $host =~ $rule->[0];
					next unless $vservice =~ $rule->[1];
					print $h $rule->[2], "\n";
				}
				close $h;
				unlink $f unless -s $f;
			}
		}else{
			die "$servicetype, stopped";
		}
	}

	##
	my $f = "$CONFDIR/threshold";
	opendir my $h, $f or do {
		die "$f: cannot open, stopped";
	};
	my @rules;
	foreach my $e ( sort readdir $h ){
		next unless $e =~ m"^\w.*\.thresholds$";
		my $vhost_re;
		my $vservice_re;
		my $g = "$f/$e";
		open my $i, "<", $g or do {
			die "$f: cannot open, stopped";
		};
		while( <$i> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhost_re = qr"$1";
				$vservice_re = qr"$2";
			}elsif( m"^\S+" ){
				push @rules, [$vhost_re, $vservice_re, $_];
			}else{
				die "$g:$.: illegal format, stopped";
			}
		}
		close $i;
	}
	closedir $h;

	foreach my $i ( @host_vservice_rservice_opts ){
		my ($host, $vservice, $rservice, $opts) = @$i;
		my $servicetype = $service2servicetype{$rservice};

		my $f;
		if( $servicetype eq 'agent' ){
			my $f = "$WORKDIR/ncrtagent/$host/threshold/thresholds.$vservice";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				next unless $vservice =~ $rule->[1];
				print $h $rule->[2], "\n";
			}
			close $h;
		}elsif( $servicetype eq 'master' || $servicetype eq 'gateway' || $servicetype eq 'composite' ){
	
			foreach my $master ( @ncrtmasters ){
				my $f = "$WORKDIR/ncrtmaster/$master/threshold/thresholds.$host.$vservice";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				foreach my $rule ( @rules ){
					next unless $host =~ $rule->[0];
					next unless $vservice =~ $rule->[1];
					print $h $rule->[2], "\n";
				}
				close $h;
			}
		}else{
			die "$servicetype, stopped";
		}
	}
}

#exit 0;

if( $plan{step7} ){

	#### write template settings
	my $f = "$WORKDIR/ncrt_hosttemplates.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $hosttype ( sort keys %hosttype2templateopts ){
		my %param = ( 'hosttype' => $hosttype );
		my $ht_topt = $hosttype2templateopts{$hosttype};
		my @settings = generate_settings %$ht_topt, %param;
		####
		print $h
		"define host {\n",
		"	name			ncrt-hosttype-$hosttype\n",
		"	use			ncrt-generic-host\n",
		"	check_command		ncrtmaster_hostcheck\n",
		@settings,
		"	register		0\n",
		"}\n";
	}
	close $h;

	my $f =  "$WORKDIR/ncrt_servicetemplates.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $service ( sort keys %service2servicetype ){
		my %p = ( 'service' => $service );
		my $servicetype = $service2servicetype{$service};
		my $s_topt = $service2templateopts{$service};
		my @settings = generate_settings %$s_topt, %p;
		####
		if( $servicetype eq 'agent' ){
			print $h
			"define service {\n",
			"	name			ncrtagent-$service\n",
			"	check_command		ncrtagent_check\n",
			"	_real			$service\n",
			"	use			ncrt-generic-service\n",
			@settings,
			"	register		0\n",
			"}\n";
		}elsif( $servicetype eq 'master' ){
			print $h
			"define service {\n",
			"	name			ncrtmaster-$service\n",
			"	check_command		ncrtmaster_check\n",
			"	_real			$service\n",
			"	use			ncrt-generic-service\n",
			@settings,
			"	register		0\n",
			"}\n";
		}elsif( $servicetype eq 'gateway' ){
			print $h
			"define service {\n",
			"	name			ncrtgateway-$service\n",
			"	check_command		ncrtmaster_gatewaycheck\n",
			"	_real			$service\n",
			"	use			ncrt-generic-service\n",
			@settings,
			"	register		0\n",
			"}\n";
		}elsif( $servicetype eq 'composite' ){
			print $h
			"define service {\n",
			"	name			ncrtcomposite-$service\n",
			"	check_command		ncrtmaster_compositecheck\n",
			"	_real			$service\n",
			"	use			ncrt-generic-service\n",
			@settings,
			"	register		0\n",
			"}\n";
		}else{
			die;
		}
	}
	close $h;

	#### write settings

	my $f = "$WORKDIR/ncrt_hosts.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $host ( sort keys %host2vservice2rservice ){
		my $hosttype = $host2hosttype{$host} // 'virtual';
		my %p = ( 'hostname' => $host, 'hosttype' => $hosttype );
		my $ht_opt = $hosttype2opts{$hosttype};
		my @settings = generate_settings %$ht_opt, %p;
		my $contacts = generate_shortnamelist $host2contact{$host};
		my $_urlencoded = uri_escape_utf8($host);
		$contacts = "nobody" if $contacts eq "";
		####
		print $h
		"define host {\n",
		"	host_name		$host\n",
		"	use			ncrt-hosttype-$hosttype\n",
		"	contacts		$contacts\n",
		"	_urlencoded		$_urlencoded\n",
		"	_hosttype		$hosttype\n",
		@settings,
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_services.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $host_vservice_rservice_opts ( @host_vservice_rservice_opts ){
		my ($host, $vservice, $rservice, $hs_opts) = @$host_vservice_rservice_opts;
		my $hosttype = $host2hosttype{$host} // 'virtual';
		my $servicetype = $service2servicetype{$rservice};
		my $s_opt = $service2opts{$rservice};
		my %p = ( 'hostname' => $host, 'hosttype' => $hosttype );
		my @settings = (
			generate_settings(%$s_opt, %p),
			generate_settings(%$hs_opts, %p)
		);
		my $contacts = generate_shortnamelist $hostservice2contact{$host, $vservice};
		my $_urlencoded = uri_escape_utf8($vservice);
		$contacts = "nobody" if $contacts eq "";
		####
		if( $servicetype eq 'composite' ){
			my $importmacro = expand_importspec @{$host2service2importspecs{$host}->{$vservice}};

			print $h
			"define service {\n",
			"	host_name		$host\n",
			"	service_description	$vservice\n",
			"	use			ncrt$servicetype-$rservice\n",
			"	contacts		$contacts\n",
			"	_urlencoded		$_urlencoded\n",
			"	check_command		ncrtmaster_compositecheck!$importmacro\n",
			@settings,
			"}\n";
		}else{
			print $h
			"define service {\n",
			"	host_name		$host\n",
			"	service_description	$vservice\n",
			"	use			ncrt$servicetype-$rservice\n",
			"	contacts		$contacts\n",
			"	_urlencoded		$_urlencoded\n",
			@settings,
			"}\n";
		}
	}
	close $h;

	my $f = "$WORKDIR/ncrt_hostgroups.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $group ( sort keys %group2host ){
		my $hosts = generate_shortnamelist $group2host{$group};
		print $h
		"define hostgroup {\n",
		"	hostgroup_name		$group\n",
		"	members			$hosts\n",
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_servicegroups.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $group ( sort keys %group2hostservice ){
		my $hostservices;
		foreach my $hostservice ( @{$group2hostservice{$group}} ){
			$hostservices .= ',' if $hostservices;
			$hostservices .= $hostservice->[0] . ',' . $hostservice->[1];
		}
		print $h
		"define servicegroup {\n",
		"	servicegroup_name	$group\n",
		"	members			$hostservices\n",
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_users.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $user ( sort keys %users ){
		print $h
		"define contact {\n",
		"	contact_name		$user\n",
		"	host_notification_commands	ncrtmaster_do_nothing\n",
		"	service_notification_commands	ncrtmaster_do_nothing\n",
		"	host_notification_period	ncrt_notime\n",
		"	service_notification_period	ncrt_notime\n",
		"	host_notification_options	n\n",
		"	service_notification_options	n\n",
		"	host_notifications_enabled	0\n",
		"	service_notifications_enabled	0\n",
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_addresses.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $address ( sort keys %addresses ){
		print $h
		"define contact {\n",
		"	contact_name			$address\n",
		"	email				$address\n",
		"	host_notification_commands	ncrtmaster_do_nothing\n",
		"	service_notification_commands	ncrtmaster_alertspooler\n",
		"	host_notification_period	ncrt_anytime\n",
		"	service_notification_period	ncrt_anytime\n",
		"	host_notification_options	n\n",
		"	service_notification_options	w,u,c,r\n",
		"	host_notifications_enabled	0\n",
		"	service_notifications_enabled	1\n",
		"}\n";
	}
	close $h;
}

######## Step 8. ########

my $ncrtmasterhosts = join( ',', @ncrtmasters );

####
my $f = "$WORKDIR/vars.yml";
open my $h, '>', $f or do {
	die "$f: cannot open, stopped";
};
print $h <<"EOF";
---

 HELPERURL:           "$HELPERURL"
 GRAFANADB:           "$GRAFANADB"
 GRAFANAUSER:         "$GRAFANAUSER"
 GRAFANAPASSWD:       "$GRAFANAPASSWD"
 GRAFANAORGID:        "$GRAFANAORGID"
 NCRTAGENTHOME:       "$NCRTAGENTHOME"
 NCRTMASTERHOME:      "$NCRTMASTERHOME"
 NAEMON2INFLUX_DEB:   "$NAEMON2INFLUX_DEB"
 INFLUXDBHOST:        "$INFLUXDBHOST"
 INFLUXDBPORT:        "$INFLUXDBPORT"
 INFLUXDBADMINUSER:   "$INFLUXDBADMINUSER"
 INFLUXDBADMINPASSWD: "$INFLUXDBADMINPASSWD"
 INFLUXDBUSER:        "$INFLUXDBUSER"
 INFLUXDBPASSWD:      "$INFLUXDBPASSWD"
 INFLUXDBDATABASE:    "$INFLUXDBDATABASE"
 AGENTPACKAGE:	      "$AGENTPACKAGE"
 NRPEPORT:            "$NRPEPORT"
 NRPETLS:             "$NRPETLS"
 NRPEALLOWEDHOSTS:    "$NRPEALLOWEDHOSTS"
 NCRTMASTERHOSTS:     "$ncrtmasterhosts"
EOF
close $h;

#exit 0;

####
my $tags = 'common';
unless( $quick ){
	my $tags = ',commoninstall';
	if   ( lc($AGENTPACKAGE) eq 'nrpe' )   { $tags .= ',nrpe'; }
	elsif( lc($AGENTPACKAGE) eq 'nrpe-ng' ){ $tags .= ',nrpe-ng'; }
	else{ die "AGENTPACKAGE: invalid package, stopped"; }
	if   ( lc($NRPETLS) eq 'yes' ){ $tags .= ',nrpetls'; }
	elsif( lc($NRPETLS) eq 'no' ) {}
	else{ die "NRPETLS: invalid setting, stopped"; }
}

#### run ansible for nagios master
my $hosts = join( ',', @ncrtmasters, '' );
my $options = sprintf "%s -e WORKDIR=%s -e TOOLHOME=%s -i %s -t \"%s\"",
	$ncrtconf{'ANSIBLEOPTIONS'}, $WORKDIR, $TOOLHOME, $hosts, $tags;
if( $plan{step8} ){
	my $r = system "ansible-playbook -v $options $PLAYBOOKSDIR/build_ncrtmaster.yml";
	die unless $r == 0;
}

######## Step 9. ########

#### run ansible for nrpe agent
my $hosts = join( ',', @ncrtagents, '' );
my $options = sprintf "%s -e WORKDIR=%s -e TOOLHOME=%s -i %s -t \"%s\"",
	$ncrtconf{'ANSIBLEOPTIONS'}, $WORKDIR, $TOOLHOME, $hosts, $tags;
if( $plan{step9} ){
	my $r = system "ansible-playbook -v $options $PLAYBOOKSDIR/build_ncrtagent.yml";
	die unless $r == 0;
}




