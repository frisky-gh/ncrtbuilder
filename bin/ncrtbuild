#!/usr/bin/perl

use strict;
use Getopt::Long;
use Cwd 'abs_path';
use URI::Escape;
use Socket;

$0 =~ m"^(.*)/";
our $TOOLHOME = abs_path("$1/..");
our $PLUGINSDIR = "$TOOLHOME/plugins";
our $PLAYBOOKSDIR = "$TOOLHOME/playbooks";
our $CONFDIR = "$TOOLHOME/conf";
our $SRCDIR = "$TOOLHOME/src";
our $TMPDIR = "/tmp";
our $WORKDIR = "$TMPDIR/ncrt_work.$$";

our $AGENTCONFDIR = "$TOOLHOME/ncrtagent/conf";
our $MASTERCONFDIR = "$TOOLHOME/ncrtmaster/conf";
 
my $workdir;
my $master_only;
my $agent_only;
my $threshold_only;
my $dryrun;
my $quick;
my $no_cleanup;
GetOptions (
	'workdir=s' => \$workdir,
	'master-only' => \$master_only,
	'agent-only' => \$agent_only,
	'threshold-only' => \$threshold_only,
	'no-cleanup' => \$no_cleanup,
	'dryrun' => \$dryrun,
	'quick' => \$quick,
) or die "Invalid command line options, stopped";

# step0.  read ncrtbuilder conf (*)
# step1.  generate packages and certs
# step2.  create work dir structure
# step3.  run agenttype plugins
# step4.  run measure plugins
# step5.  run contact plugins
# step6.  read confs generated by plugins (*)
# step7.  generate naemon conf
# step8.  deploy ncrtmasters
# step9.  deploy ncrtagents
# step10. clean up work dir

my %plan = (
	'step0' => 1,
	'step1' => 1,
	'step2' => 1,
	'step3' => 1,
	'step4' => 1,
	'step5' => 1,
	'step6' => 1,
	'step7' => 1,
	'step8' => 1,
	'step9' => 1,
	'step10' => 1,
);

if( $dryrun ){ $plan{step8} = 0; $plan{step9} = 0; }
if( $master_only ){ $plan{step9} = 0; }
if( $agent_only ) { $plan{step8} = 0; }
if( $workdir ){ $WORKDIR = $workdir; }
if( $no_cleanup ){ $plan{step10} = 0; }

####
sub rm_r ($) {
	my ($r) = @_;
	return unless -d $r;
	opendir my $d, $r or do {
		die "$r: cannot open, stopped";
	};
	my @e = readdir $d;
	foreach my $e ( @e ){
		next if $e eq '..' || $e eq '.';
		if( -d "$r/$e" ){
			rm_r( "$r/$e" );
		}else{
			unlink "$r/$e" or die "$r/$e, stopped";
		}
	}
	closedir $d;
	rmdir $r or die "$r: cannot remove, stopped";
}

sub mkdir_or_die ($) {
	my ($d) = @_;
	return if -d $d;
	mkdir $d or die "$d: cannot create, stopped";
}

sub create_or_die ($) {
	my ($f) = @_;
	open my $h, '>', $f or die "$f: cannot create, stopped";
	close $h;
}

sub _parse_option ($) {
	( $_ ) = @_;
	my %opt;
	my %templateopt;
	while( m{\G
		($|\s+
			(\@)?(\w+)=
			(?:
				"([^\\"]*(?:(?:\\\\|\\")+[^\\"]*)*)"|
				([\w\!\#-\&\(-\/\:-\@\[-\_\{-\~]+)
			)
		)
	}gx ){
		return \%opt, \%templateopt if $1 eq '';

		my $template = $2;
		my $key = $3;
		my $value = $4 ne '' ? $4 : $5;

		if( $template ){ $templateopt{$key} = $value; }
		else           { $opt{$key} = $value; }
	}
	return undef;
}

sub parse_itementry ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef if m"^\s*(#|$)";
	return undef, "illegal format" unless m"^(\w+)"g;
	my $item = $1;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $item, $opt, $topt;
}

sub parse_addressentry ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef if m"^\s*(#|$)";
	return undef, "illegal format" unless m"^(\S+\@[-.a-zA-Z0-9]+)"g;
	my $item = $1;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $item, $opt, $topt;
}

sub parse_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, "illegal format" unless m"^(\S+)\s+([\w,]+)"g;
	my $from = $1;
	my $to = $2;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $from, $to, $opt, $topt;
}

sub parse_3items_with_option_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, "illegal format" unless m"^(\S+)\s+(\S+)\s+(\S+)";
	my $first  = $1;
	my $second = $2;
	my $third  = $3;
	my ($opt, $topt) = _parse_option $';
	return undef unless defined $opt;
	return $first, $second, $third, $opt, $topt;
}

sub parse_host2item_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, "illegal format" unless m"^(\S+)\s+(\S+)$";
	return $1, $2, undef;
}

sub parse_host2service2item_mapping ($) {
	( $_ ) = @_;
	chomp;
	return undef, undef, undef, undef if m"^\s*(#|$)";
	return undef, undef, undef, "illegal format" unless m"^(\S+)\s+([\w,]+)\s+(\S+)$";
	return $1, $2, $3, undef;
}

sub expand_importspec (@){
	my @importmacros;
	foreach my $i ( @_ ){
		my ($host, $service, $prefix) = @$i;

		# TODO: check host / service

		push @importmacros,
			"$host:$service:$prefix \$SERVICEPERFDATA:$host:$service\$";
	}
	my $importmacro = join " ", @importmacros;
	return $importmacro;
}

sub expand_params ($\%) {
	my ($text, $params) = @_;
	$text =~ s{ \%(\w+)\% }{ $params->{$1}; }egx;
	return $text;
}

END {
	if( $plan{step10} ){
		rm_r $WORKDIR if -d $WORKDIR;
	}
}

######## Step 0. ########

exit 0 unless $plan{step0};

#### load template conf.
my %ncrtconf;
my $f = "$CONFDIR/ncrtbuild.conf";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	next if m"^\s*(#|$)";
	m"^(\w+)=(.*)$" or die "$f:$.: illegal format, stopped";
	$ncrtconf{$1} = $2;
}
close $h;

our $ANSIBLEOPTIONS      = $ncrtconf{'ANSIBLEOPTIONS'};

our $NCRTAGENTHOME       = $ncrtconf{'NCRTAGENTHOME'};
our $AGENTPACKAGE	 = $ncrtconf{'AGENTPACKAGE'} || 'nrpe';
our $NRPEPORT	         = $ncrtconf{'NRPEPORT'} // '5666';
our $NRPETLS	         = $ncrtconf{'NRPETLS'} // 'yes';
our $NRPEALLOWEDHOSTS	 = $ncrtconf{'NRPEALLOWEDHOSTS'};

our $NCRTMASTERHOME      = $ncrtconf{'NCRTMASTERHOME'};

our $GRAFANAURL          = $ncrtconf{'GRAFANAURL'} // 'http://example.com/grafana';
our $GRAFANADATASOURCE   = $ncrtconf{'GRAFANADATASOURCE'};
our $GRAFANAUSER         = $ncrtconf{'GRAFANAUSER'};
our $GRAFANAPASSWD       = $ncrtconf{'GRAFANAPASSWD'};
our $GRAFANAORGID        = $ncrtconf{'GRAFANAORGID'};
our $GRAFANAAPIKEY       = $ncrtconf{'GRAFANAAPIKEY'};

our $INFLUXDBHOST	 = $ncrtconf{'INFLUXDBHOST'} // 'localhost';
our $INFLUXDBPORT	 = $ncrtconf{'INFLUXDBPORT'} // '8086';
our $INFLUXDBADMINUSER   = $ncrtconf{'INFLUXDBADMINUSER'}   // 'admin';
our $INFLUXDBADMINPASSWD = $ncrtconf{'INFLUXDBADMINPASSWD'} // 'admin';
our $INFLUXDBUSER	 = $ncrtconf{'INFLUXDBUSER'}     // 'naemon';
our $INFLUXDBPASSWD      = $ncrtconf{'INFLUXDBPASSWD'}   // 'naemon';
our $INFLUXDBDATABASE    = $ncrtconf{'INFLUXDBDATABASE'} // 'naemon';

our $HELPERURL           = $ncrtconf{'HELPERURL'} // 'http://example.com/naemon2influx-grafana-helper';

sub get_naemon2influx_deb ($) {
	my ($d) = @_;
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	while( my $e = readdir $h ){
		next unless $e =~ m"^naemon2influx-\d.*\.deb$";
		return $e;
	}
	closedir $h;
	return undef;
}

sub get_naemon2influx_grafana_helper_deb ($) {
	my ($d) = @_;
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	while( my $e = readdir $h ){
		next unless $e =~ m"^naemon2influx-grafana-helper_.*\.deb$";
		return $e;
	}
	closedir $h;
	return undef;
}

our $NAEMON2INFLUX_DEB                = get_naemon2influx_deb $CONFDIR;
our $NAEMON2INFLUX_GRAFANA_HELPER_DEB = get_naemon2influx_grafana_helper_deb $CONFDIR;

#### load ncrtmaster.conf
my @ncrtmasters;
my @ncrtmasteraddrs;
my $f = "$CONFDIR/master.hosts";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	next if m"^\s*(#|$)";
	push @ncrtmasters, $_;
	my ( $name, $aliases, $addrtype, $length, @addrs ) = gethostbyname $_;
	foreach my $addr ( @addrs ){
		my $a = inet_ntoa $addr;
		push @ncrtmasteraddrs, $a;
	}
}
close $h;
$NRPEALLOWEDHOSTS = join ",", @ncrtmasteraddrs if $NRPEALLOWEDHOSTS eq '';

#### load metricsmerge settings
my $d = "$CONFDIR/metricmerge";
opendir my $h, $d or do {
	die "$d: cannot open, stopped";
};
my %vhost2vservice2importspecs;
foreach my $e ( sort readdir $h ){
	next unless $e =~ m"^\w.*\.mergerules$";
	my $vhost;
	my $vservice;

	my $f = "$d/$e";
	open my $i, "<", $f or do {
		die "$f: cannot open, stopped";
	};
	while( <$i> ){
		chomp;
		next if m"^\s*(#|$)";
		if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
			$vhost = $1;
			$vservice = $2;
		}elsif( m"^import\s+(\S+)\s+(\S+)" ){
			my $importhost = $1;
			my $importservice = $2;

			push @{$vhost2vservice2importspecs{$vhost}->{$vservice}}, [$importhost, $importservice];
		}else{
			die "$f:$.: illegal format, stopped";
		}
	}
	close $i;
}
close $h;

#### find all plugins
my @agenttype_plugins;
my @measure_plugins;
my @contact_plugins;
opendir my $d, $PLUGINSDIR or do {
	die "$PLUGINSDIR: cannot open, stopped";
};
while( my $e = readdir $d ){
	next unless $e =~ m"^ncrtbuild(?:(measure)|(agenttype)|(contact))_";
	push @measure_plugins,  $e if $1;
	push @agenttype_plugins, $e if $2;
	push @contact_plugins,  $e if $3;
}
closedir $d;

######## Step 1. ########

if( $plan{step1} ){

	#### build naemon2influx package
	if( not defined $NAEMON2INFLUX_DEB ){
		unless( -d "$SRCDIR/naemon2influx" ){
			my $r = system "git clone --depth=1 https://github.com/hakong/naemon2influx.git $SRCDIR/naemon2influx";
			die unless $r == 0;
		}
		my $r = system "make deb -C $SRCDIR/naemon2influx";
		die unless $r == 0;
		$NAEMON2INFLUX_DEB = get_naemon2influx_deb "$SRCDIR/naemon2influx";
		defined $NAEMON2INFLUX_DEB or
			die "naemon2influx: cannot build package, stopped";
		my $r = system "cp $SRCDIR/naemon2influx/$NAEMON2INFLUX_DEB $CONFDIR/$NAEMON2INFLUX_DEB";
		die unless $r == 0;
	}

	#### build naemon2influx-grafana-helper package
	if( not defined $NAEMON2INFLUX_GRAFANA_HELPER_DEB ){
		unless( -d "$SRCDIR/naemon2influx-grafana-helper" ){
			my $r = system "git clone --depth=1 https://github.com/frisky-gh/naemon2influx-grafana-helper.git $SRCDIR/naemon2influx-grafana-helper";
			die unless $r == 0;
		}
		my $r = system "cd $SRCDIR/naemon2influx-grafana-helper && dpkg-buildpackage -us -uc";
		die unless $r == 0;
		$NAEMON2INFLUX_GRAFANA_HELPER_DEB = get_naemon2influx_grafana_helper_deb $SRCDIR;
		defined $NAEMON2INFLUX_GRAFANA_HELPER_DEB or
			die "naemon2influx-grafana-helper: cannot build package, stopped";
		my $r = system "cp $SRCDIR/$NAEMON2INFLUX_GRAFANA_HELPER_DEB $CONFDIR/$NAEMON2INFLUX_GRAFANA_HELPER_DEB";
		die unless $r == 0;
	}

	#### create server cert. if not exists
	if( ! -f "$CONFDIR/ncrt_key.pem" ){
		my $r = system "openssl req -verbose -subj '/C=JP/ST=Kanagawa-ken/O=Watao Family/CN=*' -x509 -newkey rsa:2048 -nodes -keyout $CONFDIR/ncrt_key.pem -out $CONFDIR/ncrt_cert.pem -days 36525";
		die unless $r == 0;
	}
}

######## Step 2. ########

if( $plan{step2} ){

	#### initialize fixed work dirs and files
	rm_r $WORKDIR if -d $WORKDIR;
	mkdir_or_die $WORKDIR;
	mkdir_or_die "$WORKDIR/ncrtmaster";
	mkdir_or_die "$WORKDIR/ncrtagent";

	# hostname -> agenttype mappings
	create_or_die "$WORKDIR/hosts";

	# agenttype list
	create_or_die "$WORKDIR/agenttypes";

	# measure list
	create_or_die "$WORKDIR/measures";

	# measure -> configuration file multi-mappings
	create_or_die "$WORKDIR/measure2conf";

	# hostname -> service multi-mapping
	create_or_die "$WORKDIR/host2service2measure";

	# hostname -> contact multi-mapping
	create_or_die "$WORKDIR/host2contact";

	# hostname -> service -> contact multi-mapping
	create_or_die "$WORKDIR/host2service2contact";

	# hostname -> groupname multi-mapping
	create_or_die "$WORKDIR/host2group";

	# hostname -> service -> groupname multi-mapping
	create_or_die "$WORKDIR/host2service2group";

	# username list
	create_or_die "$WORKDIR/users";

	# email address list
	create_or_die "$WORKDIR/addresses";

	# add metricmerge virtual-services
	my $f = "$WORKDIR/host2service2measure";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $host ( sort keys %vhost2vservice2importspecs ){
		my $vservice2importspecs = $vhost2vservice2importspecs{$host};
		foreach my $service ( sort keys %$vservice2importspecs ){
			print $h "$host	$service	metricmerge\n";
		}
	}
	close $h;

	#### write templates
	my $action_url = "${HELPERURL}/redirect.html?hostname=\$_HOSTURLENCODED\$&servicedesc=\$_SERVICEURLENCODED\$";
	my $f = "$WORKDIR/ncrt_hosttemplates.cfg";
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	print $h <<"EOF";
# host settings for Nagios / Naemon

define host {
	name				ncrt-generic-host
	
	check_command			ncrt-check-host
	check_interval			4
	retry_interval			1
	max_check_attempts		3
	check_period			24x7

	notifications_enabled		1
	notification_interval		60
	notification_options		d,u,r
	notification_period		24x7
	contact_groups			

	process_perf_data		1
	event_handler_enabled		1	; Host event handler is enabled
	flap_detection_enabled		1	; Flap detection is enabled
	retain_nonstatus_information	1       ; Retain non-status information across program restarts
	retain_status_information	1       ; Retain status information across program restarts

	register			0	; DONT REGISTER THIS DEFINITION - ITS NOT A REAL HOST, JUST A TEMPLATE!

}

EOF
	close $h;
	my $f = "$WORKDIR/ncrt_servicetemplates.cfg";
	open my $h, '>', $f or do {
		die "$f: cannot open, stopped";
	};
	print $h <<"EOF";
# service settings for Nagios / Naemon

define service {
	name				ncrt-generic-service

	active_checks_enabled		1
	passive_checks_enabled		1
	check_freshness			0       ; Default is to NOT check service 'freshness'
	check_interval			4
	retry_interval			1
	max_check_attempts		3
	check_period			24x7

	notifications_enabled		1
	notification_interval		60
	notification_options		w,u,c,r
	notification_period		24x7
	contact_groups			

	is_volatile			0       ; The service is not volatile
	obsess_over_service		1       ; We should obsess over this service (if necessary)
	process_perf_data		1
	event_handler_enabled		1       ; Service event handler is enabled
	flap_detection_enabled		1       ; Flap detection is enabled
	retain_nonstatus_information	1       ; Retain non-status information across program restarts
	retain_status_information	1       ; Retain status information across program restarts

	action_url			$action_url

	register			0	; DONT REGISTER THIS DEFINITION - ITS NOT A REAL SERVICE, JUST A TEMPLATE!
}

EOF
	close $h;

}

######## Step 3. ########

if( $plan{step3} ){
	#### run agenttype plugins
	foreach my $e ( sort @agenttype_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		my $r = system "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
		print "r=", $r, "\n";
		die unless $r == 0;
	}
}

######## Step 4. ########

if( $plan{step4} ){
	#### run measurement plugins
	foreach my $e ( sort @measure_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		my $r = system "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
		print "r=", $r, "\n";
		die unless $r == 0;
	}
}

######## Step 5. ########

if( $plan{step5} ){
	#### run contact plugins
	foreach my $e ( sort @contact_plugins ){
		print "$PLUGINSDIR/$e $CONFDIR $WORKDIR\n";
		my $r = system "$PLUGINSDIR/$e $CONFDIR $WORKDIR";
		print "r=", $r, "\n";
		die unless $r == 0;
	}
}

######## Step 6. ########

exit 0 unless $plan{step6};

#### initialize variable work dirs.
my %host2agenttype;
my $agenttype_has_collision;
my $f = "$WORKDIR/hosts";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	my ($host, $agenttype) = split m"\s+";
	if( not defined $host2agenttype{$host} ){
		$host2agenttype{$host} = $agenttype;
	}elsif( $host2agenttype{$host} ne $agenttype ){
		print "ERROR: host $host has multiple agenttypes.\n";
		$agenttype_has_collision = 1;
	}
}
close $h;

die "Some agenttype have collisions, stopped" if $agenttype_has_collision;

my @ncrtagents;
while( my ($h, $t) = each %host2agenttype ){
	push @ncrtagents, $h if $t =~ m"(linux)";
}

foreach my $h ( @ncrtmasters ){
	mkdir_or_die "$WORKDIR/ncrtmaster/$h";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/agentless";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/indirect";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/threshold";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/metricmerge";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/metricfilter";
	mkdir_or_die "$WORKDIR/ncrtmaster/$h/thresholdfilter";
	my $r = system "rsync -aSvx $MASTERCONFDIR/ $WORKDIR/ncrtmaster/$h/";
	die unless $r == 0;
}
foreach my $h ( @ncrtagents ){
	mkdir_or_die "$WORKDIR/ncrtagent/$h";
	mkdir_or_die "$WORKDIR/ncrtagent/$h/agent";
	mkdir_or_die "$WORKDIR/ncrtagent/$h/indirect";
	mkdir_or_die "$WORKDIR/ncrtagent/$h/threshold";
	mkdir_or_die "$WORKDIR/ncrtagent/$h/metricfilter";
	mkdir_or_die "$WORKDIR/ncrtagent/$h/thresholdfilter";
	my $r = system "rsync -aSvx $AGENTCONFDIR/ $WORKDIR/ncrtagent/$h/";
	die unless $r == 0;
}

#### read settings generated by plugins
my %agenttype2opts         = ( 'virtual' => {
	'display_name' => 'Virtual:%hostname%',
	'address' => '127.0.0.1',
} );
my %agenttype2templateopts = ( 'virtual' => {
} );
my $f = "$WORKDIR/agenttypes";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($agenttype, $opts, $templateopts) = parse_itementry $_;
	print "$f:$.:$opts\n" if !defined $agenttype && defined $opts;
	next unless $agenttype;
	$agenttype2opts{$agenttype} = $opts;
	$agenttype2templateopts{$agenttype} = $templateopts;
}
close $h;

my %measure2measuretype = ( 'metricmerge' => 'metricmerge' );
my %measure2opts;
my %measure2templateopts;
my $f = "$WORKDIR/measures";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($measure, $measuretype, $opts, $templateopts) = parse_mapping $_;
	print "$f:$.:$opts\n" if !defined $measure && defined $opts;
	next unless $measure;
	$measure2measuretype{$measure} = $measuretype;
	$measure2opts{$measure} = $opts;
	$measure2templateopts{$measure} = $templateopts;
}
close $h;

my %host2service2measure;
my @host_service_measure_opts;
my $f = "$WORKDIR/host2service2measure";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $service, $measure, $opts) = parse_3items_with_option_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	$host2service2measure{$host}->{$service} = $measure;
	push @host_service_measure_opts, [$host, $service, $measure, $opts];
}
close $h;

my %host2contact;
my $f = "$WORKDIR/host2contact";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $contact, $opts) = parse_host2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$host2contact{$host}}, $contact;
}
close $h;

my %host2service2contact;
my $f = "$WORKDIR/host2service2contact";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $service, $contact, $opts) = parse_host2service2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$host2service2contact{$host}->{$service}}, $contact;
}
close $h;

my %group2host;
my $f = "$WORKDIR/host2group";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $group, $opts) = parse_host2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	push @{$group2host{$group}}, $host;
}
close $h;

my %group2host2service;
my $f = "$WORKDIR/host2service2group";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($host, $service, $group, $opts) = parse_host2service2item_mapping $_;
	print "$f:$.:$opts\n" if !defined $host && defined $opts;
	next unless $host;
	$group2host2service{$group}->{$host}->{$service} = 1;
}
close $h;

my %users = ( nobody => "" );
my $f = "$WORKDIR/users";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($user, $opts) = parse_itementry $_;
	print "$f:$.:$opts\n" if !defined $user && defined $opts;
	next unless $user;
	$users{$user} = $opts;
}
close $h;

my %addresses;
my $f = "$WORKDIR/addresses";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	my ($address, $opts) = parse_addressentry $_;
	print "$f:$.:$opts\n" if !defined $address && defined $opts;
	next unless $address;
	$addresses{$address} = $opts;
}
close $h;

####
my %measure2conf;
my $f = "$WORKDIR/measure2conf";
open my $h, '<', $f or do {
	die "$f: cannot open, stopped";
};
while( <$h> ){
	chomp;
	my ($service, $conf) = split m"\s+";
	push @{$measure2conf{$service}}, $conf;
}
close $h;

######## Step 7. ########

sub generate_settings (\%\%) {
	my ($opts, $params) = @_;
	my @settings;
	foreach my $k ( sort keys %{$opts} ){
		my $v = $opts->{$k};
		push @settings, sprintf "\t%-23s\t%s\n",
			$k, expand_params $v, %$params;
	}
	return @settings;
}

sub generate_shortnamelist ($) {
	return '' unless defined $_[0];
	return join ',', @{$_[0]};
}

#### generate confs for which service type is agent
while( my ($measure, $measuretype) = each %measure2measuretype ){
	last unless $plan{step7};
	next unless $measuretype eq 'agent';
	my @confs = @{$measure2conf{$measure} // []};

	foreach my $conf ( @confs ){
		my @rules;
		my $f = "$CONFDIR/$conf";
		open my $h, '<', $f or do {
			die "$f: cannot open, stopped";
		};
		while( <$h> ){
			chomp;
			next if m"^\s*(#|$)";
			m"^(\S+)\s+(.*)" or
				die "$f:$.: illegal format, stopped";
			push @rules, [qr"$1", $2];
		}
		close $h;

		while( my ($host, $agenttype) = each %host2agenttype ){
			my $f = "$WORKDIR/ncrtagent/$host/$conf";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				print $h $rule->[1], "\n";
			}
			close $h;
		}
	}
}

#### generate confs for which service type is agentless
my %vhosts;
while( my ($measure, $measuretype) = each %measure2measuretype ){
	last unless $plan{step7};
	next unless $measuretype eq 'agentless';
	my @confs = @{$measure2conf{$measure}};

	foreach my $conf ( @confs ){
		my %vhost2rules;
		my $vhost;
		my $f = "$CONFDIR/$conf";
		open my $h, '<', $f or do {
			die "$f: cannot open, stopped";
		};
		while( <$h> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+===$" ){
				$vhost = $1;
				$vhosts{$vhost} = 1;
			}elsif( m"^(\S+)" ){
				push @{$vhost2rules{$vhost}}, $_;
			}else{
				die "$f:$.: illegal format, stopped";
			}
		}
		close $h;

		foreach my $master ( @ncrtmasters ){
			while( my ($vhost, $rules) = each %vhost2rules ){
				my $f = "$WORKDIR/ncrtmaster/$master/$conf.$vhost";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				foreach my $rule ( @$rules ){
					print $h $rule, "\n";
				}
				close $h;
			}
		}
	}
}

#### generate confs for which service type is indirect
sub diff (\%\%) {
	my ($old, $new) = @_;
	my %keys;
	my %d;
	while( my ($k) = each %$old ){ $keys{$k} = 1; }
	while( my ($k) = each %$new ){ $keys{$k} = 1; }
	while( my ($k) = each %keys ){
		my $o = $old->{$k};
		my $n = $new->{$k};
		next if $o eq $n;
		$d{$k} = $n;
	}
	return %d;
}

my %vhostvservices;
while( my ($measure, $measuretype) = each %measure2measuretype ){
	last unless $plan{step7};
	next unless $measuretype eq 'indirect';
	my @confs = @{$measure2conf{$measure}};

	foreach my $conf ( @confs ){
		my %vhostvservice2rules;
		my $vhostvservice;
		my %option;
		my $f = "$CONFDIR/$conf";
		open my $h, '<', $f or do {
			die "$f: cannot open, stopped";
		};
		while( <$h> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhostvservice = "$1 $2";
				$vhostvservices{$vhostvservice} = 1;
				%option = ();
			}elsif( m"^(\w+)=(\S*)$" ){
				$option{$1} = $2;
			}elsif( m"^(\S+)\s+(\S.*)$" ){
				push @{$vhostvservice2rules{$vhostvservice}}, [$1, $2, {%option}];
			}else{
				die "$f:$.: illegal format, stopped";
			}
		}
		close $h;

		while( my ($host, $agenttype) = each %host2agenttype ){
			foreach my $vhostvservice ( sort keys %vhostvservices ){
				my ($vhost, $vservice) = split m"\s+", $vhostvservice;
				my $rules = $vhostvservice2rules{$vhostvservice};
				my $f = "$WORKDIR/ncrtagent/$host/$conf.$vhost.$vservice";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				my %option;
				foreach my $rule ( @$rules ){
					my ($targethost, $item, $targetoption) = @$rule;
					next unless $host eq $targethost;
					my %d = diff %option, %$targetoption;
					while( my ($k, $v) = each %d ){
						print $h "$k=$v\n";
						$option{$k} = $v;
					}
					print $h $item, "\n";
				}
				close $h;
			}
		}
		foreach my $master ( @ncrtmasters ){
			foreach my $vhostvservice ( sort keys %vhostvservices ){
				my ($vhost, $vservice) = split m"\s+", $vhostvservice;
				my $rules = $vhostvservice2rules{$vhostvservice};
				my $f = "$WORKDIR/ncrtmaster/$master/$conf.$vhost.$vservice";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				my %marked;
				foreach my $rule ( @$rules ){
					my $host = $rule->[0];
					next if $marked{$host};
					print $h $host, "\n";
					$marked{$host} = 1;
				}
				close $h;
			}
		}
	}
}

#### generate metricfilter / thresholdfilter settings
sub generate_filter_settings ($\%\@) {
	my ($filtertype, $measure2measuretype, $host_service_measure_opts) = @_;

	##
	my $d = "$CONFDIR/$filtertype";
	opendir my $h, $d or do {
		die "$d: cannot open, stopped";
	};
	my @rules;
	foreach my $e ( sort readdir $h ){
		next unless $e =~ m"^\w.*\.filterrules$";
		my $f = "$d/$e";
		open my $i, "<", $f or do {
			die "$f: cannot open, stopped";
		};
		my $vhost_re;
		my $vservice_re;
		while( <$i> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhost_re = qr"$1";
				$vservice_re = qr"$2";
			}elsif( m"^filter\s+(\S+)" ){
				my $filter = $1;

				# TODO: check filter path

				push @rules, [$vhost_re, $vservice_re, $filter];
			}else{
				die "$f:$.: illegal format, stopped";
			}
		}
		close $i;
	}
	closedir $h;

	foreach my $i ( @$host_service_measure_opts ){
		my ($host, $service, $measure, $opts) = @$i;
		my $measuretype = $$measure2measuretype{$measure};

		my $f;
		if( $measuretype eq 'agent' ){
			my $f = "$WORKDIR/ncrtagent/$host/$filtertype/$filtertype.$service";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				next unless $service =~ $rule->[1];
				print $h $rule->[2], "\n";
			}
			close $h;
			unlink $f unless -s $f;
		}elsif( $measuretype eq 'agentless' || $measuretype eq 'indirect' || $measuretype eq 'metricmerge' ){
			foreach my $master ( @ncrtmasters ){
				my $f = "$WORKDIR/ncrtmaster/$master/$filtertype/$filtertype.$host.$service";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				foreach my $rule ( @rules ){
					next unless $host =~ $rule->[0];
					next unless $service =~ $rule->[1];
					print $h $rule->[2], "\n";
				}
				close $h;
				unlink $f unless -s $f;
			}
		}else{
			die "$measuretype, stopped";
		}
	}
}

my %host2service2metricfilters;
if( $plan{step7} ){
	generate_filter_settings 
		"metricfilter",
		%measure2measuretype,
		@host_service_measure_opts;

	generate_filter_settings 
		"thresholdfilter",
		%measure2measuretype,
		@host_service_measure_opts;
}

#### generate thresholds settings
my %host2service2metricfilters;
if( $plan{step7} ){
	##
	my $f = "$CONFDIR/threshold";
	opendir my $h, $f or do {
		die "$f: cannot open, stopped";
	};
	my @rules;
	foreach my $e ( sort readdir $h ){
		next unless $e =~ m"^\w.*\.thresholds$";
		my $vhost_re;
		my $vservice_re;
		my $g = "$f/$e";
		open my $i, "<", $g or do {
			die "$f: cannot open, stopped";
		};
		while( <$i> ){
			chomp;
			next if m"^\s*(#|$)";
			if( m"^===\s+(\S+)\s+(\S+)\s+===$" ){
				$vhost_re = qr"$1";
				$vservice_re = qr"$2";
			}elsif( m"^\S+" ){
				push @rules, [$vhost_re, $vservice_re, $_];
			}else{
				die "$g:$.: illegal format, stopped";
			}
		}
		close $i;
	}
	closedir $h;

	foreach my $i ( @host_service_measure_opts ){
		my ($host, $service, $measure, $opts) = @$i;
		my $measuretype = $measure2measuretype{$measure};

		my $f;
		if( $measuretype eq 'agent' ){
			my $f = "$WORKDIR/ncrtagent/$host/threshold/thresholds.$host.$service";
			open my $h, '>', $f or do {
				die "$f: cannot open, stopped";
			};
			foreach my $rule ( @rules ){
				next unless $host =~ $rule->[0];
				next unless $service =~ $rule->[1];
				print $h $rule->[2], "\n";
			}
			close $h;
		}elsif( $measuretype eq 'agentless' || $measuretype eq 'indirect' || $measuretype eq 'metricmerge' ){
	
			foreach my $master ( @ncrtmasters ){
				my $f = "$WORKDIR/ncrtmaster/$master/threshold/thresholds.$host.$service";
				open my $h, '>', $f or do {
					die "$f: cannot open, stopped";
				};
				foreach my $rule ( @rules ){
					next unless $host =~ $rule->[0];
					next unless $service =~ $rule->[1];
					print $h $rule->[2], "\n";
				}
				close $h;
			}
		}else{
			die "$measuretype, stopped";
		}
	}
}

#exit 0;

if( $plan{step7} ){

	#### write template settings
	my $f = "$WORKDIR/ncrt_hosttemplates.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $agenttype ( sort keys %agenttype2templateopts ){
		my %param = ( 'agenttype' => $agenttype );
		my $ht_topt = $agenttype2templateopts{$agenttype};
		my @settings = generate_settings %$ht_topt, %param;
		####
		print $h
		"define host {\n",
		"	name			ncrt-agenttype-$agenttype\n",
		"	use			ncrt-generic-host\n",
		"	check_command		ncrtmaster_hostcheck\n",
		@settings,
		"	register		0\n",
		"}\n";
	}
	close $h;

	my $f =  "$WORKDIR/ncrt_servicetemplates.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $measure ( sort keys %measure2measuretype ){
		my %p = ( 'measure' => $measure );
		my $measuretype = $measure2measuretype{$measure};
		my $s_topt = $measure2templateopts{$measure};
		my @settings = generate_settings %$s_topt, %p;
		####
		if( $measuretype eq 'agent' ){
			print $h
			"define service {\n",
			"	name			ncrtagent-$measure\n",
			"	check_command		ncrtagent_detect\n",
			"	_measure		$measure\n",
			"	use			ncrt-generic-service\n",
			@settings,
			"	register		0\n",
			"}\n";
		}elsif( $measuretype eq 'agentless' ){
			print $h
			"define service {\n",
			"	name			ncrtagentless-$measure\n",
			"	check_command		ncrtmaster_detect\n",
			"	_measure		$measure\n",
			"	use			ncrt-generic-service\n",
			@settings,
			"	register		0\n",
			"}\n";
		}elsif( $measuretype eq 'indirect' ){
			print $h
			"define service {\n",
			"	name			ncrtindirect-$measure\n",
			"	check_command		ncrtmaster_detectindirect\n",
			"	_measure		$measure\n",
			"	use			ncrt-generic-service\n",
			@settings,
			"	register		0\n",
			"}\n";
		}elsif( $measuretype eq 'metricmerge' ){
			print $h
			"define service {\n",
			"	name			ncrtmetricmerge-$measure\n",
			"	check_command		ncrtmaster_detectmetricmerge\n",
			"	_measure		$measure\n",
			"	use			ncrt-generic-service\n",
			@settings,
			"	register		0\n",
			"}\n";
		}else{
			die;
		}
	}
	close $h;

	#### write settings

	my $f = "$WORKDIR/ncrt_hosts.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $host ( sort keys %host2service2measure ){
		my $agenttype = $host2agenttype{$host} // 'virtual';
		my %p = ( 'hostname' => $host, 'agenttype' => $agenttype );
		my $ht_opt = $agenttype2opts{$agenttype};
		my @settings = generate_settings %$ht_opt, %p;
		my $contacts = generate_shortnamelist $host2contact{$host};
		my $_urlencoded = uri_escape_utf8($host);
		$contacts = "nobody" if $contacts eq "";
		####
		print $h
		"define host {\n",
		"	host_name		$host\n",
		"	use			ncrt-agenttype-$agenttype\n",
		"	contacts		$contacts\n",
		"	_urlencoded		$_urlencoded\n",
		"	_agenttype		$agenttype\n",
		@settings,
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_services.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $host_service_measure_opts ( @host_service_measure_opts ){
		my ($host, $service, $measure, $hs_opts) = @$host_service_measure_opts;
		my $agenttype = $host2agenttype{$host} // 'virtual';
		my $measuretype = $measure2measuretype{$measure};
		my $s_opt = $measure2opts{$measure};
		my %p = ( 'hostname' => $host, 'agenttype' => $agenttype );
		my @settings = (
			generate_settings(%$s_opt, %p),
			generate_settings(%$hs_opts, %p)
		);
		my $contacts = generate_shortnamelist $host2service2contact{$host}->{$service};
		my $_urlencoded = uri_escape_utf8($service);
		$contacts = "nobody" if $contacts eq "";
		####
		if( $measuretype eq 'metricmerge' ){
			my $importmacro = expand_importspec @{$vhost2vservice2importspecs{$host}->{$service}};

			print $h
			"define service {\n",
			"	host_name		$host\n",
			"	service_description	$service\n",
			"	use			ncrt$measuretype-$measure\n",
			"	contacts		$contacts\n",
			"	_urlencoded		$_urlencoded\n",
			"	check_command		ncrtmaster_detectmetricmerge!$importmacro\n",
			@settings,
			"}\n";
		}else{
			print $h
			"define service {\n",
			"	host_name		$host\n",
			"	service_description	$service\n",
			"	use			ncrt$measuretype-$measure\n",
			"	contacts		$contacts\n",
			"	_urlencoded		$_urlencoded\n",
			@settings,
			"}\n";
		}
	}
	close $h;

	my $f = "$WORKDIR/ncrt_hostgroups.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $group ( sort keys %group2host ){
		my $hosts = generate_shortnamelist $group2host{$group};
		print $h
		"define hostgroup {\n",
		"	hostgroup_name		$group\n",
		"	members			$hosts\n",
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_servicegroups.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $group ( sort keys %group2host2service ){
		my @r;
		my $host2service_map = $group2host2service{$group};
		foreach my $host ( sort keys %{$host2service_map} ){
			my $service_map = $host2service_map->{$host};
			foreach my $service ( sort keys %{$service_map} ){
				push @r, "$host,$service";
			}
		}
		my $r = join ",", @r;
		print $h
			"define servicegroup {\n",
			 "	servicegroup_name	$group\n",
			"	members			$r\n",
			"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_users.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $user ( sort keys %users ){
		print $h
		"define contact {\n",
		"	contact_name		$user\n",
		"	host_notification_commands	ncrtmaster_do_nothing\n",
		"	service_notification_commands	ncrtmaster_do_nothing\n",
		"	host_notification_period	ncrt_notime\n",
		"	service_notification_period	ncrt_notime\n",
		"	host_notification_options	n\n",
		"	service_notification_options	n\n",
		"	host_notifications_enabled	0\n",
		"	service_notifications_enabled	0\n",
		"}\n";
	}
	close $h;

	my $f = "$WORKDIR/ncrt_addresses.cfg";
	open my $h, '>>', $f or do {
		die "$f: cannot open, stopped";
	};
	foreach my $address ( sort keys %addresses ){
		print $h
		"define contact {\n",
		"	contact_name			$address\n",
		"	email				$address\n",
		"	host_notification_commands	ncrtmaster_do_nothing\n",
		"	service_notification_commands	ncrtmaster_alertspooler\n",
		"	host_notification_period	ncrt_anytime\n",
		"	service_notification_period	ncrt_anytime\n",
		"	host_notification_options	n\n",
		"	service_notification_options	w,u,c,r\n",
		"	host_notifications_enabled	0\n",
		"	service_notifications_enabled	1\n",
		"}\n";
	}
	close $h;
}

######## Step 8. ########

####
foreach my $master ( @ncrtmasters ){
	foreach my $f ( "ncrtbuild.conf", "messenger.rules", "messenger_webpage.tt", "messenger_expiredwebpage.tt", "messenger_mail.tt" ){
		my $p = "$CONFDIR/$f";
		open my $h, '<', $p or do {
			die "$p: cannot open, stopped";
		};
		my @r = <$h>;
		close $h;
		my $p = "$WORKDIR/ncrtmaster/$master/$f";
		open my $h, '>', $p or do {
			die "$p: cannot open, stopped";
		};
		print $h @r;
		close $h;
	}
}

####
my $ncrtmasterhosts = join( ',', @ncrtmasters );

my $f = "$WORKDIR/vars.yml";
open my $h, '>', $f or do {
	die "$f: cannot open, stopped";
};
print $h <<"EOF";
---

 HELPERURL:           "$HELPERURL"
 GRAFANAURL:          "$GRAFANAURL"
 GRAFANADATASOURCE:   "$GRAFANADATASOURCE"
 GRAFANAUSER:         "$GRAFANAUSER"
 GRAFANAPASSWD:       "$GRAFANAPASSWD"
 GRAFANAORGID:        "$GRAFANAORGID"
 GRAFANAAPIKEY:       "$GRAFANAAPIKEY"
 NCRTAGENTHOME:       "$NCRTAGENTHOME"
 NCRTMASTERHOME:      "$NCRTMASTERHOME"
 NAEMON2INFLUX_DEB:   "$NAEMON2INFLUX_DEB"
 NAEMON2INFLUX_GRAFANA_HELPER_DEB: "$NAEMON2INFLUX_GRAFANA_HELPER_DEB"
 INFLUXDBHOST:        "$INFLUXDBHOST"
 INFLUXDBPORT:        "$INFLUXDBPORT"
 INFLUXDBADMINUSER:   "$INFLUXDBADMINUSER"
 INFLUXDBADMINPASSWD: "$INFLUXDBADMINPASSWD"
 INFLUXDBUSER:        "$INFLUXDBUSER"
 INFLUXDBPASSWD:      "$INFLUXDBPASSWD"
 INFLUXDBDATABASE:    "$INFLUXDBDATABASE"
 AGENTPACKAGE:	      "$AGENTPACKAGE"
 NRPEPORT:            "$NRPEPORT"
 NRPETLS:             "$NRPETLS"
 NRPEALLOWEDHOSTS:    "$NRPEALLOWEDHOSTS"
 NCRTMASTERHOSTS:     "$ncrtmasterhosts"
EOF
close $h;

#exit 0;

####
my $tags = 'common';
unless( $quick ){
	$tags .= ',commoninstall';
	if   ( lc($AGENTPACKAGE) eq 'nrpe' )   { $tags .= ',nrpe'; }
	elsif( lc($AGENTPACKAGE) eq 'nrpe-ng' ){ $tags .= ',nrpe-ng'; }
	else{ die "AGENTPACKAGE: invalid package, stopped"; }
	if   ( lc($NRPETLS) eq 'yes' ){ $tags .= ',nrpetls'; }
	elsif( lc($NRPETLS) eq 'no' ) {}
	else{ die "NRPETLS: invalid setting, stopped"; }
}

#### run ansible for nagios master
my $hosts = join( ',', @ncrtmasters, '' );
my $options = sprintf "%s -e WORKDIR=%s -e TOOLHOME=%s -i %s -t \"%s\"",
	$ncrtconf{'ANSIBLEOPTIONS'}, $WORKDIR, $TOOLHOME, $hosts, $tags;
if( $plan{step8} ){
	my $r = system "ansible-playbook -v $options $PLAYBOOKSDIR/build_ncrtmaster.yml";
	die unless $r == 0;
}

######## Step 9. ########

#### run ansible for nrpe agent
my $hosts = join( ',', @ncrtagents, '' );
my $options = sprintf "%s -e WORKDIR=%s -e TOOLHOME=%s -i %s -t \"%s\"",
	$ncrtconf{'ANSIBLEOPTIONS'}, $WORKDIR, $TOOLHOME, $hosts, $tags;
if( $plan{step9} ){
	my $r = system "ansible-playbook -v $options $PLAYBOOKSDIR/build_ncrtagent.yml";
	die unless $r == 0;
}



